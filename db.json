{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1581651647996},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1581651647996},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1581651647997},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1581651647997},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1581651647997},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1581651647997},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1581651647998},{"_id":"themes/hexo-theme-next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1581651647998},{"_id":"themes/hexo-theme-next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1581651647998},{"_id":"themes/hexo-theme-next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1581651648000},{"_id":"themes/hexo-theme-next/_config.yml","hash":"ff73c07f5ce3a5bb1661a1c0bbd03286f01fcbdb","modified":1581651648000},{"_id":"themes/hexo-theme-next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1581651648000},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1581651648001},{"_id":"themes/hexo-theme-next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1581651648029},{"_id":"source/_posts/coin.md","hash":"b4d5afc01c30109c3147373228380ad7a18e3887","modified":1545736514271},{"_id":"source/_posts/eth.md","hash":"f1f4550b50b713ed9f60703a5f60976d4e248d46","modified":1545736974386},{"_id":"source/_posts/go_goroutine.md","hash":"140745e4c41d6f1d817bd3a7da024b8e39c14f74","modified":1545736673276},{"_id":"source/_posts/golang_base.md","hash":"4afa4f7f0bf613a8d2b6e35e211c8a02be6066d0","modified":1529552204944},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1529552204944},{"_id":"source/_posts/ipfs.md","hash":"328502d4091d77d4abad1bc1a786d1b3f6cc79dd","modified":1545736717785},{"_id":"source/_posts/solidity_01.md","hash":"273a16e681f4606a99fe9b16fc4c2ed14e656397","modified":1545736874883},{"_id":"source/about/index.md","hash":"a975632c06327137bfa415a3272863fd8f458034","modified":1581651647995},{"_id":"source/categories/index.md","hash":"6bd6d6e51d43396952f4e13ffea08c271d2125aa","modified":1581651647995},{"_id":"source/tags/index.md","hash":"4cfe6910e17efa2676f6bf5975c53ab5814afb85","modified":1581651647996},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1581651648001},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1581651648001},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1581651648002},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1581651648002},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1581651648002},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1581651648003},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1581651648003},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1581651648003},{"_id":"themes/hexo-theme-next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1581651648004},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1581651648004},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1581651648004},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1581651648004},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1581651648005},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1581651648005},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1581651648005},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1581651648006},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1581651648006},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1581651648028},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1581651648028},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1581651648028},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1581651648028},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1581651648029},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1581651648029},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1581651648029},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1581651648030},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1581651648031},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1581651648140},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1581651648140},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1581651648141},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204987},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1581651648006},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1581651648006},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1581651648007},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1581651648007},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1581651648007},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1581651648008},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1581651648008},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1581651648009},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1581651648009},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1581651648009},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1581651648010},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1581651648011},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1581651648011},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1581651648011},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1581651648011},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1581651648014},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1581651648014},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1581651648016},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1581651648024},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1581651648024},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1581651648024},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1581651648024},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1581651648025},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1581651648025},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1581651648025},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1581651648031},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1581651648031},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1581651648032},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1581651648032},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1581651648033},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1581651648033},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1581651648033},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1581651648033},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1581651648033},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1581651648067},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1581651648068},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1529552204988},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1529552204988},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1581651648069},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1581651648069},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1581651648070},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1581651648070},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1581651648070},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1581651648071},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1581651648071},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1529552204989},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1529552204989},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1529552204990},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1581651648072},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1529552204990},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1581651648072},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1581651648072},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1529552204990},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204958},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204958},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204981},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204981},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204981},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204987},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529552204987},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1581651648010},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1581651648010},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1581651648012},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1581651648012},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1581651648012},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1581651648012},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1581651648013},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1581651648013},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1581651648013},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1581651648014},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1581651648015},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1581651648016},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1581651648017},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1581651648017},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1581651648018},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1581651648018},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1581651648018},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1581651648018},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1581651648018},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1581651648019},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1581651648019},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1581651648019},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1581651648019},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1581651648020},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1581651648020},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1581651648020},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1581651648020},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1581651648021},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1581651648022},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1581651648022},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1581651648022},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1581651648022},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1581651648023},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1581651648023},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1581651648026},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1581651648027},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1581651648027},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1581651648027},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1581651648056},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1581651648056},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1581651648057},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1581651648057},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1581651648065},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1581651648065},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1581651648066},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1581651648066},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1581651648073},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1581651648074},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1581651648074},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1581651648074},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1581651648075},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1581651648075},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1581651648075},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1581651648075},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1581651648076},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1581651648076},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1581651648077},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1529552204999},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1529552205004},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1581651648090},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1532602332296},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1532602332296},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1581651648097},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1581651648097},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1581651648098},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1581651648099},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1581651648100},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1581651648100},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1581651648101},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1581651648101},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1581651648101},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1581651648115},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1581651648117},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1581651648117},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1581651648117},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1581651648118},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1581651648118},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1581651648118},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1581651648119},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1581651648120},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1581651648121},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1529552205029},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1529552205029},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1529552205029},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1529552205029},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1529552205029},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1529552205029},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1529552205029},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1529552205030},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1529552205030},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1529552205030},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1529552205030},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1529552205030},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1529552205030},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1581651648125},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1581651648126},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1581651648126},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1581651648127},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1581651648134},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1581651648134},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1581651648139},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1581651648139},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1581651648140},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1581651648116},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1581651648026},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1581651648026},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1581651648034},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1581651648034},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1581651648035},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1581651648035},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1581651648036},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1581651648041},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1581651648047},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1581651648054},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1581651648054},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1581651648054},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1581651648055},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1581651648055},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1581651648055},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1581651648056},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1581651648058},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1581651648058},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1581651648059},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1581651648059},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1581651648060},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1581651648060},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1581651648060},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1581651648060},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1581651648061},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1581651648061},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1581651648062},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1581651648062},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1581651648062},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1581651648063},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1581651648063},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1581651648064},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1581651648064},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1581651648064},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1581651648065},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1581651648076},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1581651648080},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1581651648082},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1581651648083},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1529552205005},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1529552205005},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1529552205005},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1529552205005},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1529552205005},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1529552205005},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1532602332306},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1532602332306},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1532602332307},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1581651648099},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1529552205010},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1581651648102},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1581651648102},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1581651648103},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1581651648133},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1581651648134},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1581651648082},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1529552205024},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1529552205024},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1581651648137},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1581651648036},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1581651648036},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1581651648037},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1581651648037},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1581651648037},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1581651648038},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1581651648038},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1581651648038},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1581651648039},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1581651648039},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1581651648039},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1581651648040},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1581651648040},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1581651648040},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1581651648041},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1581651648041},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1581651648042},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1581651648042},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1581651648042},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1581651648042},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1581651648043},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1581651648043},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1581651648043},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1581651648043},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1581651648043},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1581651648044},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1581651648044},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1581651648044},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1581651648044},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1581651648045},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1581651648045},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1581651648045},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1581651648046},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1581651648046},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1581651648046},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1581651648046},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1581651648047},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1581651648047},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1581651648047},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1581651648048},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1581651648048},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1581651648048},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1581651648049},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1581651648049},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1581651648049},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1581651648049},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1581651648050},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1581651648050},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1581651648051},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1581651648051},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1581651648052},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1581651648052},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1581651648052},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1581651648052},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1581651648052},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1581651648053},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1581651648053},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1581651648053},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1581651648061},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1581651648061},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1581651648063},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1529552204996},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1529552204996},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1529552204996},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1529552204996},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1529552204997},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1529552205007},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1532602332302},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1532602332304},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1532602332304},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1532602332305},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1532602332305},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1529552205014},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1529552205017},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1529552205023},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1581651648088},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1581651648133},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1581651648111},{"_id":"public/about/index.html","hash":"b9593aa9a90d6713d8e96159fa53f42e8e7cd94f","modified":1594435220830},{"_id":"public/categories/index.html","hash":"ee7537bba22802f321abf1edd2fe7b45b0d61e40","modified":1594435220832},{"_id":"public/tags/index.html","hash":"e6103d57d1b2f213f247723ab714765818e9542c","modified":1594435220833},{"_id":"public/archives/index.html","hash":"533155696776e14a793e3cc2890b3d34203f46db","modified":1594435220841},{"_id":"public/archives/2018/index.html","hash":"9c0b77c7bdd64388267e64fae3a097513a9b84f7","modified":1594435220841},{"_id":"public/archives/2018/06/index.html","hash":"60bcfdae5d1dca4e103ad0d96da8d343bafa1833","modified":1545735407837},{"_id":"public/archives/2018/07/index.html","hash":"0ba7b0349e68ae77a20fd7473e9e0c84f24c61b1","modified":1545735407837},{"_id":"public/2018/07/04/go_goroutine/index.html","hash":"1f7bb966084ee066f279129dc392b2af365c68cb","modified":1545735407839},{"_id":"public/2018/07/04/eth/index.html","hash":"b3ddc57c1c540fe447390bd845146d5ace9d239c","modified":1531814298601},{"_id":"public/2018/07/04/coin/index.html","hash":"a98f441b3dc9770540435a70acdb91417ab1ead9","modified":1545735407840},{"_id":"public/2018/07/04/solidity_01/index.html","hash":"6796fdb46f61398d02c6d606816104bcec483365","modified":1545735407839},{"_id":"public/index.html","hash":"cd020786f07948dc5003311f5a9842fa8d32d1ba","modified":1594435220841},{"_id":"public/2018/06/21/hello-world/index.html","hash":"35d921d1780ce92f3a0376aa0d8c7c36078e6d31","modified":1545735407840},{"_id":"public/2018/06/21/ipfs/index.html","hash":"1fdc2c899919843d9503870b4ec590d20a8abbf7","modified":1531814298604},{"_id":"public/2018/06/21/golang_base/index.html","hash":"79967f5b076540c535b22d6041d23754b773892e","modified":1536046751846},{"_id":"source/_posts/makefile.md","hash":"2dda02966d582c950091a3f01a543dff361cf081","modified":1588327969048},{"_id":"source/_posts/sodility_optimal.md","hash":"604769b666ad1dbf7bb965bca8048833382f98a1","modified":1545736842558},{"_id":"source/_posts/solidity_inter_call.md","hash":"3e9ea3a674a485210b190d85e6a44b96adb2d3e3","modified":1545735850113},{"_id":"source/_posts/solidity_library.md","hash":"7fee0c8bf32e2aba5a293ad76a0af1e48457c495","modified":1545736899766},{"_id":"public/archives/page/2/index.html","hash":"ae7acaba08de5727486763f87671d44aba3296fe","modified":1594435220835},{"_id":"public/archives/2018/page/2/index.html","hash":"9794ebe63415c1c2c2cb9a2ed2efb75c034b65cd","modified":1594435220835},{"_id":"public/page/2/index.html","hash":"24e56d6c0aca9b255c742339f542904d489a36d4","modified":1594435220841},{"_id":"public/2018/07/17/solidity_inter_call/index.html","hash":"f65711928ec2e2ca2fe26a51d841af4412722d00","modified":1545735407839},{"_id":"public/2018/07/17/solidity_library/index.html","hash":"31bea66361136cc012e96e08c4ceda995b6cf023","modified":1545735407839},{"_id":"public/2018/07/17/sodility_optimal/index.html","hash":"21f201f2742bd73dca45329687f95d2dc6de9789","modified":1545735407839},{"_id":"public/2018/07/17/makefile/index.html","hash":"ab25edd6886a913fba9416e550c8a8b7c4a9d1e4","modified":1536046751846},{"_id":"public/2018/07/26/ipfs/index.html","hash":"f508e62027859084131bdc854dd7d981338a25a3","modified":1545735407839},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1532602427952},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1532602427952},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1532602427952},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1532602427952},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1532602427952},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1532602427952},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1532602427952},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1532602427953},{"_id":"source/_posts/ceph_rbd_snap.md","hash":"e0894657c5f696b63f04f3f54600a7d8c2f97859","modified":1581651647988},{"_id":"source/_posts/ceph_pg.md","hash":"2f18014be6c3d1ac5dc75a7f01622afaafe7c2ce","modified":1581651647988},{"_id":"source/_posts/ceph_messenger.md","hash":"3f5bbc781ff814fadadf077227e97b6bbf0966f0","modified":1545736971506},{"_id":"source/_posts/ERC20标准.md","hash":"facd5cb747e5c08fd598d565e3fb252f33e833cd","modified":1545736562764},{"_id":"source/_posts/ solidity_truffle.md","hash":"5ec72d0e7c37e2fad66ba643e49b570e58e1e06a","modified":1545736078481},{"_id":"source/_posts/go_paxos.md","hash":"569845592d9a6e0a181f08b54e09b9925dfb017c","modified":1545736691309},{"_id":"source/_posts/librbd.md","hash":"06e78559775993e820f0ded542eba8a92a40d19a","modified":1545736737098},{"_id":"source/_posts/eth交易签名.md","hash":"356b195553c80b1799b01f2124dfeb6a5b3e43a8","modified":1545736636700},{"_id":"source/_posts/golang reflect(反射机制).md","hash":"2dff6971b977d459938c76e0444cbab75408c659","modified":1536046927310},{"_id":"source/_posts/北京ceph集群解决方案.md","hash":"3e1091f8e17561b1c4fd9f91bbd8ec02261af2be","modified":1533881639277},{"_id":"source/_posts/snapshot.md","hash":"de14f924556f4e08ebec2159accc42824ed70e60","modified":1545736800978},{"_id":"public/2018/08/13/snapshot/index.html","hash":"da63088f7a1a5edff7ce990689d4d3ad8f395da4","modified":1545735407836},{"_id":"public/2018/08/10/ceph_messenger/index.html","hash":"a224f03004a65d1ff33548abd46018019478c3fc","modified":1545735407836},{"_id":"public/page/3/index.html","hash":"8b0638f1460d00511cb07aad2a46c406bd934a6c","modified":1588327786603},{"_id":"public/archives/page/3/index.html","hash":"cbab455b768b49f1c358798e787f853f8d8e2e47","modified":1588327786602},{"_id":"public/2018/08/20/ceph_rbd_snap/index.html","hash":"3ac861ff715a17b294a7f627adcbf49c5480432c","modified":1536047004961},{"_id":"public/2018/08/16/ceph_pg/index.html","hash":"b6bc207475330ea6be5aa0d94c345308054c5aca","modified":1536046751845},{"_id":"public/2018/08/15/librbd/index.html","hash":"adfd321791dedc630db710649c2d028418bf9799","modified":1536046751847},{"_id":"public/2018/08/08/北京ceph集群解决方案/index.html","hash":"0eb6bc42a6847665f102defefe8a57bb8d131231","modified":1534761967034},{"_id":"public/2018/08/07/go_paxos/index.html","hash":"d5e9a9bcb3754b437a4bd78ed58d25be2f3a8ac1","modified":1545735407838},{"_id":"public/2018/08/03/eth交易签名/index.html","hash":"9cebb25391315d3d8a273edb63561553a16ca2ee","modified":1545735407838},{"_id":"public/2018/08/02/golang reflect(反射机制)/index.html","hash":"8b319487e52a6e661afc55a9d909911ce1ff3e1a","modified":1536047004963},{"_id":"public/2018/08/02/ solidity_truffle/index.html","hash":"69df8c32efef6bba7d9936ceda94d78603e4975c","modified":1545732522974},{"_id":"public/2018/07/27/ERC20标准/index.html","hash":"2084bfc648d487eff58d1117805c8ffc54b7b150","modified":1545735407839},{"_id":"public/2018/07/26/eth/index.html","hash":"664851046ab9d9afff57d4348c21af1d25f5e8a3","modified":1545735407839},{"_id":"public/archives/2018/page/3/index.html","hash":"09e12537aaa9f60621a727a374af7a0bde799e97","modified":1588327786594},{"_id":"public/archives/2018/08/index.html","hash":"b33767724e13ed53871034c74c3dda85b8d2b6a5","modified":1594435220835},{"_id":"source/_posts/cache_lru.md","hash":"a95b4c261859386ebd8ca05f2434acf283856fa3","modified":1536046784982},{"_id":"source/_posts/ssd_write_amplification.md","hash":"afec8abb72c24488f4891d6eecd1aeb66bf728ca","modified":1545736963648},{"_id":"public/2018/09/04/ssd_write_amplification/index.html","hash":"a4deef8422a32c1e9d366417f24b2fe0210813fe","modified":1536047004960},{"_id":"public/archives/2018/09/index.html","hash":"2ed21650a3a0e4d0aec986e09744a6b7cfaf4fb9","modified":1594435220835},{"_id":"public/2018/09/04/cache_lru/index.html","hash":"8a121822d810f24b67835d1c92061d827149f2cc","modified":1536047004962},{"_id":"source/_posts/ceph_mon.md","hash":"d15fbbc8e36125a4acd6eb032453ebe3c80e40ec","modified":1545736392310},{"_id":"source/_posts/ceph_object_attr.md","hash":"87315c490386741bd7f3e59d1b13f32a364ded95","modified":1545736416228},{"_id":"source/_posts/ceph_log.md","hash":"87c0d2d7e3dee3c904029d35d17dcd31cab6bb3c","modified":1581651647987},{"_id":"source/_posts/design.md","hash":"40dfa9151dce9fd7bbb97ed310c92904a560d4ad","modified":1545736532349},{"_id":"source/_posts/go_base.md","hash":"46032e3f74e2fc15a5868fb4da93a2981a793fca","modified":1581651647990},{"_id":"source/_posts/c++11_base.md","hash":"3138af79c463aab90c8e1ed200230fd3d5bb1e91","modified":1545736118384},{"_id":"source/_posts/go_cache_lru.md","hash":"b5f22b0ccba7289a481859e551267d3a819eb694","modified":1545736968298},{"_id":"source/_posts/go_reflect(反射机制).md","hash":"7a2aef5ac6cd04e8213970046101a561a37303cd","modified":1545736703281},{"_id":"source/_posts/rgw_put_object.md","hash":"a75b508c37d636b3d7094eb08206acb5ae5726d9","modified":1545736777885},{"_id":"public/2018/12/14/ceph_mon/index.html","hash":"ce4d375aa8b33410a84c3b781ac7bd3f91fe9079","modified":1545732522973},{"_id":"public/2018/09/21/ssd_write_amplification/index.html","hash":"adf64bf4f295a389a5585b7c04293ea6c8bb9bdc","modified":1545735407836},{"_id":"public/2018/09/21/ceph_log/index.html","hash":"6fd2c47305718c05b35a95586e4f173c117ece18","modified":1545732704332},{"_id":"public/2018/11/30/rgw_put_object/index.html","hash":"80b37aeb64fabf3c1ef84f57221162815d60364c","modified":1545735407836},{"_id":"public/archives/2018/10/index.html","hash":"f465b42d6dd61f5f9f35fe4f850538e45457ad4c","modified":1545732522979},{"_id":"public/archives/2018/11/index.html","hash":"dcbffa60352d9e9668796e3e968e91ee096827e5","modified":1594435220835},{"_id":"public/archives/2018/12/index.html","hash":"2d11ef62ac6a994662f1a6f7392e30604642a6cd","modified":1594435220836},{"_id":"public/2018/11/28/ceph_object_attr/index.html","hash":"ff377906c8fcc48d02ddb9db53380c11c9dd9b0d","modified":1545732522979},{"_id":"public/2018/11/09/design/index.html","hash":"f4f930825dc664b5b781dad570ec8b51f7911e48","modified":1545735407837},{"_id":"public/2018/10/08/c++11_base/index.html","hash":"bf9b922d984f24929925fae9df92f8c341a64b69","modified":1545732522979},{"_id":"public/2018/09/21/makefile/index.html","hash":"0d20749d4e44600a7091c21f0039e1bccce7e266","modified":1594435220839},{"_id":"public/2018/09/21/librbd/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545735407835},{"_id":"public/2018/09/21/go_reflect(反射机制)/index.html","hash":"f47694a73360ed6f464d4ecf95b72d175770e5e4","modified":1545735407838},{"_id":"public/2018/09/21/go_cache_lru/index.html","hash":"4777ea2fb3be57a8405315bdc769029b25f53716","modified":1545735407838},{"_id":"public/2018/09/21/go_base/index.html","hash":"df1be9caa15f2a45acdb54bf86ce3c8c3d07dd50","modified":1545735407838},{"_id":"public/2018/09/21/ceph_rbd_snap/index.html","hash":"90897d934d0564894bfd7fc05307527b5e2dfa1b","modified":1545735407838},{"_id":"public/2018/09/21/ceph_pg/index.html","hash":"fe8f53e72b981723b9260a2aa11f9a3481444042","modified":1545735407838},{"_id":"public/2018/12/25/ceph_mon/index.html","hash":"b07e5ca9d19d6e91a60ec93b1f93838218595aca","modified":1545735407837},{"_id":"public/2018/12/25/ceph_object_attr/index.html","hash":"1715040a7613fcd9b98504e99f0ba7fef268c49e","modified":1545735407837},{"_id":"public/2018/12/25/c++11_base/index.html","hash":"8bfc7d67de946dd45739e4225df998fe64d171fa","modified":1545735407838},{"_id":"public/2018/12/25/ceph_log/index.html","hash":"5ed3d0c11083042be0749d8c2dc627e377844345","modified":1545735407836},{"_id":"public/archives/2018/04/index.html","hash":"2ed904800ed2959d90aac3c98fdc31a74ee6ed8c","modified":1594435220841},{"_id":"public/categories/blockchain/index.html","hash":"e296ca24fa110e02b279e01b29249d7813317775","modified":1588328523076},{"_id":"public/2018/04/08/ solidity_truffle/index.html","hash":"1ad90ff5f1499bd7d76c18cf2bc385a88a2ca80c","modified":1588327786601},{"_id":"public/2018/04/15/rgw_put_object/index.html","hash":"091bbbd28d0365b8df16e98955c5d0ae53c8a0f0","modified":1594435220833},{"_id":"public/2018/04/10/ceph_log/index.html","hash":"a466d57e1ad4240e1a5be3d3e2dbc42efb66874f","modified":1588328523074},{"_id":"public/2018/04/10/ceph_messenger/index.html","hash":"88690fc7626e0e75110ace706c6024eebad105d2","modified":1588328523083},{"_id":"public/archives/2018/04/page/3/index.html","hash":"91ab739633f9654943b74e954941e4917d545dd3","modified":1588327786594},{"_id":"public/categories/c/index.html","hash":"14ea7ac1e46476b51be79298ffb7984c5759e38a","modified":1594435220833},{"_id":"public/categories/ceph/index.html","hash":"530d2d56768a3b349df522628b11c47e2665072a","modified":1594435220834},{"_id":"public/categories/设计模式/index.html","hash":"859d1f5e6088af4920ed6ee88871da0130f508dd","modified":1594435220834},{"_id":"public/categories/golang/index.html","hash":"b5415408dffa359ca7bc3851cb1a08f634e2ce4c","modified":1594435220834},{"_id":"public/categories/ipfs/index.html","hash":"f42359142ba528254ab2d854f43d8551be907f64","modified":1588327786595},{"_id":"public/categories/other/index.html","hash":"f1d016bf810e0674c2ffa245b1bfd55a3568918e","modified":1594435220834},{"_id":"public/2018/12/10/ceph_pg/index.html","hash":"be2adf5cacfcb646b52e93616fd7126e36d0cd12","modified":1594435220838},{"_id":"public/2018/12/10/ceph_mon/index.html","hash":"276aa3db42de7b3fcf9326dc13d0ac1c17e5c42b","modified":1594435220838},{"_id":"public/2018/12/10/ceph_object_attr/index.html","hash":"74123dbbaa5b2e5ccb7f109391f9df3e8893de48","modified":1594435220839},{"_id":"public/2018/11/10/ceph_rbd_snap/index.html","hash":"6ca9b6928e465c89a682c078bbe44b2c0f14c279","modified":1594435220839},{"_id":"public/2018/08/10/design/index.html","hash":"2b61645add37825464f1f9f9c98bb946956e5034","modified":1594435220839},{"_id":"public/2018/04/15/go_paxos/index.html","hash":"7f5e3e91bd472b4e4482e568415fc21a32bd16c1","modified":1588327786599},{"_id":"public/2018/04/15/solidity_library/index.html","hash":"de7906e32fbb56cfbb04b6c7e37387576a7aab89","modified":1588328523081},{"_id":"public/2018/04/15/solidity_inter_call/index.html","hash":"13737f55e52e6c3f69905cedd4322a4983b16ba6","modified":1588327786599},{"_id":"public/2018/04/15/ipfs/index.html","hash":"0350808d1ab99af90f5fa1235a079ba0dff00d41","modified":1588327786598},{"_id":"public/2018/04/15/go_goroutine/index.html","hash":"b69ca3b3016d217aed92c4aa6f428a13c7581acb","modified":1594435220839},{"_id":"public/2018/04/15/go_reflect(反射机制)/index.html","hash":"d9d38f798d254149d934072c8b53777db512f380","modified":1588328523083},{"_id":"public/2018/04/15/ERC20标准/index.html","hash":"51dbd2f2fe476cf77b93eb86ba6b25f6a28cf889","modified":1588327786599},{"_id":"public/2018/04/15/go_cache_lru/index.html","hash":"9985b000326611f998c0b7d84f9111b807b70be3","modified":1594435220840},{"_id":"public/2018/04/15/librbd/index.html","hash":"0608bd9b40cd6831c50af2628f0eca09ad686320","modified":1594435220840},{"_id":"public/2018/04/15/eth交易签名/index.html","hash":"e6835467949afd88a7e1c8a20dc30ac0e4eca135","modified":1588327786600},{"_id":"public/2018/04/15/snapshot/index.html","hash":"8f7cd49ffc37fe3a3a1ccdf3b7c8a20c9900be55","modified":1594435220840},{"_id":"public/2018/04/15/ssd_write_amplification/index.html","hash":"04fc6be46d3ca5997fd0717c17c9d3d17cbb1732","modified":1594435220840},{"_id":"public/2018/04/15/solidity_01/index.html","hash":"89d61aae00f6a2e80357aa7898957d0f1a445563","modified":1588327786603},{"_id":"public/2018/04/15/sodility_optimal/index.html","hash":"afa18961b8f1e60eb2f3247eb5f81c979240aebe","modified":1588327786599},{"_id":"public/2018/04/15/go_base/index.html","hash":"c56ad4ae716a845f79865ec7020ac6b525933245","modified":1594435220840},{"_id":"public/2018/04/11/coin/index.html","hash":"3c224021dad72ac8668281e4e34c41901376b42a","modified":1588327786601},{"_id":"public/2018/04/09/c++11_base/index.html","hash":"1828d798cb6de35fdbe7adb98d0d79bec8316d8e","modified":1594435220841},{"_id":"public/2018/04/15/eth/index.html","hash":"2bb2f22252ad211d241c19e5f18bcd5a18c14ff5","modified":1588327786598},{"_id":"public/archives/2018/04/page/2/index.html","hash":"f02bf245acbfab2e17fdc115798c0888d46ab43d","modified":1588328523075},{"_id":"public/tags/ceph/index.html","hash":"950670ad0c6f5d5efea407872f9fbf77a5f22027","modified":1594435220836},{"_id":"public/tags/eth/index.html","hash":"1a0ca2ae8ca6e587555008993543afb73abc263f","modified":1588328523077},{"_id":"public/tags/solidity/index.html","hash":"000ec2d15943a41d09910dad5719da12e7399f27","modified":1588328523078},{"_id":"public/tags/c-11/index.html","hash":"19e4df0938c02fd524b49958b7291690101661d8","modified":1594435220836},{"_id":"public/tags/golang/index.html","hash":"0187485f0eb09e9a7f0374192c91308c09562633","modified":1594435220837},{"_id":"public/tags/goroutine/index.html","hash":"60a7321d554089e9bb34a2194095e8e62c54588e","modified":1594435220837},{"_id":"public/tags/snapshot/index.html","hash":"0fb3688ff11439555c18ed18b1667184bad21387","modified":1594435220837},{"_id":"public/tags/s3/index.html","hash":"2ef9ffec7868c107b5f40623685a10fa60534150","modified":1594435220837},{"_id":"public/tags/rgw/index.html","hash":"9993d7e8b0eb60895dfef4a61ee7619d4d44b6d6","modified":1594435220838},{"_id":"public/tags/paxos/index.html","hash":"4f961a8fa71f8f541e23a886e8c8cc7d271caad9","modified":1594435220838},{"_id":"public/tags/ipfs/index.html","hash":"3bd2e8ad667313106f5137a966b7b8488fdbbeec","modified":1588327786597},{"_id":"public/tags/ssd/index.html","hash":"1fb412ba849273a04de6023b66c51d11b5d2250a","modified":1594435220838},{"_id":"public/tags/librbd/index.html","hash":"2211df71009e82c2eb3a2bebe683c6fc15f5e3ef","modified":1594435220838},{"_id":"public/tags/cache/index.html","hash":"930888c99de256d7346213662c3fb64a5e940b37","modified":1594435220838},{"_id":"source/_posts/more_effective_cpp.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581670904027},{"_id":"source/_posts/析构函数遇上多线程.md","hash":"6809e0fe8e4e4a0a36898d21f9e4b56ae7028c94","modified":1581670911172},{"_id":"public/2020/04/09/析构函数遇上多线程/index.html","hash":"87daac2f37c528b4415909a445d4b11bd1ec7bbc","modified":1588328523074},{"_id":"public/2020/02/14/more_effective_cpp/index.html","hash":"080c8afc21dafa70b1c1e885f9dfa34ea32361ef","modified":1588327786619},{"_id":"public/archives/2020/index.html","hash":"f9a14c9429d8c4bce8fce16a20da02843fa950bd","modified":1594435220836},{"_id":"public/archives/2020/02/index.html","hash":"1f8b0077cf78015eaad94513745ab4847f2b12a2","modified":1588327786619},{"_id":"public/archives/2020/04/index.html","hash":"ad59bd35cc63d28d29347db9410aeb112cd4b5cd","modified":1594435220836},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1588327786619},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1588327786620},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1588327786620},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1588327786620},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1588327786620},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1588327786620},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1588327786621},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1588327786621},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1588327786621},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1588327786621},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1588327786621},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1588327786621},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1588327792470},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1588327792472},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1588327792518},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1588327792518},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1588327792534},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1588327792534},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1588327792535},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1588327792535},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1588327792535},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1588327792535},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1588327792535},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1588327792536},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1588327792537},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1588327792537},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1588327792538},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1588327792538},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1588327792539},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1588327792539},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1588327792539},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1588327792539},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1588327792540},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1588327792540},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1588327792540},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1588327792540},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1588327792540},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1588327792541},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1588327792541},{"_id":"public/css/main.css","hash":"9ed6fc371578c9b286e2fc041f861582803fbc0e","modified":1588327792541},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1588327792541},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1588327792541},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1588327792542},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1588327792542},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1588327792542},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1588327792542},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1588327792542},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1588327792543},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1588327792543},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1588327792543},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1588327792543},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1588327792550},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1588327792551},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1588327792551},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1588327792551},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1588327792551},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1588327792552},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1588327792552},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1588327792552},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1588327792553},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1588327794728},{"_id":"source/_posts/paxos.md","hash":"569845592d9a6e0a181f08b54e09b9925dfb017c","modified":1581651647991},{"_id":"public/2018/04/15/paxos/index.html","hash":"57423bef15134d8b437afd60c9c084d5c2f329e4","modified":1594435220840},{"_id":"source/_posts/go_reflect.md","hash":"7a2aef5ac6cd04e8213970046101a561a37303cd","modified":1594434859128},{"_id":"source/_posts/set_markdown_sublime.md","hash":"a8dee8aaa6bd81403be7cb1222a4b06ccd83f5b5","modified":1594434859128},{"_id":"public/2020/04/09/set_markdown_sublime/index.html","hash":"745d9152a520f3ab7d47b270fd26aa40bb3e1e9d","modified":1594435220843},{"_id":"public/tags/other/index.html","hash":"0bc236a20e3e89014d3a78d6d5684e5f013dd5f4","modified":1594435220843},{"_id":"public/2018/04/15/go_reflect/index.html","hash":"9db8b4d8ff12ded355bedf514876dc01fdc10f3c","modified":1594435220843}],"Category":[{"name":"blockchain","_id":"cjq3my7f60000ishaii4qk9q7"},{"name":"c++","_id":"cjq3n8krv0000vchalnmbr5nu"},{"name":"ceph","_id":"cjq3n8ks70002vchazebfifa2"},{"name":"设计模式","_id":"cjq3n8ksg000cvchad0ikrl2q"},{"name":"golang","_id":"cjq3n8ksi000fvchaj9ydz1l6"},{"name":"ipfs","_id":"cjq3n8ksr000ovchanq0jgozy"},{"name":"other","_id":"cjq3n8ksu000svchav1el1mt4"}],"Data":[],"Page":[{"title":"about","date":"2018-06-19T09:14:17.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-06-19 17:14:17\n---\n","updated":"2020-02-14T03:40:47.995Z","path":"about/index.html","_id":"cjj6hwjn00001lihaqdm6xniu","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2018-06-19T09:12:34.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-06-19 17:12:34\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-02-14T03:40:47.995Z","path":"categories/index.html","_id":"cjj6hwjnk0003lihat10s9zs8","layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-06-19T09:10:52.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-06-19 17:10:52\ntype: \"tags\"\ncomments: false\n---\n","updated":"2020-02-14T03:40:47.996Z","path":"tags/index.html","_id":"cjj6hwjo90005lihasidn74r3","layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"goroutine","date":"2018-04-14T16:00:00.000Z","_content":"\n### 协程\n协程（Coroutine）本质上是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器；目前，原生支持协程的语言还很少；\n\n### 并发通信\n- 两种最常用的并发通信模式：消息和共享数据\n```go\nvar ch map[string] chan bool\n```\n\n### 单向channel\n对channel的限制使用：<br/>\n一个channel变量传递到一个函数时，可以通过将其指定为单向channel变量，从而限制该函数中可以对此channel的操作，比如只能往这个channel写，或者只能从这个channel读。\n\n- 使用多核心CPU:\n```go\n  runtime.GOMAXPROCS(16)\n```\n- 出让时间片\n  使用runtime包中的Gosched()函数实现\n  实际上，需要精细地控制goroutine的行为，就必须深入地了解GO语言开发包中的runtime包所提供的具体功能；\n\n### go 网络编程\n- 标准库中的net包\n- 使用net.Dial()封装了socket(), bind(), listen(), connect(),accept(), receive(), send()函数；\n```go\nfunc handleMsg(conn net.Conn) ([]byte, error) {\n    defer conn.Close()\n\n    result := bytes.NewBuffer(nil)  //这里需要用循环buf来提高效率\n    var buf [512]byte\n    for {\n        size, err := conn.Read(buf[0:])\n        result.Write(buf[0:size])\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return nil, err\n        }\n    }\n    return result.Bytes(), nil\n}\n```\n\n### http\n- net/http包\n\n\n### 工程管理\n- 命名<br/>\n  驼峰命名命名法doSometing<br/>\n  c/c++则是下划线命名法\n- 目录结构\n```sh\n<calcproj>\n  ├─README\n  ├─AUTHORS\n  |─LICENSE\n  ├─<bin>\n    ├─calc\n  ├─<pkg>\n    └─<linux_amd64>\n      └─simplemath.a\n  ├─<src>\n    ├─<calc>\n      └─calc.go\n    ├─<simplemath>\n      ├─add.go\n      ├─add_test.go\n      ├─sqrt.go\n      ├─sqrt_test.go\n```\n","source":"_posts/go_goroutine.md","raw":"---\n    title: goroutine\n    date: 2018-04-15\n    categories:\n      - golang\n    tags:\n      - goroutine\n---\n\n### 协程\n协程（Coroutine）本质上是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器；目前，原生支持协程的语言还很少；\n\n### 并发通信\n- 两种最常用的并发通信模式：消息和共享数据\n```go\nvar ch map[string] chan bool\n```\n\n### 单向channel\n对channel的限制使用：<br/>\n一个channel变量传递到一个函数时，可以通过将其指定为单向channel变量，从而限制该函数中可以对此channel的操作，比如只能往这个channel写，或者只能从这个channel读。\n\n- 使用多核心CPU:\n```go\n  runtime.GOMAXPROCS(16)\n```\n- 出让时间片\n  使用runtime包中的Gosched()函数实现\n  实际上，需要精细地控制goroutine的行为，就必须深入地了解GO语言开发包中的runtime包所提供的具体功能；\n\n### go 网络编程\n- 标准库中的net包\n- 使用net.Dial()封装了socket(), bind(), listen(), connect(),accept(), receive(), send()函数；\n```go\nfunc handleMsg(conn net.Conn) ([]byte, error) {\n    defer conn.Close()\n\n    result := bytes.NewBuffer(nil)  //这里需要用循环buf来提高效率\n    var buf [512]byte\n    for {\n        size, err := conn.Read(buf[0:])\n        result.Write(buf[0:size])\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return nil, err\n        }\n    }\n    return result.Bytes(), nil\n}\n```\n\n### http\n- net/http包\n\n\n### 工程管理\n- 命名<br/>\n  驼峰命名命名法doSometing<br/>\n  c/c++则是下划线命名法\n- 目录结构\n```sh\n<calcproj>\n  ├─README\n  ├─AUTHORS\n  |─LICENSE\n  ├─<bin>\n    ├─calc\n  ├─<pkg>\n    └─<linux_amd64>\n      └─simplemath.a\n  ├─<src>\n    ├─<calc>\n      └─calc.go\n    ├─<simplemath>\n      ├─add.go\n      ├─add_test.go\n      ├─sqrt.go\n      ├─sqrt_test.go\n```\n","slug":"go_goroutine","published":1,"updated":"2018-12-25T11:17:53.276Z","_id":"cjj6hwjnv0004lihaonla0ilw","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h3><p>协程（Coroutine）本质上是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器；目前，原生支持协程的语言还很少；</p>\n<h3 id=\"并发通信\"><a href=\"#并发通信\" class=\"headerlink\" title=\"并发通信\"></a>并发通信</h3><ul>\n<li>两种最常用的并发通信模式：消息和共享数据<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"单向channel\"><a href=\"#单向channel\" class=\"headerlink\" title=\"单向channel\"></a>单向channel</h3><p>对channel的限制使用：<br><br>一个channel变量传递到一个函数时，可以通过将其指定为单向channel变量，从而限制该函数中可以对此channel的操作，比如只能往这个channel写，或者只能从这个channel读。</p>\n<ul>\n<li><p>使用多核心CPU:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runtime.GOMAXPROCS(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出让时间片<br>使用runtime包中的Gosched()函数实现<br>实际上，需要精细地控制goroutine的行为，就必须深入地了解GO语言开发包中的runtime包所提供的具体功能；</p>\n</li>\n</ul>\n<h3 id=\"go-网络编程\"><a href=\"#go-网络编程\" class=\"headerlink\" title=\"go 网络编程\"></a>go 网络编程</h3><ul>\n<li>标准库中的net包</li>\n<li>使用net.Dial()封装了socket(), bind(), listen(), connect(),accept(), receive(), send()函数；<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleMsg</span><span class=\"params\">(conn net.Conn)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    result := bytes.NewBuffer(<span class=\"literal\">nil</span>)  <span class=\"comment\">//这里需要用循环buf来提高效率</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf [<span class=\"number\">512</span>]<span class=\"keyword\">byte</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        size, err := conn.Read(buf[<span class=\"number\">0</span>:])</span><br><span class=\"line\">        result.Write(buf[<span class=\"number\">0</span>:size])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result.Bytes(), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h3><ul>\n<li>net/http包</li>\n</ul>\n<h3 id=\"工程管理\"><a href=\"#工程管理\" class=\"headerlink\" title=\"工程管理\"></a>工程管理</h3><ul>\n<li>命名<br><br>驼峰命名命名法doSometing<br><br>c/c++则是下划线命名法</li>\n<li>目录结构<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;calcproj&gt;</span><br><span class=\"line\">  ├─README</span><br><span class=\"line\">  ├─AUTHORS</span><br><span class=\"line\">  |─LICENSE</span><br><span class=\"line\">  ├─&lt;bin&gt;</span><br><span class=\"line\">    ├─calc</span><br><span class=\"line\">  ├─&lt;pkg&gt;</span><br><span class=\"line\">    └─&lt;linux_amd64&gt;</span><br><span class=\"line\">      └─simplemath.a</span><br><span class=\"line\">  ├─&lt;src&gt;</span><br><span class=\"line\">    ├─&lt;calc&gt;</span><br><span class=\"line\">      └─calc.go</span><br><span class=\"line\">    ├─&lt;simplemath&gt;</span><br><span class=\"line\">      ├─add.go</span><br><span class=\"line\">      ├─add_test.go</span><br><span class=\"line\">      ├─sqrt.go</span><br><span class=\"line\">      ├─sqrt_test.go</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h3><p>协程（Coroutine）本质上是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器；目前，原生支持协程的语言还很少；</p>\n<h3 id=\"并发通信\"><a href=\"#并发通信\" class=\"headerlink\" title=\"并发通信\"></a>并发通信</h3><ul>\n<li>两种最常用的并发通信模式：消息和共享数据<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"单向channel\"><a href=\"#单向channel\" class=\"headerlink\" title=\"单向channel\"></a>单向channel</h3><p>对channel的限制使用：<br><br>一个channel变量传递到一个函数时，可以通过将其指定为单向channel变量，从而限制该函数中可以对此channel的操作，比如只能往这个channel写，或者只能从这个channel读。</p>\n<ul>\n<li><p>使用多核心CPU:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runtime.GOMAXPROCS(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出让时间片<br>使用runtime包中的Gosched()函数实现<br>实际上，需要精细地控制goroutine的行为，就必须深入地了解GO语言开发包中的runtime包所提供的具体功能；</p>\n</li>\n</ul>\n<h3 id=\"go-网络编程\"><a href=\"#go-网络编程\" class=\"headerlink\" title=\"go 网络编程\"></a>go 网络编程</h3><ul>\n<li>标准库中的net包</li>\n<li>使用net.Dial()封装了socket(), bind(), listen(), connect(),accept(), receive(), send()函数；<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleMsg</span><span class=\"params\">(conn net.Conn)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    result := bytes.NewBuffer(<span class=\"literal\">nil</span>)  <span class=\"comment\">//这里需要用循环buf来提高效率</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf [<span class=\"number\">512</span>]<span class=\"keyword\">byte</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        size, err := conn.Read(buf[<span class=\"number\">0</span>:])</span><br><span class=\"line\">        result.Write(buf[<span class=\"number\">0</span>:size])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result.Bytes(), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h3><ul>\n<li>net/http包</li>\n</ul>\n<h3 id=\"工程管理\"><a href=\"#工程管理\" class=\"headerlink\" title=\"工程管理\"></a>工程管理</h3><ul>\n<li>命名<br><br>驼峰命名命名法doSometing<br><br>c/c++则是下划线命名法</li>\n<li>目录结构<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;calcproj&gt;</span><br><span class=\"line\">  ├─README</span><br><span class=\"line\">  ├─AUTHORS</span><br><span class=\"line\">  |─LICENSE</span><br><span class=\"line\">  ├─&lt;bin&gt;</span><br><span class=\"line\">    ├─calc</span><br><span class=\"line\">  ├─&lt;pkg&gt;</span><br><span class=\"line\">    └─&lt;linux_amd64&gt;</span><br><span class=\"line\">      └─simplemath.a</span><br><span class=\"line\">  ├─&lt;src&gt;</span><br><span class=\"line\">    ├─&lt;calc&gt;</span><br><span class=\"line\">      └─calc.go</span><br><span class=\"line\">    ├─&lt;simplemath&gt;</span><br><span class=\"line\">      ├─add.go</span><br><span class=\"line\">      ├─add_test.go</span><br><span class=\"line\">      ├─sqrt.go</span><br><span class=\"line\">      ├─sqrt_test.go</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"_content":"---\n  title:golang中使用makefile\n---\n\nMakefile必须以tab来进行缩进\n\n```\n  target: prerequisites\n    recipe\n```\n\n- make 变量\n\n  VAR := value  //声明变量\n```\n  FILE := abc\n  $(FILE): xyz\n    echo $(FILE) > \"something\"\n\n  xyz:\n    echo \"xyz\" > xyz\n```\nhttps://sahilm.com/makefiles-for-golang/\n\nmake描述了如何构建我们的项目，那些可运行的测试以及项目中依赖的额外的工具；\nPHONY 目标并非实际的文件名： 只是显示请求时执行命令的名字；优势有以下两点：\n\n- 避免和同名文件冲突\n  如果编写一个规则，并不产生目标文件，则其命令在每次make该目标时都执行：\n ```\n  clean:\n    rm *.o temp\n ```\n   因为\" rm \"  并不生成\" clean \"文件，则每次执行\" make clean \" 的时候，该命令都会执行；\n   如果目录中出现了 \" clean \"文件，则规则失效了：没有依赖文件，文件\"clean\"始终是最新的， 命令永远不会执行； 为了避免这个问题，可使用\" .PHONY \"指明该目标。\n```\n  .PHONY: clean\n  clean:\n    rm *.0 temp\n```\n  这样执行\" make clean \"会无视\" clean \"文件存在与否；\n  已知phony 目标并非是由其它文件生成的实际文件，make 会跳过隐含规则搜索。这就是声明phony 目标会改善性能的原因，即使你并不担心实际文件存在与否。\n\n- 改善性能\n  phony 目标可以有依赖关系。当一个目录中有多个程序，将其放在一个makefile 中会更方便。因为缺省目标是makefile 中的第一个目标，通常将这个phony 目标叫做\"all\"，其依赖文件为各个程序：\n\n```\nall : prog1 prog2 prog3\n.PHONY : all\nprog1 : prog1.o utils.o\n  cc -o prog1 prog1.o utils.o\nprog2 : prog2.o\n  cc -o prog2 prog2.o\nprog3 : prog3.o sort.o utils.o\n  cc -o prog3 prog3.o sort.o utils.o\n```\n一个项目最后需要产生两个可执行文件。主要目标是产生两个可执行文件，但这两个文件是相互独立的——如果一个文件需要重建，并不影响另一个。使用“假象目的”来 达到这种效果。一个假象目的跟一个正常的目的几乎是一样的， 只是这个目的文件是不存在的。因此， make 总是会假设它需要 被生成，当把它的依赖文件更新后，就会执行它的规则里的命令行。\n","source":"_posts/makefile.md","raw":"---\n  title:golang中使用makefile\n---\n\nMakefile必须以tab来进行缩进\n\n```\n  target: prerequisites\n    recipe\n```\n\n- make 变量\n\n  VAR := value  //声明变量\n```\n  FILE := abc\n  $(FILE): xyz\n    echo $(FILE) > \"something\"\n\n  xyz:\n    echo \"xyz\" > xyz\n```\nhttps://sahilm.com/makefiles-for-golang/\n\nmake描述了如何构建我们的项目，那些可运行的测试以及项目中依赖的额外的工具；\nPHONY 目标并非实际的文件名： 只是显示请求时执行命令的名字；优势有以下两点：\n\n- 避免和同名文件冲突\n  如果编写一个规则，并不产生目标文件，则其命令在每次make该目标时都执行：\n ```\n  clean:\n    rm *.o temp\n ```\n   因为\" rm \"  并不生成\" clean \"文件，则每次执行\" make clean \" 的时候，该命令都会执行；\n   如果目录中出现了 \" clean \"文件，则规则失效了：没有依赖文件，文件\"clean\"始终是最新的， 命令永远不会执行； 为了避免这个问题，可使用\" .PHONY \"指明该目标。\n```\n  .PHONY: clean\n  clean:\n    rm *.0 temp\n```\n  这样执行\" make clean \"会无视\" clean \"文件存在与否；\n  已知phony 目标并非是由其它文件生成的实际文件，make 会跳过隐含规则搜索。这就是声明phony 目标会改善性能的原因，即使你并不担心实际文件存在与否。\n\n- 改善性能\n  phony 目标可以有依赖关系。当一个目录中有多个程序，将其放在一个makefile 中会更方便。因为缺省目标是makefile 中的第一个目标，通常将这个phony 目标叫做\"all\"，其依赖文件为各个程序：\n\n```\nall : prog1 prog2 prog3\n.PHONY : all\nprog1 : prog1.o utils.o\n  cc -o prog1 prog1.o utils.o\nprog2 : prog2.o\n  cc -o prog2 prog2.o\nprog3 : prog3.o sort.o utils.o\n  cc -o prog3 prog3.o sort.o utils.o\n```\n一个项目最后需要产生两个可执行文件。主要目标是产生两个可执行文件，但这两个文件是相互独立的——如果一个文件需要重建，并不影响另一个。使用“假象目的”来 达到这种效果。一个假象目的跟一个正常的目的几乎是一样的， 只是这个目的文件是不存在的。因此， make 总是会假设它需要 被生成，当把它的依赖文件更新后，就会执行它的规则里的命令行。\n","slug":"makefile","published":1,"date":"2018-09-21T07:16:42.312Z","updated":"2018-10-11T10:26:37.294Z","_id":"cjjpeohpc000075hake7q25tm","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h2 id=\"title-golang中使用makefile\"><a href=\"#title-golang中使用makefile\" class=\"headerlink\" title=\"  title:golang中使用makefile\"></a>  title:golang中使用makefile</h2><p>Makefile必须以tab来进行缩进</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target: prerequisites</span><br><span class=\"line\">  recipe</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>make 变量</p>\n<p>VAR := value  //声明变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE := abc</span><br><span class=\"line\">$(FILE): xyz</span><br><span class=\"line\">  echo $(FILE) &gt; &quot;something&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">xyz:</span><br><span class=\"line\">  echo &quot;xyz&quot; &gt; xyz</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"https://sahilm.com/makefiles-for-golang/\" target=\"_blank\" rel=\"noopener\">https://sahilm.com/makefiles-for-golang/</a></p>\n<p>make描述了如何构建我们的项目，那些可运行的测试以及项目中依赖的额外的工具；<br>PHONY 目标并非实际的文件名： 只是显示请求时执行命令的名字；优势有以下两点：</p>\n<ul>\n<li><p>避免和同名文件冲突<br>如果编写一个规则，并不产生目标文件，则其命令在每次make该目标时都执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">  rm *.o temp</span><br></pre></td></tr></table></figure>\n<p> 因为” rm “  并不生成” clean “文件，则每次执行” make clean “ 的时候，该命令都会执行；<br> 如果目录中出现了 “ clean “文件，则规则失效了：没有依赖文件，文件”clean”始终是最新的， 命令永远不会执行； 为了避免这个问题，可使用” .PHONY “指明该目标。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">  rm *.0 temp</span><br></pre></td></tr></table></figure>\n<p>这样执行” make clean “会无视” clean “文件存在与否；<br>已知phony 目标并非是由其它文件生成的实际文件，make 会跳过隐含规则搜索。这就是声明phony 目标会改善性能的原因，即使你并不担心实际文件存在与否。</p>\n</li>\n<li><p>改善性能<br>phony 目标可以有依赖关系。当一个目录中有多个程序，将其放在一个makefile 中会更方便。因为缺省目标是makefile 中的第一个目标，通常将这个phony 目标叫做”all”，其依赖文件为各个程序：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all : prog1 prog2 prog3</span><br><span class=\"line\">.PHONY : all</span><br><span class=\"line\">prog1 : prog1.o utils.o</span><br><span class=\"line\">  cc -o prog1 prog1.o utils.o</span><br><span class=\"line\">prog2 : prog2.o</span><br><span class=\"line\">  cc -o prog2 prog2.o</span><br><span class=\"line\">prog3 : prog3.o sort.o utils.o</span><br><span class=\"line\">  cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>\n<p>一个项目最后需要产生两个可执行文件。主要目标是产生两个可执行文件，但这两个文件是相互独立的——如果一个文件需要重建，并不影响另一个。使用“假象目的”来 达到这种效果。一个假象目的跟一个正常的目的几乎是一样的， 只是这个目的文件是不存在的。因此， make 总是会假设它需要 被生成，当把它的依赖文件更新后，就会执行它的规则里的命令行。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"title-golang中使用makefile\"><a href=\"#title-golang中使用makefile\" class=\"headerlink\" title=\"  title:golang中使用makefile\"></a>  title:golang中使用makefile</h2><p>Makefile必须以tab来进行缩进</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target: prerequisites</span><br><span class=\"line\">  recipe</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>make 变量</p>\n<p>VAR := value  //声明变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE := abc</span><br><span class=\"line\">$(FILE): xyz</span><br><span class=\"line\">  echo $(FILE) &gt; &quot;something&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">xyz:</span><br><span class=\"line\">  echo &quot;xyz&quot; &gt; xyz</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"https://sahilm.com/makefiles-for-golang/\" target=\"_blank\" rel=\"noopener\">https://sahilm.com/makefiles-for-golang/</a></p>\n<p>make描述了如何构建我们的项目，那些可运行的测试以及项目中依赖的额外的工具；<br>PHONY 目标并非实际的文件名： 只是显示请求时执行命令的名字；优势有以下两点：</p>\n<ul>\n<li><p>避免和同名文件冲突<br>如果编写一个规则，并不产生目标文件，则其命令在每次make该目标时都执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">  rm *.o temp</span><br></pre></td></tr></table></figure>\n<p> 因为” rm “  并不生成” clean “文件，则每次执行” make clean “ 的时候，该命令都会执行；<br> 如果目录中出现了 “ clean “文件，则规则失效了：没有依赖文件，文件”clean”始终是最新的， 命令永远不会执行； 为了避免这个问题，可使用” .PHONY “指明该目标。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">  rm *.0 temp</span><br></pre></td></tr></table></figure>\n<p>这样执行” make clean “会无视” clean “文件存在与否；<br>已知phony 目标并非是由其它文件生成的实际文件，make 会跳过隐含规则搜索。这就是声明phony 目标会改善性能的原因，即使你并不担心实际文件存在与否。</p>\n</li>\n<li><p>改善性能<br>phony 目标可以有依赖关系。当一个目录中有多个程序，将其放在一个makefile 中会更方便。因为缺省目标是makefile 中的第一个目标，通常将这个phony 目标叫做”all”，其依赖文件为各个程序：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all : prog1 prog2 prog3</span><br><span class=\"line\">.PHONY : all</span><br><span class=\"line\">prog1 : prog1.o utils.o</span><br><span class=\"line\">  cc -o prog1 prog1.o utils.o</span><br><span class=\"line\">prog2 : prog2.o</span><br><span class=\"line\">  cc -o prog2 prog2.o</span><br><span class=\"line\">prog3 : prog3.o sort.o utils.o</span><br><span class=\"line\">  cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>\n<p>一个项目最后需要产生两个可执行文件。主要目标是产生两个可执行文件，但这两个文件是相互独立的——如果一个文件需要重建，并不影响另一个。使用“假象目的”来 达到这种效果。一个假象目的跟一个正常的目的几乎是一样的， 只是这个目的文件是不存在的。因此， make 总是会假设它需要 被生成，当把它的依赖文件更新后，就会执行它的规则里的命令行。</p>\n"},{"title":"pg","date":"2018-12-09T16:00:00.000Z","_content":"\n### pg概述\n\n- ReplicatedPG::do_request\n  |- ReplicatedPG::do_op  //仅仅分析请求类型为\"CEPH_MSG_OSD_OP\"\n        |- ReplicatedPG::find_object_context\n              |-ReplicatedPG::execute_ctx    |- ReplicatedPG::get_object_context\n                    |- ReplicatedPG::prepare_transaction\n                          |- ReplicatedPG::complete_read_ctx\n                          |- ReplicatedPG::start_async_reads\n                          |- ReplicatedPG::calc_trim_to\n                          |- ReplicatedPG::issue_repop  //向副本发送同步请求op\n                          |- ReplicatedPG::eval_repop   //检查发向各个副本的同步操作是否reply成功\n  ReplicatedPG::issue_repop\n    |-ReplicatedBackend::submit_transaction\n      |- ReplicatedBackend::issue_op               |- ReplicatedBackend::parent_transactions\n         |- OSDService::send_message_osd_cluster          |- ReplicatedPG::queue_transactions\n                                                              |- FileStore\n\n\n- acting set\n  pg对应副本所在的OSD列表，列表是有序的，第一个osd 为 primary. 在通常情况下，up set和acting set 相同\n\n- up set\n  假设:acting set [0, 1, 2], 此时osd.0故障，导致monitor重新分配pg的acting set为[3, 1, 2], 此时osd.3不能承载pg的读io，所以向monitor申请一个临时的pg的osd.1 为主osd来承载读写，此时acting set为[3, 1, 2], up set [1, 3, 2]; acting set 与 up set不一致;\n  当osd.3 backfill完成之后, up set, acting set 均为[3, 1, 2]\n \n- current interval && past_interval \n   在序列(interval)之内，pg的acting set 和 up set不会变化; current是当前的序列，past则是上一个阶段的序列；\n\n- last_epoch_started:  pg peering完成之后的epoch\n- last_epoch_clean:  pg recovery完成，处于clean状态的epoch\n\n### PGBackend\nPGBackend定义了逻辑上处理IO和副本\n\n- 处理client 操作\n- 处理对象恢复\n- 处理对象访问\n- 处理scrub, deep-scrub, repair\n\n ```c++\n// osd/PGBackend.h\nclass PGBackend{\nprotected:\n  ObjectStore *store;\n  const coll_t coll;\n  ObjectStore::CollectionHandle &ch;\n\n//PGBackend 回调接口\npublic:\n  class Listener{\n  public:\n      // Recovery\n  ......\n    struct RecoveryHandle{\n        .....\n    }\n  }\n}\n\nstruct PG_SendMessageOnConn: public Context{\n  PGBackend::Listener *pg;\n  ...\n}\n\nstruct PG_RecoveryQueueAsync : public Context{\n  PGBackend::Listener *pg;\n  ...\n}\n ```\n\n### ReplicatedBackend(多副本后端)\n\n ```c++\n// osd/ReplicatedBackend.h\nclass ReplicatedBackend : public PGBackend{\n  // RPGHandle: replicated PG handle\n  struct RPGHandle : public PGBackend::RecoveryHandle{\n    map<pg_shard_t, vector<PushOp> pushes;\n    map<pg_shard_t, vector<PullOp> pulls;\n  }\n\n  class RPCReadPred : public IsPGReadablePredicate{\n\n  }\n\n  class RPCReadPred : public IsPGReadablePredicate{\n\n  }\n\nprivate:\n  struct PushInfo {\n    ......\n  };\n  map<hobject_t, map<pg_shard_t, PushInfo>, hobject_t::BitwiseComparator> pushing;\n\n  struct PullInfo{\n    ......\n  };\n\n  map<hobject_t, PullInfo, hobject_t::BitwiseComparator> pulling;\n\n}\n```\n\n```c++\n// osd/ReplicatedPG.h\n\nclass ReplicatedPG : public PG, public PGBackend::Listener{\n  friend class OSD;\n  .......\n\n\n}\n\n```c++\n//monitor向OSD端推送OSDMAP更新信息：\nOSD::_dispatch()\n  |- OSD::handle_osd_map()\n      |- OSD::consume_map()\n  |- PG::queue_null()\n      |- PG::queue_peering_event()\n          |- peering_queue.push_back(evt)   //CephPeeringEvtRef evt; 加入peering队列\n          |- osd->queue_for_peering(this)   //osd进行peering处理流程\n                  |- OSDService::queue_for_peering(PG *pg)\n                      |- peering_wq.queue(pg)     //ThreadPool::BatchWorkQueue<PG> &peering_wq;\n\n  OSD::_dispatch()函数是消息处理的路由函数，根据消息类型调用具体的处理函数。对于处理Monitor节点发送过来的OSDMap消息，则由handle_osd_map()函数进行处理。在handle_osd_map()函数中首先对OSDMap消息进行解析且得到OSDMap且保存，之后调用consume_map()做进一步处理。在consume_map()函数中遍历该OSD节点上已有的PGs且统计出primary/replicas/stray的数量，其次唤醒等待OSDMap的PGs，最后遍历当前OSD节点上所有PGs且调用PG::queue_null()函数将OSD节点上所有PGs添加到peering队列中。\n\n//线程池工作队列开始工作, 入口\nvoid PG::handle_peering_event(CephPeeringEvtRef evt, RecoveryCtx *rctx){\n  ...\n  recovery_state.handle_event(evt, rctx);\n}\n\nvoid handle_event(const boost::statechart::event_base &evt, RecoveryCtx *rctx)\n{\n  start_handle(rctx);\n  machine.process_event(evt);\n  end_handle();\n}\n\nvoid PG::RecoveryState::start_handle(RecoveryCtx *new_ctx){\n  ...\n}\n\nclass RecoveryState{\n  void start_handle(RecoveryCtx *new_ctx);\n  void end_handle();\n\nprivate:\n  class RecoveryMachine : public boost::statechart::state_machine<RecoveryMachine, Inital> {\n    RecoveryState *state;\n    ...\n  }\n}\n```\n\n\n```c++\nstruct C_OnMapCommit : public Context{\n  OSD *osd;\n  epoch_t first, last;\n  MOSDMap *msg;\n  C_OnMapCommit(OSD *o, epoch_t f, epoch_t l, MOSDMap *m)\n    : osd(o), first(f), last(l), msg(m) { }\n  void finish(int r){\n    osd -> _committed_osd_maps(first, last, msg) ;\n  }\n}\n\n/*\n * Context - abstract callback class\n */\n class Context{\n   Context(const Context& other);\n   const Context& operator=(const Context& other);\n  protected:\n    virtual void finish(int r) = 0;\n  public:\n    Context() {}\n    virtual ~Context() {}\n    virtual void complete(int r){\n      finish(r);\n      delete this;\n    }\n };\n```\n\nObjectStore\n","source":"_posts/ceph_pg.md","raw":"---\n  title: pg\n  date: 2018-12-10\n  categories:\n    - ceph\n  tags:\n    - ceph\n---\n\n### pg概述\n\n- ReplicatedPG::do_request\n  |- ReplicatedPG::do_op  //仅仅分析请求类型为\"CEPH_MSG_OSD_OP\"\n        |- ReplicatedPG::find_object_context\n              |-ReplicatedPG::execute_ctx    |- ReplicatedPG::get_object_context\n                    |- ReplicatedPG::prepare_transaction\n                          |- ReplicatedPG::complete_read_ctx\n                          |- ReplicatedPG::start_async_reads\n                          |- ReplicatedPG::calc_trim_to\n                          |- ReplicatedPG::issue_repop  //向副本发送同步请求op\n                          |- ReplicatedPG::eval_repop   //检查发向各个副本的同步操作是否reply成功\n  ReplicatedPG::issue_repop\n    |-ReplicatedBackend::submit_transaction\n      |- ReplicatedBackend::issue_op               |- ReplicatedBackend::parent_transactions\n         |- OSDService::send_message_osd_cluster          |- ReplicatedPG::queue_transactions\n                                                              |- FileStore\n\n\n- acting set\n  pg对应副本所在的OSD列表，列表是有序的，第一个osd 为 primary. 在通常情况下，up set和acting set 相同\n\n- up set\n  假设:acting set [0, 1, 2], 此时osd.0故障，导致monitor重新分配pg的acting set为[3, 1, 2], 此时osd.3不能承载pg的读io，所以向monitor申请一个临时的pg的osd.1 为主osd来承载读写，此时acting set为[3, 1, 2], up set [1, 3, 2]; acting set 与 up set不一致;\n  当osd.3 backfill完成之后, up set, acting set 均为[3, 1, 2]\n \n- current interval && past_interval \n   在序列(interval)之内，pg的acting set 和 up set不会变化; current是当前的序列，past则是上一个阶段的序列；\n\n- last_epoch_started:  pg peering完成之后的epoch\n- last_epoch_clean:  pg recovery完成，处于clean状态的epoch\n\n### PGBackend\nPGBackend定义了逻辑上处理IO和副本\n\n- 处理client 操作\n- 处理对象恢复\n- 处理对象访问\n- 处理scrub, deep-scrub, repair\n\n ```c++\n// osd/PGBackend.h\nclass PGBackend{\nprotected:\n  ObjectStore *store;\n  const coll_t coll;\n  ObjectStore::CollectionHandle &ch;\n\n//PGBackend 回调接口\npublic:\n  class Listener{\n  public:\n      // Recovery\n  ......\n    struct RecoveryHandle{\n        .....\n    }\n  }\n}\n\nstruct PG_SendMessageOnConn: public Context{\n  PGBackend::Listener *pg;\n  ...\n}\n\nstruct PG_RecoveryQueueAsync : public Context{\n  PGBackend::Listener *pg;\n  ...\n}\n ```\n\n### ReplicatedBackend(多副本后端)\n\n ```c++\n// osd/ReplicatedBackend.h\nclass ReplicatedBackend : public PGBackend{\n  // RPGHandle: replicated PG handle\n  struct RPGHandle : public PGBackend::RecoveryHandle{\n    map<pg_shard_t, vector<PushOp> pushes;\n    map<pg_shard_t, vector<PullOp> pulls;\n  }\n\n  class RPCReadPred : public IsPGReadablePredicate{\n\n  }\n\n  class RPCReadPred : public IsPGReadablePredicate{\n\n  }\n\nprivate:\n  struct PushInfo {\n    ......\n  };\n  map<hobject_t, map<pg_shard_t, PushInfo>, hobject_t::BitwiseComparator> pushing;\n\n  struct PullInfo{\n    ......\n  };\n\n  map<hobject_t, PullInfo, hobject_t::BitwiseComparator> pulling;\n\n}\n```\n\n```c++\n// osd/ReplicatedPG.h\n\nclass ReplicatedPG : public PG, public PGBackend::Listener{\n  friend class OSD;\n  .......\n\n\n}\n\n```c++\n//monitor向OSD端推送OSDMAP更新信息：\nOSD::_dispatch()\n  |- OSD::handle_osd_map()\n      |- OSD::consume_map()\n  |- PG::queue_null()\n      |- PG::queue_peering_event()\n          |- peering_queue.push_back(evt)   //CephPeeringEvtRef evt; 加入peering队列\n          |- osd->queue_for_peering(this)   //osd进行peering处理流程\n                  |- OSDService::queue_for_peering(PG *pg)\n                      |- peering_wq.queue(pg)     //ThreadPool::BatchWorkQueue<PG> &peering_wq;\n\n  OSD::_dispatch()函数是消息处理的路由函数，根据消息类型调用具体的处理函数。对于处理Monitor节点发送过来的OSDMap消息，则由handle_osd_map()函数进行处理。在handle_osd_map()函数中首先对OSDMap消息进行解析且得到OSDMap且保存，之后调用consume_map()做进一步处理。在consume_map()函数中遍历该OSD节点上已有的PGs且统计出primary/replicas/stray的数量，其次唤醒等待OSDMap的PGs，最后遍历当前OSD节点上所有PGs且调用PG::queue_null()函数将OSD节点上所有PGs添加到peering队列中。\n\n//线程池工作队列开始工作, 入口\nvoid PG::handle_peering_event(CephPeeringEvtRef evt, RecoveryCtx *rctx){\n  ...\n  recovery_state.handle_event(evt, rctx);\n}\n\nvoid handle_event(const boost::statechart::event_base &evt, RecoveryCtx *rctx)\n{\n  start_handle(rctx);\n  machine.process_event(evt);\n  end_handle();\n}\n\nvoid PG::RecoveryState::start_handle(RecoveryCtx *new_ctx){\n  ...\n}\n\nclass RecoveryState{\n  void start_handle(RecoveryCtx *new_ctx);\n  void end_handle();\n\nprivate:\n  class RecoveryMachine : public boost::statechart::state_machine<RecoveryMachine, Inital> {\n    RecoveryState *state;\n    ...\n  }\n}\n```\n\n\n```c++\nstruct C_OnMapCommit : public Context{\n  OSD *osd;\n  epoch_t first, last;\n  MOSDMap *msg;\n  C_OnMapCommit(OSD *o, epoch_t f, epoch_t l, MOSDMap *m)\n    : osd(o), first(f), last(l), msg(m) { }\n  void finish(int r){\n    osd -> _committed_osd_maps(first, last, msg) ;\n  }\n}\n\n/*\n * Context - abstract callback class\n */\n class Context{\n   Context(const Context& other);\n   const Context& operator=(const Context& other);\n  protected:\n    virtual void finish(int r) = 0;\n  public:\n    Context() {}\n    virtual ~Context() {}\n    virtual void complete(int r){\n      finish(r);\n      delete this;\n    }\n };\n```\n\nObjectStore\n","slug":"ceph_pg","published":1,"updated":"2020-02-14T03:40:47.988Z","_id":"cjl25n9ql000014ha1u2c0bgx","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"pg概述\"><a href=\"#pg概述\" class=\"headerlink\" title=\"pg概述\"></a>pg概述</h3><ul>\n<li>ReplicatedPG::do_request<br>|- ReplicatedPG::do_op  //仅仅分析请求类型为”CEPH_MSG_OSD_OP”<pre><code>|- ReplicatedPG::find_object_context\n      |-ReplicatedPG::execute_ctx    |- ReplicatedPG::get_object_context\n            |- ReplicatedPG::prepare_transaction\n                  |- ReplicatedPG::complete_read_ctx\n                  |- ReplicatedPG::start_async_reads\n                  |- ReplicatedPG::calc_trim_to\n                  |- ReplicatedPG::issue_repop  //向副本发送同步请求op\n                  |- ReplicatedPG::eval_repop   //检查发向各个副本的同步操作是否reply成功\n</code></pre>ReplicatedPG::issue_repop<br>  |-ReplicatedBackend::submit_transaction<pre><code>|- ReplicatedBackend::issue_op               |- ReplicatedBackend::parent_transactions\n   |- OSDService::send_message_osd_cluster          |- ReplicatedPG::queue_transactions\n                                                        |- FileStore\n</code></pre></li>\n</ul>\n<ul>\n<li><p>acting set<br>pg对应副本所在的OSD列表，列表是有序的，第一个osd 为 primary. 在通常情况下，up set和acting set 相同</p>\n</li>\n<li><p>up set<br>假设:acting set [0, 1, 2], 此时osd.0故障，导致monitor重新分配pg的acting set为[3, 1, 2], 此时osd.3不能承载pg的读io，所以向monitor申请一个临时的pg的osd.1 为主osd来承载读写，此时acting set为[3, 1, 2], up set [1, 3, 2]; acting set 与 up set不一致;<br>当osd.3 backfill完成之后, up set, acting set 均为[3, 1, 2]</p>\n</li>\n<li><p>current interval &amp;&amp; past_interval<br> 在序列(interval)之内，pg的acting set 和 up set不会变化; current是当前的序列，past则是上一个阶段的序列；</p>\n</li>\n<li><p>last_epoch_started:  pg peering完成之后的epoch</p>\n</li>\n<li>last_epoch_clean:  pg recovery完成，处于clean状态的epoch</li>\n</ul>\n<h3 id=\"PGBackend\"><a href=\"#PGBackend\" class=\"headerlink\" title=\"PGBackend\"></a>PGBackend</h3><p>PGBackend定义了逻辑上处理IO和副本</p>\n<ul>\n<li>处理client 操作</li>\n<li>处理对象恢复</li>\n<li>处理对象访问</li>\n<li><p>处理scrub, deep-scrub, repair</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osd/PGBackend.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PGBackend</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  ObjectStore *store;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">coll_t</span> coll;</span><br><span class=\"line\">  ObjectStore::CollectionHandle &amp;ch;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PGBackend 回调接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listener</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// Recovery</span></span><br><span class=\"line\">  ......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RecoveryHandle</span>&#123;</span></span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PG_SendMessageOnConn</span>:</span> <span class=\"keyword\">public</span> Context&#123;</span><br><span class=\"line\">  PGBackend::Listener *pg;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PG_RecoveryQueueAsync</span> :</span> <span class=\"keyword\">public</span> Context&#123;</span><br><span class=\"line\">  PGBackend::Listener *pg;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"ReplicatedBackend-多副本后端\"><a href=\"#ReplicatedBackend-多副本后端\" class=\"headerlink\" title=\"ReplicatedBackend(多副本后端)\"></a>ReplicatedBackend(多副本后端)</h3> <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osd/ReplicatedBackend.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReplicatedBackend</span> :</span> <span class=\"keyword\">public</span> PGBackend&#123;</span><br><span class=\"line\">  <span class=\"comment\">// RPGHandle: replicated PG handle</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RPGHandle</span> :</span> <span class=\"keyword\">public</span> PGBackend::RecoveryHandle&#123;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">pg_shard_t</span>, <span class=\"built_in\">vector</span>&lt;PushOp&gt; pushes;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">pg_shard_t</span>, <span class=\"built_in\">vector</span>&lt;PullOp&gt; pulls;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  class RPCReadPred : <span class=\"keyword\">public</span> IsPGReadablePredicate&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  class RPCReadPred : <span class=\"keyword\">public</span> IsPGReadablePredicate&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  struct PushInfo &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">hobject_t</span>, <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">pg_shard_t</span>, PushInfo&gt;, <span class=\"keyword\">hobject_t</span>::BitwiseComparator&gt; pushing;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct PullInfo&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">hobject_t</span>, PullInfo, <span class=\"keyword\">hobject_t</span>::BitwiseComparator&gt; pulling;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osd/ReplicatedPG.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReplicatedPG</span> :</span> <span class=\"keyword\">public</span> PG, <span class=\"keyword\">public</span> PGBackend::Listener&#123;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OSD</span>;</span></span><br><span class=\"line\">  .......</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```c++</span><br><span class=\"line\"><span class=\"comment\">//monitor向OSD端推送OSDMAP更新信息：</span></span><br><span class=\"line\">OSD::_dispatch()</span><br><span class=\"line\">  |- OSD::handle_osd_map()</span><br><span class=\"line\">      |- OSD::consume_map()</span><br><span class=\"line\">  |- PG::queue_null()</span><br><span class=\"line\">      |- PG::queue_peering_event()</span><br><span class=\"line\">          |- peering_queue.push_back(evt)   <span class=\"comment\">//CephPeeringEvtRef evt; 加入peering队列</span></span><br><span class=\"line\">          |- osd-&gt;queue_for_peering(<span class=\"keyword\">this</span>)   <span class=\"comment\">//osd进行peering处理流程</span></span><br><span class=\"line\">                  |- OSDService::queue_for_peering(PG *pg)</span><br><span class=\"line\">                      |- peering_wq.<span class=\"built_in\">queue</span>(pg)     <span class=\"comment\">//ThreadPool::BatchWorkQueue&lt;PG&gt; &amp;peering_wq;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  OSD::_dispatch()函数是消息处理的路由函数，根据消息类型调用具体的处理函数。对于处理Monitor节点发送过来的OSDMap消息，则由handle_osd_map()函数进行处理。在handle_osd_map()函数中首先对OSDMap消息进行解析且得到OSDMap且保存，之后调用consume_map()做进一步处理。在consume_map()函数中遍历该OSD节点上已有的PGs且统计出primary/replicas/stray的数量，其次唤醒等待OSDMap的PGs，最后遍历当前OSD节点上所有PGs且调用PG::queue_null()函数将OSD节点上所有PGs添加到peering队列中。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线程池工作队列开始工作, 入口</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> PG::handle_peering_event(CephPeeringEvtRef evt, RecoveryCtx *rctx)&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  recovery_state.handle_event(evt, rctx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handle_event</span><span class=\"params\">(<span class=\"keyword\">const</span> boost::statechart::event_base &amp;evt, RecoveryCtx *rctx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  start_handle(rctx);</span><br><span class=\"line\">  machine.process_event(evt);</span><br><span class=\"line\">  end_handle();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> PG::RecoveryState::start_handle(RecoveryCtx *new_ctx)&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecoveryState</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start_handle</span><span class=\"params\">(RecoveryCtx *new_ctx)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end_handle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecoveryMachine</span> :</span> <span class=\"keyword\">public</span> boost::statechart::state_machine&lt;RecoveryMachine, Inital&gt; &#123;</span><br><span class=\"line\">    RecoveryState *state;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C_OnMapCommit</span> :</span> <span class=\"keyword\">public</span> Context&#123;</span><br><span class=\"line\">  OSD *osd;</span><br><span class=\"line\">  <span class=\"keyword\">epoch_t</span> first, last;</span><br><span class=\"line\">  MOSDMap *msg;</span><br><span class=\"line\">  C_OnMapCommit(OSD *o, <span class=\"keyword\">epoch_t</span> f, <span class=\"keyword\">epoch_t</span> l, MOSDMap *m)</span><br><span class=\"line\">    : osd(o), first(f), last(l), msg(m) &#123; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    osd -&gt; _committed_osd_maps(first, last, msg) ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Context - abstract callback class</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span>&#123;</span></span><br><span class=\"line\">   Context(<span class=\"keyword\">const</span> Context&amp; other);</span><br><span class=\"line\">   <span class=\"keyword\">const</span> Context&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Context&amp; other);</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Context() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Context() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">      finish(r);</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>ObjectStore</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"pg概述\"><a href=\"#pg概述\" class=\"headerlink\" title=\"pg概述\"></a>pg概述</h3><ul>\n<li>ReplicatedPG::do_request<br>|- ReplicatedPG::do_op  //仅仅分析请求类型为”CEPH_MSG_OSD_OP”<pre><code>|- ReplicatedPG::find_object_context\n      |-ReplicatedPG::execute_ctx    |- ReplicatedPG::get_object_context\n            |- ReplicatedPG::prepare_transaction\n                  |- ReplicatedPG::complete_read_ctx\n                  |- ReplicatedPG::start_async_reads\n                  |- ReplicatedPG::calc_trim_to\n                  |- ReplicatedPG::issue_repop  //向副本发送同步请求op\n                  |- ReplicatedPG::eval_repop   //检查发向各个副本的同步操作是否reply成功\n</code></pre>ReplicatedPG::issue_repop<br>  |-ReplicatedBackend::submit_transaction<pre><code>|- ReplicatedBackend::issue_op               |- ReplicatedBackend::parent_transactions\n   |- OSDService::send_message_osd_cluster          |- ReplicatedPG::queue_transactions\n                                                        |- FileStore\n</code></pre></li>\n</ul>\n<ul>\n<li><p>acting set<br>pg对应副本所在的OSD列表，列表是有序的，第一个osd 为 primary. 在通常情况下，up set和acting set 相同</p>\n</li>\n<li><p>up set<br>假设:acting set [0, 1, 2], 此时osd.0故障，导致monitor重新分配pg的acting set为[3, 1, 2], 此时osd.3不能承载pg的读io，所以向monitor申请一个临时的pg的osd.1 为主osd来承载读写，此时acting set为[3, 1, 2], up set [1, 3, 2]; acting set 与 up set不一致;<br>当osd.3 backfill完成之后, up set, acting set 均为[3, 1, 2]</p>\n</li>\n<li><p>current interval &amp;&amp; past_interval<br> 在序列(interval)之内，pg的acting set 和 up set不会变化; current是当前的序列，past则是上一个阶段的序列；</p>\n</li>\n<li><p>last_epoch_started:  pg peering完成之后的epoch</p>\n</li>\n<li>last_epoch_clean:  pg recovery完成，处于clean状态的epoch</li>\n</ul>\n<h3 id=\"PGBackend\"><a href=\"#PGBackend\" class=\"headerlink\" title=\"PGBackend\"></a>PGBackend</h3><p>PGBackend定义了逻辑上处理IO和副本</p>\n<ul>\n<li>处理client 操作</li>\n<li>处理对象恢复</li>\n<li>处理对象访问</li>\n<li><p>处理scrub, deep-scrub, repair</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osd/PGBackend.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PGBackend</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  ObjectStore *store;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">coll_t</span> coll;</span><br><span class=\"line\">  ObjectStore::CollectionHandle &amp;ch;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PGBackend 回调接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Listener</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// Recovery</span></span><br><span class=\"line\">  ......</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RecoveryHandle</span>&#123;</span></span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PG_SendMessageOnConn</span>:</span> <span class=\"keyword\">public</span> Context&#123;</span><br><span class=\"line\">  PGBackend::Listener *pg;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PG_RecoveryQueueAsync</span> :</span> <span class=\"keyword\">public</span> Context&#123;</span><br><span class=\"line\">  PGBackend::Listener *pg;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"ReplicatedBackend-多副本后端\"><a href=\"#ReplicatedBackend-多副本后端\" class=\"headerlink\" title=\"ReplicatedBackend(多副本后端)\"></a>ReplicatedBackend(多副本后端)</h3> <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osd/ReplicatedBackend.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReplicatedBackend</span> :</span> <span class=\"keyword\">public</span> PGBackend&#123;</span><br><span class=\"line\">  <span class=\"comment\">// RPGHandle: replicated PG handle</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RPGHandle</span> :</span> <span class=\"keyword\">public</span> PGBackend::RecoveryHandle&#123;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">pg_shard_t</span>, <span class=\"built_in\">vector</span>&lt;PushOp&gt; pushes;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">pg_shard_t</span>, <span class=\"built_in\">vector</span>&lt;PullOp&gt; pulls;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  class RPCReadPred : <span class=\"keyword\">public</span> IsPGReadablePredicate&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  class RPCReadPred : <span class=\"keyword\">public</span> IsPGReadablePredicate&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  struct PushInfo &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">hobject_t</span>, <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">pg_shard_t</span>, PushInfo&gt;, <span class=\"keyword\">hobject_t</span>::BitwiseComparator&gt; pushing;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct PullInfo&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">hobject_t</span>, PullInfo, <span class=\"keyword\">hobject_t</span>::BitwiseComparator&gt; pulling;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osd/ReplicatedPG.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReplicatedPG</span> :</span> <span class=\"keyword\">public</span> PG, <span class=\"keyword\">public</span> PGBackend::Listener&#123;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OSD</span>;</span></span><br><span class=\"line\">  .......</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```c++</span><br><span class=\"line\"><span class=\"comment\">//monitor向OSD端推送OSDMAP更新信息：</span></span><br><span class=\"line\">OSD::_dispatch()</span><br><span class=\"line\">  |- OSD::handle_osd_map()</span><br><span class=\"line\">      |- OSD::consume_map()</span><br><span class=\"line\">  |- PG::queue_null()</span><br><span class=\"line\">      |- PG::queue_peering_event()</span><br><span class=\"line\">          |- peering_queue.push_back(evt)   <span class=\"comment\">//CephPeeringEvtRef evt; 加入peering队列</span></span><br><span class=\"line\">          |- osd-&gt;queue_for_peering(<span class=\"keyword\">this</span>)   <span class=\"comment\">//osd进行peering处理流程</span></span><br><span class=\"line\">                  |- OSDService::queue_for_peering(PG *pg)</span><br><span class=\"line\">                      |- peering_wq.<span class=\"built_in\">queue</span>(pg)     <span class=\"comment\">//ThreadPool::BatchWorkQueue&lt;PG&gt; &amp;peering_wq;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  OSD::_dispatch()函数是消息处理的路由函数，根据消息类型调用具体的处理函数。对于处理Monitor节点发送过来的OSDMap消息，则由handle_osd_map()函数进行处理。在handle_osd_map()函数中首先对OSDMap消息进行解析且得到OSDMap且保存，之后调用consume_map()做进一步处理。在consume_map()函数中遍历该OSD节点上已有的PGs且统计出primary/replicas/stray的数量，其次唤醒等待OSDMap的PGs，最后遍历当前OSD节点上所有PGs且调用PG::queue_null()函数将OSD节点上所有PGs添加到peering队列中。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线程池工作队列开始工作, 入口</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> PG::handle_peering_event(CephPeeringEvtRef evt, RecoveryCtx *rctx)&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  recovery_state.handle_event(evt, rctx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handle_event</span><span class=\"params\">(<span class=\"keyword\">const</span> boost::statechart::event_base &amp;evt, RecoveryCtx *rctx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  start_handle(rctx);</span><br><span class=\"line\">  machine.process_event(evt);</span><br><span class=\"line\">  end_handle();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> PG::RecoveryState::start_handle(RecoveryCtx *new_ctx)&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecoveryState</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start_handle</span><span class=\"params\">(RecoveryCtx *new_ctx)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end_handle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecoveryMachine</span> :</span> <span class=\"keyword\">public</span> boost::statechart::state_machine&lt;RecoveryMachine, Inital&gt; &#123;</span><br><span class=\"line\">    RecoveryState *state;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C_OnMapCommit</span> :</span> <span class=\"keyword\">public</span> Context&#123;</span><br><span class=\"line\">  OSD *osd;</span><br><span class=\"line\">  <span class=\"keyword\">epoch_t</span> first, last;</span><br><span class=\"line\">  MOSDMap *msg;</span><br><span class=\"line\">  C_OnMapCommit(OSD *o, <span class=\"keyword\">epoch_t</span> f, <span class=\"keyword\">epoch_t</span> l, MOSDMap *m)</span><br><span class=\"line\">    : osd(o), first(f), last(l), msg(m) &#123; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    osd -&gt; _committed_osd_maps(first, last, msg) ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Context - abstract callback class</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span>&#123;</span></span><br><span class=\"line\">   Context(<span class=\"keyword\">const</span> Context&amp; other);</span><br><span class=\"line\">   <span class=\"keyword\">const</span> Context&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Context&amp; other);</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Context() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Context() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">      finish(r);</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>ObjectStore</p>\n"},{"title":"ceph_rbd_snap","date":"2018-11-09T16:00:00.000Z","_content":"\n对克隆块的写操作流程：//从这里明白多重克隆降低性能\n\n- 客户端（librbd）向对应的OSD发送正常的写请求；\n- OSD返回客户端(librbd)应答，表明该OSD上对应的对象不存在；\n- 客户端(librbd)发送读请求给克隆块的父块，读取对应snap1上的数据返回给客户端；\n- 客户端(librbd)把该快照数据写入克隆image中；\n- 客户端(librbd)把克隆image发送写操作，写入实际数据；\n\n由以上过程可知，克隆的拷贝操作由客户端控制完成，OSD 端是无感知的；\n\n### snap核心数据结构：\n\n- head object：对象的原始对象，可读、可写\n- snap object: 对某个对象做快照后，通过cow机制copy出来的快照对象只能读，不能写；\n- snap_seq: 快照序号，每次做快照，系统分配一个相应快照序号，主要是应用于写操作；\n- sanpdir object：当head对象被删除后，仍然有 snap 和 clone 对象，系统自动创建一个snapdir对象来保存SnapSet信息。head对象和snapdir对象只能存在一个，其属性保存了快照的相关信息；\n\n\n```c++\n//common/snap_types.h\n  struct SnapContext{\n    snapid_t seq;   //最新的快照序号\n    vector<snapid_t> snaps; //当前存在的快照序号，降序排列\n    ...\n  }\n```\nSnapContext在客户端(librbd)保存了snap相关信息, 该结构 持久化存储在RBD的元数据中；\n而用户写操作必须自己提供SnapContext信息；\n\n```c++\nstruct librados::IoCtxImpl{\n  ...\n  snapid_t snap_seq;\n  ::SnapContext snapc;\n  ...\n}\n```\n在librados::IoCtxImpl里，当打开一个image时候，需要读取块的元数据去构建该结构（初始化一下），\n如果打开的是卷的快照，那么snap_seq的值就是该snap对应的快照序号，\n否则snap_seq就为CEPH_NOSNAP(-2),表示操作的不是快照，而是卷本身；\n\nSnapSet用于保存Server端（OSD）与快照相关的信息：\n```c++\nstruct SnapSet{\n  snapid_t seq;     //最新的快照序号\n  bool head_exists;\n  vector<snapid_t> snaps;   //所有的快照序号列表（降序排列）\n  vector<snapid_t> clones;  //所有的clone对象序号列表 （升序排列）\n  map<snapid_t, interval_set<uint64_t> > clone_overlap;\n  map<snapid_t, uint64> clone_size;\n}\n```\n\nclone_overlap: 保存本次clone对象和上次clone对象（有可能是head对象）的overlap（重叠）的部分。\nclone操作后，每次写操作，都要维护这个信息； 这个信息用于数据恢复阶段对象恢复的优化；\n\n在Head对象的xattr中保存key为snapset， value为SnapSet结构序列化后的值；\n在Sanp对象的xattr中保存key为user.cephos.seq的snap_seq值；\n\n### RBD快照创建\n\n- 向Monitor发送请求，获取一个最新的快照序号snap_seq的值；\n- 把该次快照的snap_name和snap_seq的值保存到RBD的元数据中；\n在RBD的元数据里保存了所有快照的名字和对应的snap_seq号，并不会触发OSD端的数据操作，所以很快；\n\n\n### 快照的写操作\n\n  客户端的每次写操作，消息中必须带数据结构SnapContext信息，包含了客户端认为的最新快照序列号seq, 以及该对象的所有序号snaps的列表。\n在OSD端，对象的Snap相关信息则在SnapSet数据结构中，当有写操作时，处理过程按照如下规则进行：\n\n- 情景一： librbd(SnapContext)的seq < OSD(SnapSet)的seq：</br>\n  直接返回-EOLDSNAP错误;   <br>\n  一般而言，客户端（librbd）始终保持最新的快照序号；如果客户端不是最新的快照序号，则可能是：\n\n    - 多个客户端情况下，其他客户端创建了快照，本客户端没有获取到最新的快照序号\n  原理：Ceph rbd有一套Watcher回调通知机制来实现快照序号的更新，如果其他客户端对一个卷作了快照，会产生了一个最新的快照序号。OSD端接收到最新快照序号变化后，通知相应的连接客户端更新最新的快照序号。如果客户端没有及时更新，也没有太大问题，OSD端会返回客户端-EOLDSNAP，客户端会主动更新为最新的快照序号，重新发起写操作；\n\n- 情景二：如果head对象不存在，创建该对象并写入数据，用SnapContext相应的信息更新SnapSet的信息；\n- 情景三：如果librbd的seq = OSD的seq：做正常的读写\n- 情景四：librbd的seq > OSD的seq：<br>\n    - 对当前head对象做copy操作，clone出一个新的快照对象，该快照对象的snap序号为最新的序号，并把clone操作记录在clones列表里；也就是把最新的快照序号加入到clones列表里；\n    - 用SnapContext的 seq 和 snaps 值更新SnapSet的seq 和 snaps值；\n    - 写入最新的数据到head对象中；\n\n```c++\n//注释：捕获与正在进行的读写相关联的所有对象状态。\n// osd/ReplicatedPG.h\nstruct OpContext{\n  OpRequestRef op;\n  osd_reqid_t reqid;\n  vector<OSDOp> &ops;\n\n  const ObjectState *obs;   //old ObjectState\n  const SnapSet *snapset;   //old snapset, OSD端保存的快照信息\n\n  SnapContext snapc;           // writer snap context， 写操作自带的，也就是librbd的SnapContext信息；\n  ObjectState new_obs;  //resulting ObjectState 新的SnapSet\n  SnapSet     new_snapset;  //resulting SnapSet(in case of a write)\n  object_stat_sum_t delta_stats;\n\n  bool modify;          // (force) modification (even if op_t is empty)\n  bool user_modify;     // user-visible modification\n  bool undirty;         // user explicitly un-dirtying this object\n  bool cache_evict;     ///< true if this is a cache eviction\n  bool ignore_cache;    ///< true if IGNORE_CACHE flag is set\n  bool ignore_log_op_stats;  // don't log op stats\n\n  // side effects\n  list<pair<watch_info_t,bool> > watch_connects; ///< new watch + will_ping flag\n  list<watch_disconnect_t> watch_disconnects; ///< old watch + send_discon\n  list<notify_info_t> notifies;\n  struct NotifyAck {\n    boost::optional<uint64_t> watch_cookie;\n    uint64_t notify_id;\n    bufferlist reply_bl;\n    explicit NotifyAck(uint64_t notify_id) : notify_id(notify_id) {}\n    NotifyAck(uint64_t notify_id, uint64_t cookie, bufferlist& rbl)\n  : watch_cookie(cookie), notify_id(notify_id) {\n  reply_bl.claim(rbl);\n    }\n  };\n  list<NotifyAck> notify_acks;\n\n  uint64_t bytes_written, bytes_read;\n\n  utime_t mtime;\n\n  eversion_t at_version;       // pg's current version pointer\n  version_t user_at_version;   // pg's current user version pointer\n\n  int current_osd_subop_num;\n\n  PGBackend::PGTransactionUPtr op_t;\n  vector<pg_log_entry_t> log;\n  boost::optional<pg_hit_set_history_t> updated_hset_history;\n\n  interval_set<uint64_t> modified_ranges;\n  ObjectContextRef obc;\n  map<hobject_t,ObjectContextRef, hobject_t::BitwiseComparator> src_obc;\n  ObjectContextRef clone_obc;    // if we created a clone\n  ObjectContextRef snapset_obc;  // if we created/deleted a snapdir\n\n  int data_off;        // FIXME: we may want to kill this msgr hint off at some point!\n\n  MOSDOpReply *reply;\n  utime_t readable_stamp;  // when applied on all replicas\n  ReplicatedPG *pg;\n\n  int num_read;    ///< count read ops\n  int num_write;   ///< count update ops\n\n  vector<pair<osd_reqid_t, version_t> > extra_reqids;\n\n  CopyFromCallback *copy_cb;\n\n  hobject_t new_temp_oid, discard_temp_oid;  ///< temp objects we should start/stop tracking\n\n  // pending xattr updates\n  map<ObjectContextRef,\n  map<string, boost::optional<bufferlist> > > pending_attrs;\n\n  list<std::function<void()>> on_applied;\n  list<std::function<void()>> on_committed;\n  list<std::function<void()>> on_finish;\n  list<std::function<void()>> on_success;\n  bool sent_ack;\n  bool sent_disk;\n  ......\n}\n```\n- OSD端的写操作流程中， ReplicatedPG::execute_ctx中，把客户端消息中的SnapContext信息保存在OpContext的snapc中：\n\n```c++\nctx->snapc.seq = m->get_snap_seq();\nctx->snapc.snaps = m->get_snaps();\n```\n- 在ReplicatedPG::prepare_transaction里调用了函数ReplicatedPG::make_writeable来完成快照相关的操作：\n\n### 快照的读操作\n\n快照读取数据时，输入参数为RBd的名字和快照的名字，RBD客户端通过访问RBD的元数据，来获取快照对应的snap_id,也就是快照对应的snap_seq值；\n在OSD端，获取head对象保存的SnapSet数据结构，然后根据SnapSet中的snaps和clones值来计算快照所对应的正确的快照对象的ObjectContext；\n\n- clinet(librbd)对象快照oid.snap > osd 端快照序号 ssc->snapset.seq, 获取head对象就是该快照对应的时间数据对象。\n- 计算oid.snap首次大于ssc->snapset。clones列表中的克隆对象，就是oid对应的克隆对象；\n","source":"_posts/ceph_rbd_snap.md","raw":"---\n  title: ceph_rbd_snap\n  date: 2018-11-10\n  categories:\n    - ceph\n  tags:\n    - ceph \n    - snapshot\n---\n\n对克隆块的写操作流程：//从这里明白多重克隆降低性能\n\n- 客户端（librbd）向对应的OSD发送正常的写请求；\n- OSD返回客户端(librbd)应答，表明该OSD上对应的对象不存在；\n- 客户端(librbd)发送读请求给克隆块的父块，读取对应snap1上的数据返回给客户端；\n- 客户端(librbd)把该快照数据写入克隆image中；\n- 客户端(librbd)把克隆image发送写操作，写入实际数据；\n\n由以上过程可知，克隆的拷贝操作由客户端控制完成，OSD 端是无感知的；\n\n### snap核心数据结构：\n\n- head object：对象的原始对象，可读、可写\n- snap object: 对某个对象做快照后，通过cow机制copy出来的快照对象只能读，不能写；\n- snap_seq: 快照序号，每次做快照，系统分配一个相应快照序号，主要是应用于写操作；\n- sanpdir object：当head对象被删除后，仍然有 snap 和 clone 对象，系统自动创建一个snapdir对象来保存SnapSet信息。head对象和snapdir对象只能存在一个，其属性保存了快照的相关信息；\n\n\n```c++\n//common/snap_types.h\n  struct SnapContext{\n    snapid_t seq;   //最新的快照序号\n    vector<snapid_t> snaps; //当前存在的快照序号，降序排列\n    ...\n  }\n```\nSnapContext在客户端(librbd)保存了snap相关信息, 该结构 持久化存储在RBD的元数据中；\n而用户写操作必须自己提供SnapContext信息；\n\n```c++\nstruct librados::IoCtxImpl{\n  ...\n  snapid_t snap_seq;\n  ::SnapContext snapc;\n  ...\n}\n```\n在librados::IoCtxImpl里，当打开一个image时候，需要读取块的元数据去构建该结构（初始化一下），\n如果打开的是卷的快照，那么snap_seq的值就是该snap对应的快照序号，\n否则snap_seq就为CEPH_NOSNAP(-2),表示操作的不是快照，而是卷本身；\n\nSnapSet用于保存Server端（OSD）与快照相关的信息：\n```c++\nstruct SnapSet{\n  snapid_t seq;     //最新的快照序号\n  bool head_exists;\n  vector<snapid_t> snaps;   //所有的快照序号列表（降序排列）\n  vector<snapid_t> clones;  //所有的clone对象序号列表 （升序排列）\n  map<snapid_t, interval_set<uint64_t> > clone_overlap;\n  map<snapid_t, uint64> clone_size;\n}\n```\n\nclone_overlap: 保存本次clone对象和上次clone对象（有可能是head对象）的overlap（重叠）的部分。\nclone操作后，每次写操作，都要维护这个信息； 这个信息用于数据恢复阶段对象恢复的优化；\n\n在Head对象的xattr中保存key为snapset， value为SnapSet结构序列化后的值；\n在Sanp对象的xattr中保存key为user.cephos.seq的snap_seq值；\n\n### RBD快照创建\n\n- 向Monitor发送请求，获取一个最新的快照序号snap_seq的值；\n- 把该次快照的snap_name和snap_seq的值保存到RBD的元数据中；\n在RBD的元数据里保存了所有快照的名字和对应的snap_seq号，并不会触发OSD端的数据操作，所以很快；\n\n\n### 快照的写操作\n\n  客户端的每次写操作，消息中必须带数据结构SnapContext信息，包含了客户端认为的最新快照序列号seq, 以及该对象的所有序号snaps的列表。\n在OSD端，对象的Snap相关信息则在SnapSet数据结构中，当有写操作时，处理过程按照如下规则进行：\n\n- 情景一： librbd(SnapContext)的seq < OSD(SnapSet)的seq：</br>\n  直接返回-EOLDSNAP错误;   <br>\n  一般而言，客户端（librbd）始终保持最新的快照序号；如果客户端不是最新的快照序号，则可能是：\n\n    - 多个客户端情况下，其他客户端创建了快照，本客户端没有获取到最新的快照序号\n  原理：Ceph rbd有一套Watcher回调通知机制来实现快照序号的更新，如果其他客户端对一个卷作了快照，会产生了一个最新的快照序号。OSD端接收到最新快照序号变化后，通知相应的连接客户端更新最新的快照序号。如果客户端没有及时更新，也没有太大问题，OSD端会返回客户端-EOLDSNAP，客户端会主动更新为最新的快照序号，重新发起写操作；\n\n- 情景二：如果head对象不存在，创建该对象并写入数据，用SnapContext相应的信息更新SnapSet的信息；\n- 情景三：如果librbd的seq = OSD的seq：做正常的读写\n- 情景四：librbd的seq > OSD的seq：<br>\n    - 对当前head对象做copy操作，clone出一个新的快照对象，该快照对象的snap序号为最新的序号，并把clone操作记录在clones列表里；也就是把最新的快照序号加入到clones列表里；\n    - 用SnapContext的 seq 和 snaps 值更新SnapSet的seq 和 snaps值；\n    - 写入最新的数据到head对象中；\n\n```c++\n//注释：捕获与正在进行的读写相关联的所有对象状态。\n// osd/ReplicatedPG.h\nstruct OpContext{\n  OpRequestRef op;\n  osd_reqid_t reqid;\n  vector<OSDOp> &ops;\n\n  const ObjectState *obs;   //old ObjectState\n  const SnapSet *snapset;   //old snapset, OSD端保存的快照信息\n\n  SnapContext snapc;           // writer snap context， 写操作自带的，也就是librbd的SnapContext信息；\n  ObjectState new_obs;  //resulting ObjectState 新的SnapSet\n  SnapSet     new_snapset;  //resulting SnapSet(in case of a write)\n  object_stat_sum_t delta_stats;\n\n  bool modify;          // (force) modification (even if op_t is empty)\n  bool user_modify;     // user-visible modification\n  bool undirty;         // user explicitly un-dirtying this object\n  bool cache_evict;     ///< true if this is a cache eviction\n  bool ignore_cache;    ///< true if IGNORE_CACHE flag is set\n  bool ignore_log_op_stats;  // don't log op stats\n\n  // side effects\n  list<pair<watch_info_t,bool> > watch_connects; ///< new watch + will_ping flag\n  list<watch_disconnect_t> watch_disconnects; ///< old watch + send_discon\n  list<notify_info_t> notifies;\n  struct NotifyAck {\n    boost::optional<uint64_t> watch_cookie;\n    uint64_t notify_id;\n    bufferlist reply_bl;\n    explicit NotifyAck(uint64_t notify_id) : notify_id(notify_id) {}\n    NotifyAck(uint64_t notify_id, uint64_t cookie, bufferlist& rbl)\n  : watch_cookie(cookie), notify_id(notify_id) {\n  reply_bl.claim(rbl);\n    }\n  };\n  list<NotifyAck> notify_acks;\n\n  uint64_t bytes_written, bytes_read;\n\n  utime_t mtime;\n\n  eversion_t at_version;       // pg's current version pointer\n  version_t user_at_version;   // pg's current user version pointer\n\n  int current_osd_subop_num;\n\n  PGBackend::PGTransactionUPtr op_t;\n  vector<pg_log_entry_t> log;\n  boost::optional<pg_hit_set_history_t> updated_hset_history;\n\n  interval_set<uint64_t> modified_ranges;\n  ObjectContextRef obc;\n  map<hobject_t,ObjectContextRef, hobject_t::BitwiseComparator> src_obc;\n  ObjectContextRef clone_obc;    // if we created a clone\n  ObjectContextRef snapset_obc;  // if we created/deleted a snapdir\n\n  int data_off;        // FIXME: we may want to kill this msgr hint off at some point!\n\n  MOSDOpReply *reply;\n  utime_t readable_stamp;  // when applied on all replicas\n  ReplicatedPG *pg;\n\n  int num_read;    ///< count read ops\n  int num_write;   ///< count update ops\n\n  vector<pair<osd_reqid_t, version_t> > extra_reqids;\n\n  CopyFromCallback *copy_cb;\n\n  hobject_t new_temp_oid, discard_temp_oid;  ///< temp objects we should start/stop tracking\n\n  // pending xattr updates\n  map<ObjectContextRef,\n  map<string, boost::optional<bufferlist> > > pending_attrs;\n\n  list<std::function<void()>> on_applied;\n  list<std::function<void()>> on_committed;\n  list<std::function<void()>> on_finish;\n  list<std::function<void()>> on_success;\n  bool sent_ack;\n  bool sent_disk;\n  ......\n}\n```\n- OSD端的写操作流程中， ReplicatedPG::execute_ctx中，把客户端消息中的SnapContext信息保存在OpContext的snapc中：\n\n```c++\nctx->snapc.seq = m->get_snap_seq();\nctx->snapc.snaps = m->get_snaps();\n```\n- 在ReplicatedPG::prepare_transaction里调用了函数ReplicatedPG::make_writeable来完成快照相关的操作：\n\n### 快照的读操作\n\n快照读取数据时，输入参数为RBd的名字和快照的名字，RBD客户端通过访问RBD的元数据，来获取快照对应的snap_id,也就是快照对应的snap_seq值；\n在OSD端，获取head对象保存的SnapSet数据结构，然后根据SnapSet中的snaps和clones值来计算快照所对应的正确的快照对象的ObjectContext；\n\n- clinet(librbd)对象快照oid.snap > osd 端快照序号 ssc->snapset.seq, 获取head对象就是该快照对应的时间数据对象。\n- 计算oid.snap首次大于ssc->snapset。clones列表中的克隆对象，就是oid对应的克隆对象；\n","slug":"ceph_rbd_snap","published":1,"updated":"2020-02-14T03:40:47.988Z","_id":"cjl25n9qt000114havn5krktm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>对克隆块的写操作流程：//从这里明白多重克隆降低性能</p>\n<ul>\n<li>客户端（librbd）向对应的OSD发送正常的写请求；</li>\n<li>OSD返回客户端(librbd)应答，表明该OSD上对应的对象不存在；</li>\n<li>客户端(librbd)发送读请求给克隆块的父块，读取对应snap1上的数据返回给客户端；</li>\n<li>客户端(librbd)把该快照数据写入克隆image中；</li>\n<li>客户端(librbd)把克隆image发送写操作，写入实际数据；</li>\n</ul>\n<p>由以上过程可知，克隆的拷贝操作由客户端控制完成，OSD 端是无感知的；</p>\n<h3 id=\"snap核心数据结构：\"><a href=\"#snap核心数据结构：\" class=\"headerlink\" title=\"snap核心数据结构：\"></a>snap核心数据结构：</h3><ul>\n<li>head object：对象的原始对象，可读、可写</li>\n<li>snap object: 对某个对象做快照后，通过cow机制copy出来的快照对象只能读，不能写；</li>\n<li>snap_seq: 快照序号，每次做快照，系统分配一个相应快照序号，主要是应用于写操作；</li>\n<li>sanpdir object：当head对象被删除后，仍然有 snap 和 clone 对象，系统自动创建一个snapdir对象来保存SnapSet信息。head对象和snapdir对象只能存在一个，其属性保存了快照的相关信息；</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//common/snap_types.h</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SnapContext</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">snapid_t</span> seq;   <span class=\"comment\">//最新的快照序号</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">snapid_t</span>&gt; snaps; <span class=\"comment\">//当前存在的快照序号，降序排列</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>SnapContext在客户端(librbd)保存了snap相关信息, 该结构 持久化存储在RBD的元数据中；<br>而用户写操作必须自己提供SnapContext信息；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">librados</span>:</span>:IoCtxImpl&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> snap_seq;</span><br><span class=\"line\">  ::SnapContext snapc;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在librados::IoCtxImpl里，当打开一个image时候，需要读取块的元数据去构建该结构（初始化一下），<br>如果打开的是卷的快照，那么snap_seq的值就是该snap对应的快照序号，<br>否则snap_seq就为CEPH_NOSNAP(-2),表示操作的不是快照，而是卷本身；</p>\n<p>SnapSet用于保存Server端（OSD）与快照相关的信息：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SnapSet</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> seq;     <span class=\"comment\">//最新的快照序号</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> head_exists;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">snapid_t</span>&gt; snaps;   <span class=\"comment\">//所有的快照序号列表（降序排列）</span></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">snapid_t</span>&gt; clones;  <span class=\"comment\">//所有的clone对象序号列表 （升序排列）</span></span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">snapid_t</span>, interval_set&lt;<span class=\"keyword\">uint64_t</span>&gt; &gt; clone_overlap;</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">snapid_t</span>, uint64&gt; clone_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>clone_overlap: 保存本次clone对象和上次clone对象（有可能是head对象）的overlap（重叠）的部分。<br>clone操作后，每次写操作，都要维护这个信息； 这个信息用于数据恢复阶段对象恢复的优化；</p>\n<p>在Head对象的xattr中保存key为snapset， value为SnapSet结构序列化后的值；<br>在Sanp对象的xattr中保存key为user.cephos.seq的snap_seq值；</p>\n<h3 id=\"RBD快照创建\"><a href=\"#RBD快照创建\" class=\"headerlink\" title=\"RBD快照创建\"></a>RBD快照创建</h3><ul>\n<li>向Monitor发送请求，获取一个最新的快照序号snap_seq的值；</li>\n<li>把该次快照的snap_name和snap_seq的值保存到RBD的元数据中；<br>在RBD的元数据里保存了所有快照的名字和对应的snap_seq号，并不会触发OSD端的数据操作，所以很快；</li>\n</ul>\n<h3 id=\"快照的写操作\"><a href=\"#快照的写操作\" class=\"headerlink\" title=\"快照的写操作\"></a>快照的写操作</h3><p>  客户端的每次写操作，消息中必须带数据结构SnapContext信息，包含了客户端认为的最新快照序列号seq, 以及该对象的所有序号snaps的列表。<br>在OSD端，对象的Snap相关信息则在SnapSet数据结构中，当有写操作时，处理过程按照如下规则进行：</p>\n<ul>\n<li><p>情景一： librbd(SnapContext)的seq &lt; OSD(SnapSet)的seq：<br><br>直接返回-EOLDSNAP错误;   <br><br>一般而言，客户端（librbd）始终保持最新的快照序号；如果客户端不是最新的快照序号，则可能是：</p>\n<ul>\n<li>多个客户端情况下，其他客户端创建了快照，本客户端没有获取到最新的快照序号<br>原理：Ceph rbd有一套Watcher回调通知机制来实现快照序号的更新，如果其他客户端对一个卷作了快照，会产生了一个最新的快照序号。OSD端接收到最新快照序号变化后，通知相应的连接客户端更新最新的快照序号。如果客户端没有及时更新，也没有太大问题，OSD端会返回客户端-EOLDSNAP，客户端会主动更新为最新的快照序号，重新发起写操作；</li>\n</ul>\n</li>\n<li><p>情景二：如果head对象不存在，创建该对象并写入数据，用SnapContext相应的信息更新SnapSet的信息；</p>\n</li>\n<li>情景三：如果librbd的seq = OSD的seq：做正常的读写</li>\n<li>情景四：librbd的seq &gt; OSD的seq：<br><ul>\n<li>对当前head对象做copy操作，clone出一个新的快照对象，该快照对象的snap序号为最新的序号，并把clone操作记录在clones列表里；也就是把最新的快照序号加入到clones列表里；</li>\n<li>用SnapContext的 seq 和 snaps 值更新SnapSet的seq 和 snaps值；</li>\n<li>写入最新的数据到head对象中；</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注释：捕获与正在进行的读写相关联的所有对象状态。</span></span><br><span class=\"line\"><span class=\"comment\">// osd/ReplicatedPG.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OpContext</span>&#123;</span></span><br><span class=\"line\">  OpRequestRef op;</span><br><span class=\"line\">  <span class=\"keyword\">osd_reqid_t</span> reqid;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;OSDOp&gt; &amp;ops;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ObjectState *obs;   <span class=\"comment\">//old ObjectState</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> SnapSet *snapset;   <span class=\"comment\">//old snapset, OSD端保存的快照信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  SnapContext snapc;           <span class=\"comment\">// writer snap context， 写操作自带的，也就是librbd的SnapContext信息；</span></span><br><span class=\"line\">  ObjectState new_obs;  <span class=\"comment\">//resulting ObjectState 新的SnapSet</span></span><br><span class=\"line\">  SnapSet     new_snapset;  <span class=\"comment\">//resulting SnapSet(in case of a write)</span></span><br><span class=\"line\">  <span class=\"keyword\">object_stat_sum_t</span> delta_stats;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> modify;          <span class=\"comment\">// (force) modification (even if op_t is empty)</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> user_modify;     <span class=\"comment\">// user-visible modification</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> undirty;         <span class=\"comment\">// user explicitly un-dirtying this object</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> cache_evict;     <span class=\"comment\">///&lt; true if this is a cache eviction</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> ignore_cache;    <span class=\"comment\">///&lt; true if IGNORE_CACHE flag is set</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> ignore_log_op_stats;  <span class=\"comment\">// don't log op stats</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// side effects</span></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;pair&lt;<span class=\"keyword\">watch_info_t</span>,<span class=\"keyword\">bool</span>&gt; &gt; watch_connects; <span class=\"comment\">///&lt; new watch + will_ping flag</span></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">watch_disconnect_t</span>&gt; watch_disconnects; <span class=\"comment\">///&lt; old watch + send_discon</span></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">notify_info_t</span>&gt; notifies;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NotifyAck</span> &#123;</span></span><br><span class=\"line\">    boost::optional&lt;<span class=\"keyword\">uint64_t</span>&gt; watch_cookie;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> notify_id;</span><br><span class=\"line\">    bufferlist reply_bl;</span><br><span class=\"line\">    explicit NotifyAck(uint64_t notify_id) : notify_id(notify_id) &#123;&#125;</span><br><span class=\"line\">    NotifyAck(<span class=\"keyword\">uint64_t</span> notify_id, <span class=\"keyword\">uint64_t</span> cookie, bufferlist&amp; rbl)</span><br><span class=\"line\">  : watch_cookie(cookie), notify_id(notify_id) &#123;</span><br><span class=\"line\">  reply_bl.claim(rbl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;NotifyAck&gt; notify_acks;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint64_t</span> bytes_written, bytes_read;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">utime_t</span> mtime;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">eversion_t</span> at_version;       <span class=\"comment\">// pg's current version pointer</span></span><br><span class=\"line\">  <span class=\"keyword\">version_t</span> user_at_version;   <span class=\"comment\">// pg's current user version pointer</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> current_osd_subop_num;</span><br><span class=\"line\"></span><br><span class=\"line\">  PGBackend::PGTransactionUPtr <span class=\"keyword\">op_t</span>;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">pg_log_entry_t</span>&gt; <span class=\"built_in\">log</span>;</span><br><span class=\"line\">  boost::optional&lt;<span class=\"keyword\">pg_hit_set_history_t</span>&gt; updated_hset_history;</span><br><span class=\"line\"></span><br><span class=\"line\">  interval_set&lt;<span class=\"keyword\">uint64_t</span>&gt; modified_ranges;</span><br><span class=\"line\">  ObjectContextRef obc;</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">hobject_t</span>,ObjectContextRef, <span class=\"keyword\">hobject_t</span>::BitwiseComparator&gt; src_obc;</span><br><span class=\"line\">  ObjectContextRef clone_obc;    <span class=\"comment\">// if we created a clone</span></span><br><span class=\"line\">  ObjectContextRef snapset_obc;  <span class=\"comment\">// if we created/deleted a snapdir</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> data_off;        <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> we may want to kill this msgr hint off at some point!</span></span><br><span class=\"line\"></span><br><span class=\"line\">  MOSDOpReply *reply;</span><br><span class=\"line\">  <span class=\"keyword\">utime_t</span> readable_stamp;  <span class=\"comment\">// when applied on all replicas</span></span><br><span class=\"line\">  ReplicatedPG *pg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> num_read;    <span class=\"comment\">///&lt; count read ops</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> num_write;   <span class=\"comment\">///&lt; count update ops</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">osd_reqid_t</span>, <span class=\"keyword\">version_t</span>&gt; &gt; extra_reqids;</span><br><span class=\"line\"></span><br><span class=\"line\">  CopyFromCallback *copy_cb;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> new_temp_oid, discard_temp_oid;  <span class=\"comment\">///&lt; temp objects we should start/stop tracking</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// pending xattr updates</span></span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;ObjectContextRef,</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, boost::optional&lt;bufferlist&gt; &gt; &gt; pending_attrs;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_applied;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_committed;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_finish;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_success;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> sent_ack;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> sent_disk;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>OSD端的写操作流程中， ReplicatedPG::execute_ctx中，把客户端消息中的SnapContext信息保存在OpContext的snapc中：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx-&gt;snapc.seq = m-&gt;get_snap_seq();</span><br><span class=\"line\">ctx-&gt;snapc.snaps = m-&gt;get_snaps();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在ReplicatedPG::prepare_transaction里调用了函数ReplicatedPG::make_writeable来完成快照相关的操作：</li>\n</ul>\n<h3 id=\"快照的读操作\"><a href=\"#快照的读操作\" class=\"headerlink\" title=\"快照的读操作\"></a>快照的读操作</h3><p>快照读取数据时，输入参数为RBd的名字和快照的名字，RBD客户端通过访问RBD的元数据，来获取快照对应的snap_id,也就是快照对应的snap_seq值；<br>在OSD端，获取head对象保存的SnapSet数据结构，然后根据SnapSet中的snaps和clones值来计算快照所对应的正确的快照对象的ObjectContext；</p>\n<ul>\n<li>clinet(librbd)对象快照oid.snap &gt; osd 端快照序号 ssc-&gt;snapset.seq, 获取head对象就是该快照对应的时间数据对象。</li>\n<li>计算oid.snap首次大于ssc-&gt;snapset。clones列表中的克隆对象，就是oid对应的克隆对象；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>对克隆块的写操作流程：//从这里明白多重克隆降低性能</p>\n<ul>\n<li>客户端（librbd）向对应的OSD发送正常的写请求；</li>\n<li>OSD返回客户端(librbd)应答，表明该OSD上对应的对象不存在；</li>\n<li>客户端(librbd)发送读请求给克隆块的父块，读取对应snap1上的数据返回给客户端；</li>\n<li>客户端(librbd)把该快照数据写入克隆image中；</li>\n<li>客户端(librbd)把克隆image发送写操作，写入实际数据；</li>\n</ul>\n<p>由以上过程可知，克隆的拷贝操作由客户端控制完成，OSD 端是无感知的；</p>\n<h3 id=\"snap核心数据结构：\"><a href=\"#snap核心数据结构：\" class=\"headerlink\" title=\"snap核心数据结构：\"></a>snap核心数据结构：</h3><ul>\n<li>head object：对象的原始对象，可读、可写</li>\n<li>snap object: 对某个对象做快照后，通过cow机制copy出来的快照对象只能读，不能写；</li>\n<li>snap_seq: 快照序号，每次做快照，系统分配一个相应快照序号，主要是应用于写操作；</li>\n<li>sanpdir object：当head对象被删除后，仍然有 snap 和 clone 对象，系统自动创建一个snapdir对象来保存SnapSet信息。head对象和snapdir对象只能存在一个，其属性保存了快照的相关信息；</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//common/snap_types.h</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SnapContext</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">snapid_t</span> seq;   <span class=\"comment\">//最新的快照序号</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">snapid_t</span>&gt; snaps; <span class=\"comment\">//当前存在的快照序号，降序排列</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>SnapContext在客户端(librbd)保存了snap相关信息, 该结构 持久化存储在RBD的元数据中；<br>而用户写操作必须自己提供SnapContext信息；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">librados</span>:</span>:IoCtxImpl&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> snap_seq;</span><br><span class=\"line\">  ::SnapContext snapc;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在librados::IoCtxImpl里，当打开一个image时候，需要读取块的元数据去构建该结构（初始化一下），<br>如果打开的是卷的快照，那么snap_seq的值就是该snap对应的快照序号，<br>否则snap_seq就为CEPH_NOSNAP(-2),表示操作的不是快照，而是卷本身；</p>\n<p>SnapSet用于保存Server端（OSD）与快照相关的信息：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SnapSet</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> seq;     <span class=\"comment\">//最新的快照序号</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> head_exists;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">snapid_t</span>&gt; snaps;   <span class=\"comment\">//所有的快照序号列表（降序排列）</span></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">snapid_t</span>&gt; clones;  <span class=\"comment\">//所有的clone对象序号列表 （升序排列）</span></span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">snapid_t</span>, interval_set&lt;<span class=\"keyword\">uint64_t</span>&gt; &gt; clone_overlap;</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">snapid_t</span>, uint64&gt; clone_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>clone_overlap: 保存本次clone对象和上次clone对象（有可能是head对象）的overlap（重叠）的部分。<br>clone操作后，每次写操作，都要维护这个信息； 这个信息用于数据恢复阶段对象恢复的优化；</p>\n<p>在Head对象的xattr中保存key为snapset， value为SnapSet结构序列化后的值；<br>在Sanp对象的xattr中保存key为user.cephos.seq的snap_seq值；</p>\n<h3 id=\"RBD快照创建\"><a href=\"#RBD快照创建\" class=\"headerlink\" title=\"RBD快照创建\"></a>RBD快照创建</h3><ul>\n<li>向Monitor发送请求，获取一个最新的快照序号snap_seq的值；</li>\n<li>把该次快照的snap_name和snap_seq的值保存到RBD的元数据中；<br>在RBD的元数据里保存了所有快照的名字和对应的snap_seq号，并不会触发OSD端的数据操作，所以很快；</li>\n</ul>\n<h3 id=\"快照的写操作\"><a href=\"#快照的写操作\" class=\"headerlink\" title=\"快照的写操作\"></a>快照的写操作</h3><p>  客户端的每次写操作，消息中必须带数据结构SnapContext信息，包含了客户端认为的最新快照序列号seq, 以及该对象的所有序号snaps的列表。<br>在OSD端，对象的Snap相关信息则在SnapSet数据结构中，当有写操作时，处理过程按照如下规则进行：</p>\n<ul>\n<li><p>情景一： librbd(SnapContext)的seq &lt; OSD(SnapSet)的seq：<br><br>直接返回-EOLDSNAP错误;   <br><br>一般而言，客户端（librbd）始终保持最新的快照序号；如果客户端不是最新的快照序号，则可能是：</p>\n<ul>\n<li>多个客户端情况下，其他客户端创建了快照，本客户端没有获取到最新的快照序号<br>原理：Ceph rbd有一套Watcher回调通知机制来实现快照序号的更新，如果其他客户端对一个卷作了快照，会产生了一个最新的快照序号。OSD端接收到最新快照序号变化后，通知相应的连接客户端更新最新的快照序号。如果客户端没有及时更新，也没有太大问题，OSD端会返回客户端-EOLDSNAP，客户端会主动更新为最新的快照序号，重新发起写操作；</li>\n</ul>\n</li>\n<li><p>情景二：如果head对象不存在，创建该对象并写入数据，用SnapContext相应的信息更新SnapSet的信息；</p>\n</li>\n<li>情景三：如果librbd的seq = OSD的seq：做正常的读写</li>\n<li>情景四：librbd的seq &gt; OSD的seq：<br><ul>\n<li>对当前head对象做copy操作，clone出一个新的快照对象，该快照对象的snap序号为最新的序号，并把clone操作记录在clones列表里；也就是把最新的快照序号加入到clones列表里；</li>\n<li>用SnapContext的 seq 和 snaps 值更新SnapSet的seq 和 snaps值；</li>\n<li>写入最新的数据到head对象中；</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注释：捕获与正在进行的读写相关联的所有对象状态。</span></span><br><span class=\"line\"><span class=\"comment\">// osd/ReplicatedPG.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OpContext</span>&#123;</span></span><br><span class=\"line\">  OpRequestRef op;</span><br><span class=\"line\">  <span class=\"keyword\">osd_reqid_t</span> reqid;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;OSDOp&gt; &amp;ops;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ObjectState *obs;   <span class=\"comment\">//old ObjectState</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> SnapSet *snapset;   <span class=\"comment\">//old snapset, OSD端保存的快照信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  SnapContext snapc;           <span class=\"comment\">// writer snap context， 写操作自带的，也就是librbd的SnapContext信息；</span></span><br><span class=\"line\">  ObjectState new_obs;  <span class=\"comment\">//resulting ObjectState 新的SnapSet</span></span><br><span class=\"line\">  SnapSet     new_snapset;  <span class=\"comment\">//resulting SnapSet(in case of a write)</span></span><br><span class=\"line\">  <span class=\"keyword\">object_stat_sum_t</span> delta_stats;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> modify;          <span class=\"comment\">// (force) modification (even if op_t is empty)</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> user_modify;     <span class=\"comment\">// user-visible modification</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> undirty;         <span class=\"comment\">// user explicitly un-dirtying this object</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> cache_evict;     <span class=\"comment\">///&lt; true if this is a cache eviction</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> ignore_cache;    <span class=\"comment\">///&lt; true if IGNORE_CACHE flag is set</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> ignore_log_op_stats;  <span class=\"comment\">// don't log op stats</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// side effects</span></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;pair&lt;<span class=\"keyword\">watch_info_t</span>,<span class=\"keyword\">bool</span>&gt; &gt; watch_connects; <span class=\"comment\">///&lt; new watch + will_ping flag</span></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">watch_disconnect_t</span>&gt; watch_disconnects; <span class=\"comment\">///&lt; old watch + send_discon</span></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">notify_info_t</span>&gt; notifies;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NotifyAck</span> &#123;</span></span><br><span class=\"line\">    boost::optional&lt;<span class=\"keyword\">uint64_t</span>&gt; watch_cookie;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> notify_id;</span><br><span class=\"line\">    bufferlist reply_bl;</span><br><span class=\"line\">    explicit NotifyAck(uint64_t notify_id) : notify_id(notify_id) &#123;&#125;</span><br><span class=\"line\">    NotifyAck(<span class=\"keyword\">uint64_t</span> notify_id, <span class=\"keyword\">uint64_t</span> cookie, bufferlist&amp; rbl)</span><br><span class=\"line\">  : watch_cookie(cookie), notify_id(notify_id) &#123;</span><br><span class=\"line\">  reply_bl.claim(rbl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;NotifyAck&gt; notify_acks;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint64_t</span> bytes_written, bytes_read;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">utime_t</span> mtime;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">eversion_t</span> at_version;       <span class=\"comment\">// pg's current version pointer</span></span><br><span class=\"line\">  <span class=\"keyword\">version_t</span> user_at_version;   <span class=\"comment\">// pg's current user version pointer</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> current_osd_subop_num;</span><br><span class=\"line\"></span><br><span class=\"line\">  PGBackend::PGTransactionUPtr <span class=\"keyword\">op_t</span>;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">pg_log_entry_t</span>&gt; <span class=\"built_in\">log</span>;</span><br><span class=\"line\">  boost::optional&lt;<span class=\"keyword\">pg_hit_set_history_t</span>&gt; updated_hset_history;</span><br><span class=\"line\"></span><br><span class=\"line\">  interval_set&lt;<span class=\"keyword\">uint64_t</span>&gt; modified_ranges;</span><br><span class=\"line\">  ObjectContextRef obc;</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">hobject_t</span>,ObjectContextRef, <span class=\"keyword\">hobject_t</span>::BitwiseComparator&gt; src_obc;</span><br><span class=\"line\">  ObjectContextRef clone_obc;    <span class=\"comment\">// if we created a clone</span></span><br><span class=\"line\">  ObjectContextRef snapset_obc;  <span class=\"comment\">// if we created/deleted a snapdir</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> data_off;        <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> we may want to kill this msgr hint off at some point!</span></span><br><span class=\"line\"></span><br><span class=\"line\">  MOSDOpReply *reply;</span><br><span class=\"line\">  <span class=\"keyword\">utime_t</span> readable_stamp;  <span class=\"comment\">// when applied on all replicas</span></span><br><span class=\"line\">  ReplicatedPG *pg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> num_read;    <span class=\"comment\">///&lt; count read ops</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> num_write;   <span class=\"comment\">///&lt; count update ops</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">osd_reqid_t</span>, <span class=\"keyword\">version_t</span>&gt; &gt; extra_reqids;</span><br><span class=\"line\"></span><br><span class=\"line\">  CopyFromCallback *copy_cb;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> new_temp_oid, discard_temp_oid;  <span class=\"comment\">///&lt; temp objects we should start/stop tracking</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// pending xattr updates</span></span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;ObjectContextRef,</span><br><span class=\"line\">  <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, boost::optional&lt;bufferlist&gt; &gt; &gt; pending_attrs;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_applied;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_committed;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_finish;</span><br><span class=\"line\">  <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt;&gt; on_success;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> sent_ack;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> sent_disk;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>OSD端的写操作流程中， ReplicatedPG::execute_ctx中，把客户端消息中的SnapContext信息保存在OpContext的snapc中：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx-&gt;snapc.seq = m-&gt;get_snap_seq();</span><br><span class=\"line\">ctx-&gt;snapc.snaps = m-&gt;get_snaps();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在ReplicatedPG::prepare_transaction里调用了函数ReplicatedPG::make_writeable来完成快照相关的操作：</li>\n</ul>\n<h3 id=\"快照的读操作\"><a href=\"#快照的读操作\" class=\"headerlink\" title=\"快照的读操作\"></a>快照的读操作</h3><p>快照读取数据时，输入参数为RBd的名字和快照的名字，RBD客户端通过访问RBD的元数据，来获取快照对应的snap_id,也就是快照对应的snap_seq值；<br>在OSD端，获取head对象保存的SnapSet数据结构，然后根据SnapSet中的snaps和clones值来计算快照所对应的正确的快照对象的ObjectContext；</p>\n<ul>\n<li>clinet(librbd)对象快照oid.snap &gt; osd 端快照序号 ssc-&gt;snapset.seq, 获取head对象就是该快照对应的时间数据对象。</li>\n<li>计算oid.snap首次大于ssc-&gt;snapset。clones列表中的克隆对象，就是oid对应的克隆对象；</li>\n</ul>\n"},{"title":"librbd分析","date":"2018-04-14T16:00:00.000Z","_content":"\n//通过lib形式调用，所以不走main函数\n```cpp\n//创建rbd块  -- librbd/librbd.cc\nint RBD::create(IoCtx& io_ctx, const char *name, uint64_t size, int *order)\n{\n  int r = librbd::create(io_ctx, name, size, order);\n  return r\n}\n\n//调用librbd::create --librbd/internal.cc\nint create(librados::IoCtx& io_ctx, const char *imgname, uint64_t size, int *order)\n{\n    ...\n    return create(io_ctx, imgname, size, old_format, features, order, 0, 0);\n}\n\n//调用create  --librbd/internal.cc\nint create(IoCtx& io_ctx, const char *imgname, uint64_t size, bool old_format, uint64_t features, int *order,  uint64_t stripe_unit, uint64_t stripe_count)\n{\n  ...   //ImageOptions opts\n  r = create(io_ctx, imgname, size, opts, \"\", \"\")\n  ...\n}\n\n//调用create  -- librbd/internal.cc\nint create(IoCtx& io_ctx, const char *imgname, uint64_t size, ImageOptions& opts, const std::string &non_primary_global_image_id,\n  const std::string &primary_mirror_uuid)\n{\n  ...\n  r = create_v1(io_ctx, imgname, bid, size, order);\n  ...\n  r = create_v2(io_ctx, imgname, bid, size, order, features, stripe_unit, stripe_count, journal_order, journal_splay_width, journal_pool,\n    non_primary_global_image_id, primary_mirror_uuid);\n}\n\n//调用create_v2  --librbd/internal.cc\nint create_v2(IoCtx& io_ctx, const char *imgname, uint64_t bid, uint64_t size, int order,\n  uint64_t features, uint64_t stripe_unit, uint64_t stripe_count, uint8_t journal_order,\n  uint8_t journal_splay_width, const std::string &journal_pool,const std::string &non_primary_global_image_id,\n  const std::string &primary_mirror_uuid)\n{\n  ...\n  id_obj = util::id_obj_name(imgname)   //rbd_id.{imagname}\n  r = io_ctx.create(id_obj, true);      //创建object; 对象名为rbd_id.{imgname}\n\n  //setting image id\n  r = cls_client::set_id(&io_ctx, id_obj, id);\n\n  //adding rbd image to directory\n  r = cls_client::dir_add_image(&io_ctx, RBD_DIRECTORY, imgname, id);\n\n  header_osd = util::header_name(id);\n  r = cls_client::create_image(&io_ctx, header_oid, size, order, features, oss.str());\n\n  //关于feature设定\n}\n\n//cls_client::create_image()  -- cls/rbd/cls_rbd_client.cc\nint create_image(librados::IoCtx *ioctx, const std::string &oid, uint64_t size, uint8_t order, uint64_t features\n  const std::string &object_prefix)\n{\n    return ioctx->exec(oid, \"rbd\", \"create\", bl, bl2);\n}\n\n//librados::IoCtx::exec()    -- librados/librados.cc\nint librados::IoCtx::exec(const std::string& oid, const char *cls, const char* method, bufferlist& inbl, bufferlist& outbl)\n{\n  object_t obj(oid);\n  return io_ctx_impl->exec(obj, cls, method, inbl, outbl);\n}\n\n//io_ctx_impl->exec()  --librados/IoCtxImpl.cc\nint librados::IoCtxImpl::exec(const object_t& oid, const char *cls, const char *method, bufferlist& inbl, bufferlist& outbl)\n{\n    ::ObjectOperation rd;\n    prepare_assert_ops(&rd);\n    rd.call(cls, method, inbl);\n    return operate_read(oid, &rd, &outbl);\n}\n```\n","source":"_posts/librbd.md","raw":"---\n  title: librbd分析\n  date: 2018-04-15\n  categories:\n  - ceph\n  tags:\n    - librbd\n    - ceph\n---\n\n//通过lib形式调用，所以不走main函数\n```cpp\n//创建rbd块  -- librbd/librbd.cc\nint RBD::create(IoCtx& io_ctx, const char *name, uint64_t size, int *order)\n{\n  int r = librbd::create(io_ctx, name, size, order);\n  return r\n}\n\n//调用librbd::create --librbd/internal.cc\nint create(librados::IoCtx& io_ctx, const char *imgname, uint64_t size, int *order)\n{\n    ...\n    return create(io_ctx, imgname, size, old_format, features, order, 0, 0);\n}\n\n//调用create  --librbd/internal.cc\nint create(IoCtx& io_ctx, const char *imgname, uint64_t size, bool old_format, uint64_t features, int *order,  uint64_t stripe_unit, uint64_t stripe_count)\n{\n  ...   //ImageOptions opts\n  r = create(io_ctx, imgname, size, opts, \"\", \"\")\n  ...\n}\n\n//调用create  -- librbd/internal.cc\nint create(IoCtx& io_ctx, const char *imgname, uint64_t size, ImageOptions& opts, const std::string &non_primary_global_image_id,\n  const std::string &primary_mirror_uuid)\n{\n  ...\n  r = create_v1(io_ctx, imgname, bid, size, order);\n  ...\n  r = create_v2(io_ctx, imgname, bid, size, order, features, stripe_unit, stripe_count, journal_order, journal_splay_width, journal_pool,\n    non_primary_global_image_id, primary_mirror_uuid);\n}\n\n//调用create_v2  --librbd/internal.cc\nint create_v2(IoCtx& io_ctx, const char *imgname, uint64_t bid, uint64_t size, int order,\n  uint64_t features, uint64_t stripe_unit, uint64_t stripe_count, uint8_t journal_order,\n  uint8_t journal_splay_width, const std::string &journal_pool,const std::string &non_primary_global_image_id,\n  const std::string &primary_mirror_uuid)\n{\n  ...\n  id_obj = util::id_obj_name(imgname)   //rbd_id.{imagname}\n  r = io_ctx.create(id_obj, true);      //创建object; 对象名为rbd_id.{imgname}\n\n  //setting image id\n  r = cls_client::set_id(&io_ctx, id_obj, id);\n\n  //adding rbd image to directory\n  r = cls_client::dir_add_image(&io_ctx, RBD_DIRECTORY, imgname, id);\n\n  header_osd = util::header_name(id);\n  r = cls_client::create_image(&io_ctx, header_oid, size, order, features, oss.str());\n\n  //关于feature设定\n}\n\n//cls_client::create_image()  -- cls/rbd/cls_rbd_client.cc\nint create_image(librados::IoCtx *ioctx, const std::string &oid, uint64_t size, uint8_t order, uint64_t features\n  const std::string &object_prefix)\n{\n    return ioctx->exec(oid, \"rbd\", \"create\", bl, bl2);\n}\n\n//librados::IoCtx::exec()    -- librados/librados.cc\nint librados::IoCtx::exec(const std::string& oid, const char *cls, const char* method, bufferlist& inbl, bufferlist& outbl)\n{\n  object_t obj(oid);\n  return io_ctx_impl->exec(obj, cls, method, inbl, outbl);\n}\n\n//io_ctx_impl->exec()  --librados/IoCtxImpl.cc\nint librados::IoCtxImpl::exec(const object_t& oid, const char *cls, const char *method, bufferlist& inbl, bufferlist& outbl)\n{\n    ::ObjectOperation rd;\n    prepare_assert_ops(&rd);\n    rd.call(cls, method, inbl);\n    return operate_read(oid, &rd, &outbl);\n}\n```\n","slug":"librbd","published":1,"updated":"2018-12-25T11:18:57.098Z","_id":"cjl25n9r4000614har5z5alhd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>//通过lib形式调用，所以不走main函数<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建rbd块  -- librbd/librbd.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> RBD::create(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">int</span> *order)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> r = librbd::create(io_ctx, name, size, order);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用librbd::create --librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> create(librados::IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">int</span> *order)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> create(io_ctx, imgname, size, old_format, features, order, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用create  --librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create</span><span class=\"params\">(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">bool</span> old_format, <span class=\"keyword\">uint64_t</span> features, <span class=\"keyword\">int</span> *order,  <span class=\"keyword\">uint64_t</span> stripe_unit, <span class=\"keyword\">uint64_t</span> stripe_count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  ...   <span class=\"comment\">//ImageOptions opts</span></span><br><span class=\"line\">  r = create(io_ctx, imgname, size, opts, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用create  -- librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> create(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> size, ImageOptions&amp; opts, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;non_primary_global_image_id,</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;primary_mirror_uuid)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  r = create_v1(io_ctx, imgname, bid, size, order);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  r = create_v2(io_ctx, imgname, bid, size, order, features, stripe_unit, stripe_count, journal_order, journal_splay_width, journal_pool,</span><br><span class=\"line\">    non_primary_global_image_id, primary_mirror_uuid);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用create_v2  --librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create_v2</span><span class=\"params\">(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> bid, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">int</span> order,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">uint64_t</span> features, <span class=\"keyword\">uint64_t</span> stripe_unit, <span class=\"keyword\">uint64_t</span> stripe_count, <span class=\"keyword\">uint8_t</span> journal_order,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">uint8_t</span> journal_splay_width, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;journal_pool,<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;non_primary_global_image_id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;primary_mirror_uuid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  id_obj = util::id_obj_name(imgname)   <span class=\"comment\">//rbd_id.&#123;imagname&#125;</span></span><br><span class=\"line\">  r = io_ctx.create(id_obj, <span class=\"literal\">true</span>);      <span class=\"comment\">//创建object; 对象名为rbd_id.&#123;imgname&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//setting image id</span></span><br><span class=\"line\">  r = cls_client::set_id(&amp;io_ctx, id_obj, id);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//adding rbd image to directory</span></span><br><span class=\"line\">  r = cls_client::dir_add_image(&amp;io_ctx, RBD_DIRECTORY, imgname, id);</span><br><span class=\"line\"></span><br><span class=\"line\">  header_osd = util::header_name(id);</span><br><span class=\"line\">  r = cls_client::create_image(&amp;io_ctx, header_oid, size, order, features, oss.str());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//关于feature设定</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//cls_client::create_image()  -- cls/rbd/cls_rbd_client.cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create_image</span><span class=\"params\">(librados::IoCtx *ioctx, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;oid, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">uint8_t</span> order, <span class=\"keyword\">uint64_t</span> features</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;object_prefix)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ioctx-&gt;exec(oid, <span class=\"string\">\"rbd\"</span>, <span class=\"string\">\"create\"</span>, bl, bl2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//librados::IoCtx::exec()    -- librados/librados.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> librados::IoCtx::exec(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* method, bufferlist&amp; inbl, bufferlist&amp; outbl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">object_t</span> obj(oid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> io_ctx_impl-&gt;exec(obj, cls, method, inbl, outbl);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//io_ctx_impl-&gt;exec()  --librados/IoCtxImpl.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> librados::IoCtxImpl::exec(<span class=\"keyword\">const</span> <span class=\"keyword\">object_t</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *method, bufferlist&amp; inbl, bufferlist&amp; outbl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ::ObjectOperation rd;</span><br><span class=\"line\">    prepare_assert_ops(&amp;rd);</span><br><span class=\"line\">    rd.call(cls, method, inbl);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> operate_read(oid, &amp;rd, &amp;outbl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>//通过lib形式调用，所以不走main函数<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建rbd块  -- librbd/librbd.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> RBD::create(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">int</span> *order)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> r = librbd::create(io_ctx, name, size, order);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用librbd::create --librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> create(librados::IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">int</span> *order)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> create(io_ctx, imgname, size, old_format, features, order, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用create  --librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create</span><span class=\"params\">(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">bool</span> old_format, <span class=\"keyword\">uint64_t</span> features, <span class=\"keyword\">int</span> *order,  <span class=\"keyword\">uint64_t</span> stripe_unit, <span class=\"keyword\">uint64_t</span> stripe_count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  ...   <span class=\"comment\">//ImageOptions opts</span></span><br><span class=\"line\">  r = create(io_ctx, imgname, size, opts, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用create  -- librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> create(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> size, ImageOptions&amp; opts, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;non_primary_global_image_id,</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;primary_mirror_uuid)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  r = create_v1(io_ctx, imgname, bid, size, order);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  r = create_v2(io_ctx, imgname, bid, size, order, features, stripe_unit, stripe_count, journal_order, journal_splay_width, journal_pool,</span><br><span class=\"line\">    non_primary_global_image_id, primary_mirror_uuid);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用create_v2  --librbd/internal.cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create_v2</span><span class=\"params\">(IoCtx&amp; io_ctx, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *imgname, <span class=\"keyword\">uint64_t</span> bid, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">int</span> order,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">uint64_t</span> features, <span class=\"keyword\">uint64_t</span> stripe_unit, <span class=\"keyword\">uint64_t</span> stripe_count, <span class=\"keyword\">uint8_t</span> journal_order,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">uint8_t</span> journal_splay_width, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;journal_pool,<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;non_primary_global_image_id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;primary_mirror_uuid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  id_obj = util::id_obj_name(imgname)   <span class=\"comment\">//rbd_id.&#123;imagname&#125;</span></span><br><span class=\"line\">  r = io_ctx.create(id_obj, <span class=\"literal\">true</span>);      <span class=\"comment\">//创建object; 对象名为rbd_id.&#123;imgname&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//setting image id</span></span><br><span class=\"line\">  r = cls_client::set_id(&amp;io_ctx, id_obj, id);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//adding rbd image to directory</span></span><br><span class=\"line\">  r = cls_client::dir_add_image(&amp;io_ctx, RBD_DIRECTORY, imgname, id);</span><br><span class=\"line\"></span><br><span class=\"line\">  header_osd = util::header_name(id);</span><br><span class=\"line\">  r = cls_client::create_image(&amp;io_ctx, header_oid, size, order, features, oss.str());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//关于feature设定</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//cls_client::create_image()  -- cls/rbd/cls_rbd_client.cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">create_image</span><span class=\"params\">(librados::IoCtx *ioctx, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;oid, <span class=\"keyword\">uint64_t</span> size, <span class=\"keyword\">uint8_t</span> order, <span class=\"keyword\">uint64_t</span> features</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;object_prefix)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ioctx-&gt;exec(oid, <span class=\"string\">\"rbd\"</span>, <span class=\"string\">\"create\"</span>, bl, bl2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//librados::IoCtx::exec()    -- librados/librados.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> librados::IoCtx::exec(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* method, bufferlist&amp; inbl, bufferlist&amp; outbl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">object_t</span> obj(oid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> io_ctx_impl-&gt;exec(obj, cls, method, inbl, outbl);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//io_ctx_impl-&gt;exec()  --librados/IoCtxImpl.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> librados::IoCtxImpl::exec(<span class=\"keyword\">const</span> <span class=\"keyword\">object_t</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *method, bufferlist&amp; inbl, bufferlist&amp; outbl)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ::ObjectOperation rd;</span><br><span class=\"line\">    prepare_assert_ops(&amp;rd);</span><br><span class=\"line\">    rd.call(cls, method, inbl);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> operate_read(oid, &amp;rd, &amp;outbl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"snapshot","date":"2018-04-14T16:00:00.000Z","_content":"### snapshot\n\n快照分全量快照和增量快照\n\n#### 全量快照\n- 镜像分离\n\n#### 增量快照\n\n- copy on write(写时拷贝)\n假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步：\n\n  - 分配一个新的物理块。我们称为第9个物理块\n  - 读取第8个物理块\n  - 新读取的第8个物理块数据写入到第9个物理块\n  - 更新快照卷map,指向第9个物理块\n  - 更新第8个物理块\n\nCOW缺点：\n\n  - 写放大，本来一个写，变成1读3写。\n\nCOW优势：\n\n  - 原始卷物理块连续。没有碎片。\n  - 节省空间\n\n- rediect on first write (写时重定向)\n假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对ROW 而言，会依次做如下几步：\n\n  - 分配一个新的物理块。我们称为第9个物理块\n  - 数据写入到第9个物理块。\n  - 更新原始卷map,指向第9个物理块\n","source":"_posts/snapshot.md","raw":"---\n  title: snapshot\n  date: 2018-04-15\n  categories:\n    - other\n  tags:\n    - snapshot\n---\n### snapshot\n\n快照分全量快照和增量快照\n\n#### 全量快照\n- 镜像分离\n\n#### 增量快照\n\n- copy on write(写时拷贝)\n假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步：\n\n  - 分配一个新的物理块。我们称为第9个物理块\n  - 读取第8个物理块\n  - 新读取的第8个物理块数据写入到第9个物理块\n  - 更新快照卷map,指向第9个物理块\n  - 更新第8个物理块\n\nCOW缺点：\n\n  - 写放大，本来一个写，变成1读3写。\n\nCOW优势：\n\n  - 原始卷物理块连续。没有碎片。\n  - 节省空间\n\n- rediect on first write (写时重定向)\n假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对ROW 而言，会依次做如下几步：\n\n  - 分配一个新的物理块。我们称为第9个物理块\n  - 数据写入到第9个物理块。\n  - 更新原始卷map,指向第9个物理块\n","slug":"snapshot","published":1,"updated":"2018-12-25T11:20:00.978Z","_id":"cjl25n9r9000914ha0av17nol","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"snapshot\"><a href=\"#snapshot\" class=\"headerlink\" title=\"snapshot\"></a>snapshot</h3><p>快照分全量快照和增量快照</p>\n<h4 id=\"全量快照\"><a href=\"#全量快照\" class=\"headerlink\" title=\"全量快照\"></a>全量快照</h4><ul>\n<li>镜像分离</li>\n</ul>\n<h4 id=\"增量快照\"><a href=\"#增量快照\" class=\"headerlink\" title=\"增量快照\"></a>增量快照</h4><ul>\n<li><p>copy on write(写时拷贝)<br>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步：</p>\n<ul>\n<li>分配一个新的物理块。我们称为第9个物理块</li>\n<li>读取第8个物理块</li>\n<li>新读取的第8个物理块数据写入到第9个物理块</li>\n<li>更新快照卷map,指向第9个物理块</li>\n<li>更新第8个物理块</li>\n</ul>\n</li>\n</ul>\n<p>COW缺点：</p>\n<ul>\n<li>写放大，本来一个写，变成1读3写。</li>\n</ul>\n<p>COW优势：</p>\n<ul>\n<li>原始卷物理块连续。没有碎片。</li>\n<li>节省空间</li>\n</ul>\n<ul>\n<li><p>rediect on first write (写时重定向)<br>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对ROW 而言，会依次做如下几步：</p>\n<ul>\n<li>分配一个新的物理块。我们称为第9个物理块</li>\n<li>数据写入到第9个物理块。</li>\n<li>更新原始卷map,指向第9个物理块</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"snapshot\"><a href=\"#snapshot\" class=\"headerlink\" title=\"snapshot\"></a>snapshot</h3><p>快照分全量快照和增量快照</p>\n<h4 id=\"全量快照\"><a href=\"#全量快照\" class=\"headerlink\" title=\"全量快照\"></a>全量快照</h4><ul>\n<li>镜像分离</li>\n</ul>\n<h4 id=\"增量快照\"><a href=\"#增量快照\" class=\"headerlink\" title=\"增量快照\"></a>增量快照</h4><ul>\n<li><p>copy on write(写时拷贝)<br>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步：</p>\n<ul>\n<li>分配一个新的物理块。我们称为第9个物理块</li>\n<li>读取第8个物理块</li>\n<li>新读取的第8个物理块数据写入到第9个物理块</li>\n<li>更新快照卷map,指向第9个物理块</li>\n<li>更新第8个物理块</li>\n</ul>\n</li>\n</ul>\n<p>COW缺点：</p>\n<ul>\n<li>写放大，本来一个写，变成1读3写。</li>\n</ul>\n<p>COW优势：</p>\n<ul>\n<li>原始卷物理块连续。没有碎片。</li>\n<li>节省空间</li>\n</ul>\n<ul>\n<li><p>rediect on first write (写时重定向)<br>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对ROW 而言，会依次做如下几步：</p>\n<ul>\n<li>分配一个新的物理块。我们称为第9个物理块</li>\n<li>数据写入到第9个物理块。</li>\n<li>更新原始卷map,指向第9个物理块</li>\n</ul>\n</li>\n</ul>\n"},{"title":"ssd write amplification","date":"2018-04-14T16:00:00.000Z","_content":"\n### Page 和 Block\n\nssd中有page和block的概念，page的大小为 4k，而block的大小为512k（128个page）\n\n### write amplification\n\n从前一直认为SSD的写放大（Write amplification）是指SSD一次写必须写一个Block，其实不是这样的。SSD一次写的单位是page，但是SSD的Write只能写到空的page上，对于之前写过的page\n必须先进行一次Erase，而Erase的单位是block,所以如果一个page的数据删掉之后，要想再写到这个page上，必须经过以下三步：\n\n- 将同一个block的其他page读出来\n- 整个block erase掉\n- 将整个block数据写入\n\n### 解决版本trim\ntrim是现在公认的解决写放大的比较好的方案。\nTRIM位于操作系统层。操作系统使用TRIM命令来通知SSD某个page的数据不需要了，可以回收了。\n支持TRIM的操作系统和以往的主要区别是删除一个Page的操作不同。在磁盘时期，删除一个page，之后在文件系统的记录信息里将该page的标志位设置为可用，但是并没有将数据删除。\n使用SSD且支持TRIM的操作系统，在删除一个page时，会同时通知SSD这个page的数据不需要了，SSD内部有一个空闲时刻的垃圾收集进程，在空闲时刻SSD会将一些空闲的数据集中到一起，\n然后一起Erase。这样每次写操作，就在已经Erase好了的Page上写入新的数据。\n","source":"_posts/ssd_write_amplification.md","raw":"---\ntitle: ssd write amplification\ndate: 2018-04-15\ncategories:\n    - other\ntags:\n    - ssd \n---\n\n### Page 和 Block\n\nssd中有page和block的概念，page的大小为 4k，而block的大小为512k（128个page）\n\n### write amplification\n\n从前一直认为SSD的写放大（Write amplification）是指SSD一次写必须写一个Block，其实不是这样的。SSD一次写的单位是page，但是SSD的Write只能写到空的page上，对于之前写过的page\n必须先进行一次Erase，而Erase的单位是block,所以如果一个page的数据删掉之后，要想再写到这个page上，必须经过以下三步：\n\n- 将同一个block的其他page读出来\n- 整个block erase掉\n- 将整个block数据写入\n\n### 解决版本trim\ntrim是现在公认的解决写放大的比较好的方案。\nTRIM位于操作系统层。操作系统使用TRIM命令来通知SSD某个page的数据不需要了，可以回收了。\n支持TRIM的操作系统和以往的主要区别是删除一个Page的操作不同。在磁盘时期，删除一个page，之后在文件系统的记录信息里将该page的标志位设置为可用，但是并没有将数据删除。\n使用SSD且支持TRIM的操作系统，在删除一个page时，会同时通知SSD这个page的数据不需要了，SSD内部有一个空闲时刻的垃圾收集进程，在空闲时刻SSD会将一些空闲的数据集中到一起，\n然后一起Erase。这样每次写操作，就在已经Erase好了的Page上写入新的数据。\n","slug":"ssd_write_amplification","published":1,"updated":"2018-12-25T11:22:43.648Z","_id":"cjlnekoha0001jshaapuypctk","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Page-和-Block\"><a href=\"#Page-和-Block\" class=\"headerlink\" title=\"Page 和 Block\"></a>Page 和 Block</h3><p>ssd中有page和block的概念，page的大小为 4k，而block的大小为512k（128个page）</p>\n<h3 id=\"write-amplification\"><a href=\"#write-amplification\" class=\"headerlink\" title=\"write amplification\"></a>write amplification</h3><p>从前一直认为SSD的写放大（Write amplification）是指SSD一次写必须写一个Block，其实不是这样的。SSD一次写的单位是page，但是SSD的Write只能写到空的page上，对于之前写过的page<br>必须先进行一次Erase，而Erase的单位是block,所以如果一个page的数据删掉之后，要想再写到这个page上，必须经过以下三步：</p>\n<ul>\n<li>将同一个block的其他page读出来</li>\n<li>整个block erase掉</li>\n<li>将整个block数据写入</li>\n</ul>\n<h3 id=\"解决版本trim\"><a href=\"#解决版本trim\" class=\"headerlink\" title=\"解决版本trim\"></a>解决版本trim</h3><p>trim是现在公认的解决写放大的比较好的方案。<br>TRIM位于操作系统层。操作系统使用TRIM命令来通知SSD某个page的数据不需要了，可以回收了。<br>支持TRIM的操作系统和以往的主要区别是删除一个Page的操作不同。在磁盘时期，删除一个page，之后在文件系统的记录信息里将该page的标志位设置为可用，但是并没有将数据删除。<br>使用SSD且支持TRIM的操作系统，在删除一个page时，会同时通知SSD这个page的数据不需要了，SSD内部有一个空闲时刻的垃圾收集进程，在空闲时刻SSD会将一些空闲的数据集中到一起，<br>然后一起Erase。这样每次写操作，就在已经Erase好了的Page上写入新的数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Page-和-Block\"><a href=\"#Page-和-Block\" class=\"headerlink\" title=\"Page 和 Block\"></a>Page 和 Block</h3><p>ssd中有page和block的概念，page的大小为 4k，而block的大小为512k（128个page）</p>\n<h3 id=\"write-amplification\"><a href=\"#write-amplification\" class=\"headerlink\" title=\"write amplification\"></a>write amplification</h3><p>从前一直认为SSD的写放大（Write amplification）是指SSD一次写必须写一个Block，其实不是这样的。SSD一次写的单位是page，但是SSD的Write只能写到空的page上，对于之前写过的page<br>必须先进行一次Erase，而Erase的单位是block,所以如果一个page的数据删掉之后，要想再写到这个page上，必须经过以下三步：</p>\n<ul>\n<li>将同一个block的其他page读出来</li>\n<li>整个block erase掉</li>\n<li>将整个block数据写入</li>\n</ul>\n<h3 id=\"解决版本trim\"><a href=\"#解决版本trim\" class=\"headerlink\" title=\"解决版本trim\"></a>解决版本trim</h3><p>trim是现在公认的解决写放大的比较好的方案。<br>TRIM位于操作系统层。操作系统使用TRIM命令来通知SSD某个page的数据不需要了，可以回收了。<br>支持TRIM的操作系统和以往的主要区别是删除一个Page的操作不同。在磁盘时期，删除一个page，之后在文件系统的记录信息里将该page的标志位设置为可用，但是并没有将数据删除。<br>使用SSD且支持TRIM的操作系统，在删除一个page时，会同时通知SSD这个page的数据不需要了，SSD内部有一个空闲时刻的垃圾收集进程，在空闲时刻SSD会将一些空闲的数据集中到一起，<br>然后一起Erase。这样每次写操作，就在已经Erase好了的Page上写入新的数据。</p>\n"},{"title":"ceph-mon","date":"2018-12-09T16:00:00.000Z","_content":"\nmon->preinit()\nmessenger->start()\nmon->init()\n<!-- more -->\n```c++\n// mon/Monitor.cc\nint Monitor::preinit()\n{\n    lock.Lock();\n    dout(1) << \"preinit fsid \" << monmap->fsid << dendl;\n\n    assert(!logger);\n    {\n        PerfCountersBuilder pcb(g_ceph_context, \"mon\", l_mon_first, l_mon_last);\n        logger = pcb.create_perf_counters();\n        cct->get_perfcounters_collection()->add(logger);\n    }\n    assert(!cluster_logger);  \n    {\n    PerfCountersBuilder pcb(g_ceph_context, \"cluster\", l_cluster_first, l_cluster_last);\n    pcb.add_u64(l_cluster_num_mon, \"num_mon\");\n    // ......\n    cluster_logger = pcb.create_perf_counters();\n  }\n  paxos->init_logger();\n\n  // verify cluster_uuid\n  {\n    int r = check_fsid()\n    if (r == -ENOENT)\n        r = write_fsid();\n    if (r<0){\n        lock.Unlock();\n        return r;\n    }\n  }\n\n  //open compatset\n  read_features();\n\n  // have we ever joined a quorum ?\n  has_ever_joined = (store->get(MONITOR_NAME, \"joined\") != 0);\n  dout(10) << \"has_ever_joined = \"<< (int)has_ever_joined << dendl;\n\n  if(!has_ever_joined){\n    // impose initial quorum restructions ?\n    list<string> initial_members;\n    get_str_list(g_conf->mon_initial_members, initial_members);\n\n    if (!initial_members.empty()){\n        dout(1) << \" initial_members \" << initial_members << \", filtering seed monmap\" << dendl;\n        monmap->set_inital_members(g_ceph_context, initial_members, name, messenger->get_myaddr(), &extra_probe_peers);\n        dout(10) << \" monmap is \" << *monmap << dendl;\n        dout(10) << \" extra probe peers \" << extra_probe_peers << dendl;\n    }\n   } else if ( !monmap->contains(name)) {\n        derr << \" not in monmap and have been in a quorum before; \" << \"must have been removed \" << dendl;\n        if (g_conf->mon_force_quorum_join) {\n            dout(0)  << \" we should have died but \"\n                << \" mon_force_quorum_join is set -- allowing boot\" << dendl;\n        }else{\n            derr << \"commit suicide!\" << dendl;\n            return -ENOENT;\n        }\n   }\n\n   {\n        // we have a potentially inconsistent store state in hands. Get rid of \n        // it and start fresh\n        bool clear_store = false;\n        if(store->exists(\"mon_sync\", \"in_sync\")){\n            dout(1) << __func__ << \"clean up potentially inconsistent store state \" << dendl;\n            clear_store = true;\n        } \n\n        if (store->get(\"mon_sync\", \"force_sync\") > 0){\n            dout(1) << __func__ << \" force sync by clearing store state \" << dendl;\n            clear_store = true;\n        }\n        if(clear_store) {\n            set<string> sync_prefixes = get_sync_targets_names();\n            store->clear(sync_prefixes);\n        }\n   }\n\n   sync_last_commited_floor = store->get(\"mon_sync\", \"last_commited_floor\");\n   dout(10)  << \"sync_last_commited_floor \"<< sync_last_commited_floor << dendl;\n\n   init_paxos();  //pasox 初始化\n   health_monitor->init();\n\n   ....\n}\n```\n\n```c++\n// mon/Monitor.cc\nvoid Monitor::init_paxos() {\n    dout(10) << __func__ << dendl;\n    paxos->init(); \n\n    // init services\n    // paxos_service 在Monitor构建时，加入了6个派生类\n    - MDSMonitor\n    - MonmapMonitor\n    - OSDMonitor\n    - PGMonitor\n    - LogMonitor\n    - AuthMonitor\n    for(int i=0; i<PAXOS_NUM; ++i){\n        paxos_service[i]->init(); \n    }\n    refresh_from_paxos(NULL);\n}\n```\n\n- last_pn: 上次当选为leader后生成的PN（proposal number)\n- accepted_pn: 当前节点接受过的PN，可能是别的leader提议的PN \n- last_committed: 本节点记录的最后被commit版本\n- first_committed: 本节点记录的第一被commit版本\n```c++\nvoid Paxos::init(){\n    // load paxos variables from stable storage\n    last_pn = get_store()->get(get_name(), \"last_pn\");\n    accepted_pn = get_store()->get(get_name(), \"accepted_pn\");\n    last_committed = get_store()->get(get_name(), \"last_committed\");\n    first_commited = get_store()->get(get_name(), \"first_committed\");\n\n    dout(10) << __func__ << \" last_pn: \" << last_pn << \" accepted_pn: \" \n        << accepted_pn << \" last_commited: \" << last_commited \n        << \" first_committed: \" << first_committed << dendl;\n    dout(10) << \"init\" << dendl;\n    assert(is_consistent());\n}\n```\n\n//refresh_from_paxos(NULL)\n```c++\nvoid Monitor::refresh_from_paxos(bool * need_bootstrap){\n    // ....\n    for(int i=0; i<PAXOS_NUM; ++i){\n        paxos_service[i]->refresh(need_boostrap);\n    }\n    for(int i=0; i<PAXOS_NUM; ++i){ //主要是处理PGMonitor\n        paxos_service[i]->post_paxos_update();\n    }\n}\n```\n//paxos_service vector中的对象都没有派生refresh(), 都调用基类refresh方法\n```c++\nvoid PaxosService::refresh(bool *need_boostrap){\n    // ...\n    update_from_paxos(need_boostrap);\n}\n\n// update_from_paxos 均被paxos_service vector中的对象进行了派生\n// 这里仅仅列出MonmapMonitor 对象方法\nvoid MonmapMonitor:;update_from_paxos(bool *need_boostrap){\n    version_t  version = get_last_committed();\n    if(version <= mon->monmap->get_epoch())\n        return \n    dout(10) << __func__ << \" version \" << version\n        << \", my v \" << mon->monmap->epoch << dendl;\n    .....\n}\n```\n\n//post_paxos_update() 方法，\n- 只有PGMonitor覆盖写了post_paxos_update\n- 其他5个类均没有使用基类\n```c++\nvoid PGMonitor:;post_paxos_update(){\n    if(mon->osdmon()->osdmap.get_epoch()){\n        map_pg_creates();\n        send_pg_creates();\n    }\n}\n```\n\n```c++\n// mon/Monitor.cc\nint Monitor::init()\n{\n    dout(2) << \"init\" << dendl;\n    lock.Lock()\n\n    //start ticker\n    timer.init()\n    new_tick()\n\n    //i'm ready!\n    messenger->add_dispatcher_tail(this);\n\n    bootstrap();\n\n    // encode command sets\n    const MonCommand *cmds;\n    int cmdsize;\n    get_locally_supported_monitor_commands(&cmds, &cmdsize);\n    MonCommand::encode_array(cmds, cmdsize, supported_commands_bl);\n    get_classic_monitor_commands(&cmds, &cmdsize);\n    MonCommand::encode_array(cmds, cmdsize, classic_commands_bl);\n\n    lock.Unlock();\n    return 0;\n}\n```\n\n// bootstrap() ; 接下去我们需要看peer如何处理OP_PROBE消息\n```c++\nvoid Monitor::bootstrap()\n{\n   // ....\n   state = STATE_PROBING;\n   _reset();\n\n  // singleton monitor?\n  if(monmap->size() == 1 && rank == 0){\n    win_standalone_election();\n    return;\n  }  \n  // ....\n  dout(10) << \"probing other monitors\" <<dendl;\n  for (unsigned i = 0; i < monmap->size(); i++) {\n     if((int)i != rank){\n        messenger->send_message(new MMonProbe(monmap->fsid, MMonProbe::OP_PROBE, name, has_ever_joined), monmap->get_inst(i));\n     }\n  }\n\n  for(set<entity_addr_t>::iterator p = extra_probe_peers.begin(); p != extra_probe_peers.end(); ++p){\n    if (*p != messenger->get_addr()){\n        entity_inst_t i;\n        i.name = entity_name_t::MON(-1);\n        i.addr = *p;\n        messenger->send_message(new MMonProbe(monmap->fsid, MMonProbe::OP_PROBE, name, has_ever_joined), i);\n    }\n  }\n}\n```\n\n//handle_probe() 用来处理OP_PROBE消息\n```c++\nvoid Monitor::handle_probe(MonOpRequestRef op){\n    MMonProbe *m = static_cast<MMonProbe*>(op->get_req());\n    dout(10) << \"handle_probe \"  << *m << dendl;\n\n    if(m->fsid != monmap->fsid){\n        dout(0) << \"handle_probe ignoring fsid \"  << m->fsid << \" != \" << monmap->fsid << dendl;\n        return;\n    }\n\n    switch (m->op){\n    case MMonProbe::OP_PROBE:\n        handle_probe_probe(op);     // <-- 处理OP_PROBE请求\n        break;\n\n    case MMonProbe::OP_REPLY:\n        handle_probe_reply(op);\n        break;\n\n    case MMonProbe::OP_MISSING_FEATURES:\n        derr << __func__ << \" missing features, have \" << CEPH_FEATURES_ALL \n        << \", required \" << m->required_features\n        << \", missing \" << (m->required_features & ~CEPH_FEATURES_ALL)\n        << dendl; \n        break;\n    }\n}\n```\n\n//handle_probe_probe 处理流程\n```c++\nvoid Monitor::handle_probe_probe(MonOpRequestRef op){\n    MMonProbe *m = static_cast<MMonProbe*>(op->get_req());\n\n    dout(10) << \"handle_probe_probe \" << m->get_source_inst() << *m\n        << \" features \" << m->get_connection()->get_features() << dendl;\n\n    uint_64 missing = required_features & ~m->get_connection()->get_features();\n    // ......\n    if (!is_probing() && !is_synchronizing()) {\n        if(paxos->get_version() + 1 < m->paxos_first_version){\n            dout(1) << \" peer \" << m->get_source_addr() << \" has \n            first_committed \" << \" ahead of us, re-bootstrapping \" << dendl;\n            bootstrap();\n            goto out;\n        }\n    }\n    MMonProbe *r;\n    r = new MMonProbe(monmap->fsid, MMonProbe::OP_REPLY, name, has_ever_joined);\n    r->name = name;\n    r->quorum = quorum;\n    monmap->encode(r->monmap_bl, m->get_connection()->get_features());\n    r->paxos_first_version = paxos->get_first_committed();\n    r->paxos_last_version = paxos->get_version();\n    m->get_connection()->send_message(r);\n\n    // did we discover a peer here?\n    if(!monmap->contains(m->get_source_addr())){\n        dout(1) << \" adding peer \"<< m->get_source_addr() \n        << \" to list of hints \"<< dendl;\n        extra_probe_peers.insert(m->get_source_addr());\n    }\n\n   out:\n        return;\n}\n```\n\n//handle_probe_reply()\nvoid Monitor::handle_probe_reply(MonOpRequestRef op){\n    MMonProbe *m = static_cast<MMonProbe*>(op->get_req());\n    dout(10) << \"handle_probe_reply \" << m->get_source_inst() << *m <<dendl;\n    dout(10) << \" monmap is \" << *monmap << dendl; \n\n    //discover name and addrs during probing or electing states.\n    if(!is_probing() && !is_electing()){\n        return;\n    }\n    //newer map, or they've joined a quorum and we haven't?\n}\n\n","source":"_posts/ceph_mon.md","raw":"---\ntitle: ceph-mon\ndate: 2018-12-10\ncategories:\n    - ceph\ntags:\n    - ceph\n---\n\nmon->preinit()\nmessenger->start()\nmon->init()\n<!-- more -->\n```c++\n// mon/Monitor.cc\nint Monitor::preinit()\n{\n    lock.Lock();\n    dout(1) << \"preinit fsid \" << monmap->fsid << dendl;\n\n    assert(!logger);\n    {\n        PerfCountersBuilder pcb(g_ceph_context, \"mon\", l_mon_first, l_mon_last);\n        logger = pcb.create_perf_counters();\n        cct->get_perfcounters_collection()->add(logger);\n    }\n    assert(!cluster_logger);  \n    {\n    PerfCountersBuilder pcb(g_ceph_context, \"cluster\", l_cluster_first, l_cluster_last);\n    pcb.add_u64(l_cluster_num_mon, \"num_mon\");\n    // ......\n    cluster_logger = pcb.create_perf_counters();\n  }\n  paxos->init_logger();\n\n  // verify cluster_uuid\n  {\n    int r = check_fsid()\n    if (r == -ENOENT)\n        r = write_fsid();\n    if (r<0){\n        lock.Unlock();\n        return r;\n    }\n  }\n\n  //open compatset\n  read_features();\n\n  // have we ever joined a quorum ?\n  has_ever_joined = (store->get(MONITOR_NAME, \"joined\") != 0);\n  dout(10) << \"has_ever_joined = \"<< (int)has_ever_joined << dendl;\n\n  if(!has_ever_joined){\n    // impose initial quorum restructions ?\n    list<string> initial_members;\n    get_str_list(g_conf->mon_initial_members, initial_members);\n\n    if (!initial_members.empty()){\n        dout(1) << \" initial_members \" << initial_members << \", filtering seed monmap\" << dendl;\n        monmap->set_inital_members(g_ceph_context, initial_members, name, messenger->get_myaddr(), &extra_probe_peers);\n        dout(10) << \" monmap is \" << *monmap << dendl;\n        dout(10) << \" extra probe peers \" << extra_probe_peers << dendl;\n    }\n   } else if ( !monmap->contains(name)) {\n        derr << \" not in monmap and have been in a quorum before; \" << \"must have been removed \" << dendl;\n        if (g_conf->mon_force_quorum_join) {\n            dout(0)  << \" we should have died but \"\n                << \" mon_force_quorum_join is set -- allowing boot\" << dendl;\n        }else{\n            derr << \"commit suicide!\" << dendl;\n            return -ENOENT;\n        }\n   }\n\n   {\n        // we have a potentially inconsistent store state in hands. Get rid of \n        // it and start fresh\n        bool clear_store = false;\n        if(store->exists(\"mon_sync\", \"in_sync\")){\n            dout(1) << __func__ << \"clean up potentially inconsistent store state \" << dendl;\n            clear_store = true;\n        } \n\n        if (store->get(\"mon_sync\", \"force_sync\") > 0){\n            dout(1) << __func__ << \" force sync by clearing store state \" << dendl;\n            clear_store = true;\n        }\n        if(clear_store) {\n            set<string> sync_prefixes = get_sync_targets_names();\n            store->clear(sync_prefixes);\n        }\n   }\n\n   sync_last_commited_floor = store->get(\"mon_sync\", \"last_commited_floor\");\n   dout(10)  << \"sync_last_commited_floor \"<< sync_last_commited_floor << dendl;\n\n   init_paxos();  //pasox 初始化\n   health_monitor->init();\n\n   ....\n}\n```\n\n```c++\n// mon/Monitor.cc\nvoid Monitor::init_paxos() {\n    dout(10) << __func__ << dendl;\n    paxos->init(); \n\n    // init services\n    // paxos_service 在Monitor构建时，加入了6个派生类\n    - MDSMonitor\n    - MonmapMonitor\n    - OSDMonitor\n    - PGMonitor\n    - LogMonitor\n    - AuthMonitor\n    for(int i=0; i<PAXOS_NUM; ++i){\n        paxos_service[i]->init(); \n    }\n    refresh_from_paxos(NULL);\n}\n```\n\n- last_pn: 上次当选为leader后生成的PN（proposal number)\n- accepted_pn: 当前节点接受过的PN，可能是别的leader提议的PN \n- last_committed: 本节点记录的最后被commit版本\n- first_committed: 本节点记录的第一被commit版本\n```c++\nvoid Paxos::init(){\n    // load paxos variables from stable storage\n    last_pn = get_store()->get(get_name(), \"last_pn\");\n    accepted_pn = get_store()->get(get_name(), \"accepted_pn\");\n    last_committed = get_store()->get(get_name(), \"last_committed\");\n    first_commited = get_store()->get(get_name(), \"first_committed\");\n\n    dout(10) << __func__ << \" last_pn: \" << last_pn << \" accepted_pn: \" \n        << accepted_pn << \" last_commited: \" << last_commited \n        << \" first_committed: \" << first_committed << dendl;\n    dout(10) << \"init\" << dendl;\n    assert(is_consistent());\n}\n```\n\n//refresh_from_paxos(NULL)\n```c++\nvoid Monitor::refresh_from_paxos(bool * need_bootstrap){\n    // ....\n    for(int i=0; i<PAXOS_NUM; ++i){\n        paxos_service[i]->refresh(need_boostrap);\n    }\n    for(int i=0; i<PAXOS_NUM; ++i){ //主要是处理PGMonitor\n        paxos_service[i]->post_paxos_update();\n    }\n}\n```\n//paxos_service vector中的对象都没有派生refresh(), 都调用基类refresh方法\n```c++\nvoid PaxosService::refresh(bool *need_boostrap){\n    // ...\n    update_from_paxos(need_boostrap);\n}\n\n// update_from_paxos 均被paxos_service vector中的对象进行了派生\n// 这里仅仅列出MonmapMonitor 对象方法\nvoid MonmapMonitor:;update_from_paxos(bool *need_boostrap){\n    version_t  version = get_last_committed();\n    if(version <= mon->monmap->get_epoch())\n        return \n    dout(10) << __func__ << \" version \" << version\n        << \", my v \" << mon->monmap->epoch << dendl;\n    .....\n}\n```\n\n//post_paxos_update() 方法，\n- 只有PGMonitor覆盖写了post_paxos_update\n- 其他5个类均没有使用基类\n```c++\nvoid PGMonitor:;post_paxos_update(){\n    if(mon->osdmon()->osdmap.get_epoch()){\n        map_pg_creates();\n        send_pg_creates();\n    }\n}\n```\n\n```c++\n// mon/Monitor.cc\nint Monitor::init()\n{\n    dout(2) << \"init\" << dendl;\n    lock.Lock()\n\n    //start ticker\n    timer.init()\n    new_tick()\n\n    //i'm ready!\n    messenger->add_dispatcher_tail(this);\n\n    bootstrap();\n\n    // encode command sets\n    const MonCommand *cmds;\n    int cmdsize;\n    get_locally_supported_monitor_commands(&cmds, &cmdsize);\n    MonCommand::encode_array(cmds, cmdsize, supported_commands_bl);\n    get_classic_monitor_commands(&cmds, &cmdsize);\n    MonCommand::encode_array(cmds, cmdsize, classic_commands_bl);\n\n    lock.Unlock();\n    return 0;\n}\n```\n\n// bootstrap() ; 接下去我们需要看peer如何处理OP_PROBE消息\n```c++\nvoid Monitor::bootstrap()\n{\n   // ....\n   state = STATE_PROBING;\n   _reset();\n\n  // singleton monitor?\n  if(monmap->size() == 1 && rank == 0){\n    win_standalone_election();\n    return;\n  }  \n  // ....\n  dout(10) << \"probing other monitors\" <<dendl;\n  for (unsigned i = 0; i < monmap->size(); i++) {\n     if((int)i != rank){\n        messenger->send_message(new MMonProbe(monmap->fsid, MMonProbe::OP_PROBE, name, has_ever_joined), monmap->get_inst(i));\n     }\n  }\n\n  for(set<entity_addr_t>::iterator p = extra_probe_peers.begin(); p != extra_probe_peers.end(); ++p){\n    if (*p != messenger->get_addr()){\n        entity_inst_t i;\n        i.name = entity_name_t::MON(-1);\n        i.addr = *p;\n        messenger->send_message(new MMonProbe(monmap->fsid, MMonProbe::OP_PROBE, name, has_ever_joined), i);\n    }\n  }\n}\n```\n\n//handle_probe() 用来处理OP_PROBE消息\n```c++\nvoid Monitor::handle_probe(MonOpRequestRef op){\n    MMonProbe *m = static_cast<MMonProbe*>(op->get_req());\n    dout(10) << \"handle_probe \"  << *m << dendl;\n\n    if(m->fsid != monmap->fsid){\n        dout(0) << \"handle_probe ignoring fsid \"  << m->fsid << \" != \" << monmap->fsid << dendl;\n        return;\n    }\n\n    switch (m->op){\n    case MMonProbe::OP_PROBE:\n        handle_probe_probe(op);     // <-- 处理OP_PROBE请求\n        break;\n\n    case MMonProbe::OP_REPLY:\n        handle_probe_reply(op);\n        break;\n\n    case MMonProbe::OP_MISSING_FEATURES:\n        derr << __func__ << \" missing features, have \" << CEPH_FEATURES_ALL \n        << \", required \" << m->required_features\n        << \", missing \" << (m->required_features & ~CEPH_FEATURES_ALL)\n        << dendl; \n        break;\n    }\n}\n```\n\n//handle_probe_probe 处理流程\n```c++\nvoid Monitor::handle_probe_probe(MonOpRequestRef op){\n    MMonProbe *m = static_cast<MMonProbe*>(op->get_req());\n\n    dout(10) << \"handle_probe_probe \" << m->get_source_inst() << *m\n        << \" features \" << m->get_connection()->get_features() << dendl;\n\n    uint_64 missing = required_features & ~m->get_connection()->get_features();\n    // ......\n    if (!is_probing() && !is_synchronizing()) {\n        if(paxos->get_version() + 1 < m->paxos_first_version){\n            dout(1) << \" peer \" << m->get_source_addr() << \" has \n            first_committed \" << \" ahead of us, re-bootstrapping \" << dendl;\n            bootstrap();\n            goto out;\n        }\n    }\n    MMonProbe *r;\n    r = new MMonProbe(monmap->fsid, MMonProbe::OP_REPLY, name, has_ever_joined);\n    r->name = name;\n    r->quorum = quorum;\n    monmap->encode(r->monmap_bl, m->get_connection()->get_features());\n    r->paxos_first_version = paxos->get_first_committed();\n    r->paxos_last_version = paxos->get_version();\n    m->get_connection()->send_message(r);\n\n    // did we discover a peer here?\n    if(!monmap->contains(m->get_source_addr())){\n        dout(1) << \" adding peer \"<< m->get_source_addr() \n        << \" to list of hints \"<< dendl;\n        extra_probe_peers.insert(m->get_source_addr());\n    }\n\n   out:\n        return;\n}\n```\n\n//handle_probe_reply()\nvoid Monitor::handle_probe_reply(MonOpRequestRef op){\n    MMonProbe *m = static_cast<MMonProbe*>(op->get_req());\n    dout(10) << \"handle_probe_reply \" << m->get_source_inst() << *m <<dendl;\n    dout(10) << \" monmap is \" << *monmap << dendl; \n\n    //discover name and addrs during probing or electing states.\n    if(!is_probing() && !is_electing()){\n        return;\n    }\n    //newer map, or they've joined a quorum and we haven't?\n}\n\n","slug":"ceph_mon","published":1,"updated":"2018-12-25T11:13:12.310Z","_id":"cjq3l8d4e00005sha3zdmzvsc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>mon-&gt;preinit()<br>messenger-&gt;start()<br>mon-&gt;init()<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mon/Monitor.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Monitor::preinit()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    lock.Lock();</span><br><span class=\"line\">    dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\"preinit fsid \"</span> &lt;&lt; monmap-&gt;fsid &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(!logger);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">PerfCountersBuilder <span class=\"title\">pcb</span><span class=\"params\">(g_ceph_context, <span class=\"string\">\"mon\"</span>, l_mon_first, l_mon_last)</span></span>;</span><br><span class=\"line\">        logger = pcb.create_perf_counters();</span><br><span class=\"line\">        cct-&gt;get_perfcounters_collection()-&gt;add(logger);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(!cluster_logger);  </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"function\">PerfCountersBuilder <span class=\"title\">pcb</span><span class=\"params\">(g_ceph_context, <span class=\"string\">\"cluster\"</span>, l_cluster_first, l_cluster_last)</span></span>;</span><br><span class=\"line\">    pcb.add_u64(l_cluster_num_mon, <span class=\"string\">\"num_mon\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    cluster_logger = pcb.create_perf_counters();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  paxos-&gt;init_logger();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// verify cluster_uuid</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = check_fsid()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == -ENOENT)</span><br><span class=\"line\">        r = write_fsid();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        lock.Unlock();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//open compatset</span></span><br><span class=\"line\">  read_features();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// have we ever joined a quorum ?</span></span><br><span class=\"line\">  has_ever_joined = (store-&gt;get(MONITOR_NAME, <span class=\"string\">\"joined\"</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">  dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"has_ever_joined = \"</span>&lt;&lt; (<span class=\"keyword\">int</span>)has_ever_joined &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!has_ever_joined)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// impose initial quorum restructions ?</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; initial_members;</span><br><span class=\"line\">    get_str_list(g_conf-&gt;mon_initial_members, initial_members);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!initial_members.empty())&#123;</span><br><span class=\"line\">        dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\" initial_members \"</span> &lt;&lt; initial_members &lt;&lt; <span class=\"string\">\", filtering seed monmap\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">        monmap-&gt;set_inital_members(g_ceph_context, initial_members, name, messenger-&gt;get_myaddr(), &amp;extra_probe_peers);</span><br><span class=\"line\">        dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\" monmap is \"</span> &lt;&lt; *monmap &lt;&lt; dendl;</span><br><span class=\"line\">        dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\" extra probe peers \"</span> &lt;&lt; extra_probe_peers &lt;&lt; dendl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( !monmap-&gt;contains(name)) &#123;</span><br><span class=\"line\">        derr &lt;&lt; <span class=\"string\">\" not in monmap and have been in a quorum before; \"</span> &lt;&lt; <span class=\"string\">\"must have been removed \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g_conf-&gt;mon_force_quorum_join) &#123;</span><br><span class=\"line\">            dout(<span class=\"number\">0</span>)  &lt;&lt; <span class=\"string\">\" we should have died but \"</span></span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">\" mon_force_quorum_join is set -- allowing boot\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            derr &lt;&lt; <span class=\"string\">\"commit suicide!\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -ENOENT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"comment\">// we have a potentially inconsistent store state in hands. Get rid of </span></span><br><span class=\"line\">        <span class=\"comment\">// it and start fresh</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> clear_store = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(store-&gt;exists(<span class=\"string\">\"mon_sync\"</span>, <span class=\"string\">\"in_sync\"</span>))&#123;</span><br><span class=\"line\">            dout(<span class=\"number\">1</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\"clean up potentially inconsistent store state \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            clear_store = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (store-&gt;get(<span class=\"string\">\"mon_sync\"</span>, <span class=\"string\">\"force_sync\"</span>) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            dout(<span class=\"number\">1</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" force sync by clearing store state \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            clear_store = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(clear_store) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; sync_prefixes = get_sync_targets_names();</span><br><span class=\"line\">            store-&gt;clear(sync_prefixes);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   sync_last_commited_floor = store-&gt;get(<span class=\"string\">\"mon_sync\"</span>, <span class=\"string\">\"last_commited_floor\"</span>);</span><br><span class=\"line\">   dout(<span class=\"number\">10</span>)  &lt;&lt; <span class=\"string\">\"sync_last_commited_floor \"</span>&lt;&lt; sync_last_commited_floor &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">   init_paxos();  <span class=\"comment\">//pasox 初始化</span></span><br><span class=\"line\">   health_monitor-&gt;init();</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mon/Monitor.cc</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Monitor::init_paxos() &#123;</span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; __func__ &lt;&lt; dendl;</span><br><span class=\"line\">    paxos-&gt;init(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// init services</span></span><br><span class=\"line\">    <span class=\"comment\">// paxos_service 在Monitor构建时，加入了6个派生类</span></span><br><span class=\"line\">    - MDSMonitor</span><br><span class=\"line\">    - MonmapMonitor</span><br><span class=\"line\">    - OSDMonitor</span><br><span class=\"line\">    - PGMonitor</span><br><span class=\"line\">    - LogMonitor</span><br><span class=\"line\">    - AuthMonitor</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;PAXOS_NUM; ++i)&#123;</span><br><span class=\"line\">        paxos_service[i]-&gt;init(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refresh_from_paxos(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>last_pn: 上次当选为leader后生成的PN（proposal number)</li>\n<li>accepted_pn: 当前节点接受过的PN，可能是别的leader提议的PN </li>\n<li>last_committed: 本节点记录的最后被commit版本</li>\n<li>first_committed: 本节点记录的第一被commit版本<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Paxos::init()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// load paxos variables from stable storage</span></span><br><span class=\"line\">    last_pn = get_store()-&gt;get(get_name(), <span class=\"string\">\"last_pn\"</span>);</span><br><span class=\"line\">    accepted_pn = get_store()-&gt;get(get_name(), <span class=\"string\">\"accepted_pn\"</span>);</span><br><span class=\"line\">    last_committed = get_store()-&gt;get(get_name(), <span class=\"string\">\"last_committed\"</span>);</span><br><span class=\"line\">    first_commited = get_store()-&gt;get(get_name(), <span class=\"string\">\"first_committed\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" last_pn: \"</span> &lt;&lt; last_pn &lt;&lt; <span class=\"string\">\" accepted_pn: \"</span> </span><br><span class=\"line\">        &lt;&lt; accepted_pn &lt;&lt; <span class=\"string\">\" last_commited: \"</span> &lt;&lt; last_commited </span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\" first_committed: \"</span> &lt;&lt; first_committed &lt;&lt; dendl;</span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"init\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">    assert(is_consistent());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//refresh_from_paxos(NULL)<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::refresh_from_paxos(<span class=\"keyword\">bool</span> * need_bootstrap)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;PAXOS_NUM; ++i)&#123;</span><br><span class=\"line\">        paxos_service[i]-&gt;refresh(need_boostrap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;PAXOS_NUM; ++i)&#123; <span class=\"comment\">//主要是处理PGMonitor</span></span><br><span class=\"line\">        paxos_service[i]-&gt;post_paxos_update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//paxos_service vector中的对象都没有派生refresh(), 都调用基类refresh方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> PaxosService::refresh(<span class=\"keyword\">bool</span> *need_boostrap)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    update_from_paxos(need_boostrap);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// update_from_paxos 均被paxos_service vector中的对象进行了派生</span></span><br><span class=\"line\"><span class=\"comment\">// 这里仅仅列出MonmapMonitor 对象方法</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> MonmapMonitor:;update_from_paxos(<span class=\"keyword\">bool</span> *need_boostrap)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">version_t</span>  version = get_last_committed();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(version &lt;= mon-&gt;monmap-&gt;get_epoch())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" version \"</span> &lt;&lt; version</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\", my v \"</span> &lt;&lt; mon-&gt;monmap-&gt;epoch &lt;&lt; dendl;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//post_paxos_update() 方法，</p>\n<ul>\n<li>只有PGMonitor覆盖写了post_paxos_update</li>\n<li>其他5个类均没有使用基类<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> PGMonitor:;post_paxos_update()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mon-&gt;osdmon()-&gt;osdmap.get_epoch())&#123;</span><br><span class=\"line\">        map_pg_creates();</span><br><span class=\"line\">        send_pg_creates();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mon/Monitor.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Monitor::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dout(<span class=\"number\">2</span>) &lt;&lt; <span class=\"string\">\"init\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">    lock.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//start ticker</span></span><br><span class=\"line\">    timer.init()</span><br><span class=\"line\">    new_tick()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//i'm ready!</span></span><br><span class=\"line\">    messenger-&gt;add_dispatcher_tail(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// encode command sets</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> MonCommand *cmds;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cmdsize;</span><br><span class=\"line\">    get_locally_supported_monitor_commands(&amp;cmds, &amp;cmdsize);</span><br><span class=\"line\">    MonCommand::encode_array(cmds, cmdsize, supported_commands_bl);</span><br><span class=\"line\">    get_classic_monitor_commands(&amp;cmds, &amp;cmdsize);</span><br><span class=\"line\">    MonCommand::encode_array(cmds, cmdsize, classic_commands_bl);</span><br><span class=\"line\"></span><br><span class=\"line\">    lock.Unlock();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// bootstrap() ; 接下去我们需要看peer如何处理OP_PROBE消息<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::bootstrap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ....</span></span><br><span class=\"line\">   state = STATE_PROBING;</span><br><span class=\"line\">   _reset();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// singleton monitor?</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(monmap-&gt;size() == <span class=\"number\">1</span> &amp;&amp; rank == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    win_standalone_election();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">  dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"probing other monitors\"</span> &lt;&lt;dendl;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; monmap-&gt;size(); i++) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>((<span class=\"keyword\">int</span>)i != rank)&#123;</span><br><span class=\"line\">        messenger-&gt;send_message(<span class=\"keyword\">new</span> MMonProbe(monmap-&gt;fsid, MMonProbe::OP_PROBE, name, has_ever_joined), monmap-&gt;get_inst(i));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">entity_addr_t</span>&gt;::iterator p = extra_probe_peers.begin(); p != extra_probe_peers.end(); ++p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*p != messenger-&gt;get_addr())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">entity_inst_t</span> i;</span><br><span class=\"line\">        i.name = <span class=\"keyword\">entity_name_t</span>::MON(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        i.addr = *p;</span><br><span class=\"line\">        messenger-&gt;send_message(<span class=\"keyword\">new</span> MMonProbe(monmap-&gt;fsid, MMonProbe::OP_PROBE, name, has_ever_joined), i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//handle_probe() 用来处理OP_PROBE消息<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::handle_probe(MonOpRequestRef op)&#123;</span><br><span class=\"line\">    MMonProbe *m = <span class=\"keyword\">static_cast</span>&lt;MMonProbe*&gt;(op-&gt;get_req());</span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"handle_probe \"</span>  &lt;&lt; *m &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m-&gt;fsid != monmap-&gt;fsid)&#123;</span><br><span class=\"line\">        dout(<span class=\"number\">0</span>) &lt;&lt; <span class=\"string\">\"handle_probe ignoring fsid \"</span>  &lt;&lt; m-&gt;fsid &lt;&lt; <span class=\"string\">\" != \"</span> &lt;&lt; monmap-&gt;fsid &lt;&lt; dendl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (m-&gt;op)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MMonProbe::OP_PROBE:</span><br><span class=\"line\">        handle_probe_probe(op);     <span class=\"comment\">// &lt;-- 处理OP_PROBE请求</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MMonProbe::OP_REPLY:</span><br><span class=\"line\">        handle_probe_reply(op);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MMonProbe::OP_MISSING_FEATURES:</span><br><span class=\"line\">        derr &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" missing features, have \"</span> &lt;&lt; CEPH_FEATURES_ALL </span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\", required \"</span> &lt;&lt; m-&gt;required_features</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\", missing \"</span> &lt;&lt; (m-&gt;required_features &amp; ~CEPH_FEATURES_ALL)</span><br><span class=\"line\">        &lt;&lt; dendl; </span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//handle_probe_probe 处理流程<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::handle_probe_probe(MonOpRequestRef op)&#123;</span><br><span class=\"line\">    MMonProbe *m = <span class=\"keyword\">static_cast</span>&lt;MMonProbe*&gt;(op-&gt;get_req());</span><br><span class=\"line\"></span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"handle_probe_probe \"</span> &lt;&lt; m-&gt;get_source_inst() &lt;&lt; *m</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\" features \"</span> &lt;&lt; m-&gt;get_connection()-&gt;get_features() &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint_64 missing = required_features &amp; ~m-&gt;get_connection()-&gt;get_features();</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_probing() &amp;&amp; !is_synchronizing()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(paxos-&gt;get_version() + <span class=\"number\">1</span> &lt; m-&gt;paxos_first_version)&#123;</span><br><span class=\"line\">            dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\" peer \"</span> &lt;&lt; m-&gt;get_source_addr() &lt;&lt; <span class=\"string\">\" has </span></span><br><span class=\"line\"><span class=\"string\">            first_committed \"</span> &lt;&lt; <span class=\"string\">\" ahead of us, re-bootstrapping \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            bootstrap();</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMonProbe *r;</span><br><span class=\"line\">    r = <span class=\"keyword\">new</span> MMonProbe(monmap-&gt;fsid, MMonProbe::OP_REPLY, name, has_ever_joined);</span><br><span class=\"line\">    r-&gt;name = name;</span><br><span class=\"line\">    r-&gt;quorum = quorum;</span><br><span class=\"line\">    monmap-&gt;encode(r-&gt;monmap_bl, m-&gt;get_connection()-&gt;get_features());</span><br><span class=\"line\">    r-&gt;paxos_first_version = paxos-&gt;get_first_committed();</span><br><span class=\"line\">    r-&gt;paxos_last_version = paxos-&gt;get_version();</span><br><span class=\"line\">    m-&gt;get_connection()-&gt;send_message(r);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// did we discover a peer here?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!monmap-&gt;contains(m-&gt;get_source_addr()))&#123;</span><br><span class=\"line\">        dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\" adding peer \"</span>&lt;&lt; m-&gt;get_source_addr() </span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\" to list of hints \"</span>&lt;&lt; dendl;</span><br><span class=\"line\">        extra_probe_peers.insert(m-&gt;get_source_addr());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   out:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//handle_probe_reply()<br>void Monitor::handle_probe_reply(MonOpRequestRef op){<br>    MMonProbe <em>m = static_cast&lt;MMonProbe</em>&gt;(op-&gt;get_req());<br>    dout(10) &lt;&lt; “handle_probe_reply “ &lt;&lt; m-&gt;get_source_inst() &lt;&lt; <em>m &lt;&lt;dendl;<br>    dout(10) &lt;&lt; “ monmap is “ &lt;&lt; </em>monmap &lt;&lt; dendl; </p>\n<pre><code>//discover name and addrs during probing or electing states.\nif(!is_probing() &amp;&amp; !is_electing()){\n    return;\n}\n//newer map, or they&apos;ve joined a quorum and we haven&apos;t?\n</code></pre><p>}</p>\n","site":{"data":{}},"excerpt":"<p>mon-&gt;preinit()<br>messenger-&gt;start()<br>mon-&gt;init()<br>","more":"<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mon/Monitor.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Monitor::preinit()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    lock.Lock();</span><br><span class=\"line\">    dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\"preinit fsid \"</span> &lt;&lt; monmap-&gt;fsid &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(!logger);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">PerfCountersBuilder <span class=\"title\">pcb</span><span class=\"params\">(g_ceph_context, <span class=\"string\">\"mon\"</span>, l_mon_first, l_mon_last)</span></span>;</span><br><span class=\"line\">        logger = pcb.create_perf_counters();</span><br><span class=\"line\">        cct-&gt;get_perfcounters_collection()-&gt;add(logger);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(!cluster_logger);  </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"function\">PerfCountersBuilder <span class=\"title\">pcb</span><span class=\"params\">(g_ceph_context, <span class=\"string\">\"cluster\"</span>, l_cluster_first, l_cluster_last)</span></span>;</span><br><span class=\"line\">    pcb.add_u64(l_cluster_num_mon, <span class=\"string\">\"num_mon\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    cluster_logger = pcb.create_perf_counters();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  paxos-&gt;init_logger();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// verify cluster_uuid</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = check_fsid()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == -ENOENT)</span><br><span class=\"line\">        r = write_fsid();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        lock.Unlock();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//open compatset</span></span><br><span class=\"line\">  read_features();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// have we ever joined a quorum ?</span></span><br><span class=\"line\">  has_ever_joined = (store-&gt;get(MONITOR_NAME, <span class=\"string\">\"joined\"</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">  dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"has_ever_joined = \"</span>&lt;&lt; (<span class=\"keyword\">int</span>)has_ever_joined &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!has_ever_joined)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// impose initial quorum restructions ?</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; initial_members;</span><br><span class=\"line\">    get_str_list(g_conf-&gt;mon_initial_members, initial_members);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!initial_members.empty())&#123;</span><br><span class=\"line\">        dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\" initial_members \"</span> &lt;&lt; initial_members &lt;&lt; <span class=\"string\">\", filtering seed monmap\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">        monmap-&gt;set_inital_members(g_ceph_context, initial_members, name, messenger-&gt;get_myaddr(), &amp;extra_probe_peers);</span><br><span class=\"line\">        dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\" monmap is \"</span> &lt;&lt; *monmap &lt;&lt; dendl;</span><br><span class=\"line\">        dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\" extra probe peers \"</span> &lt;&lt; extra_probe_peers &lt;&lt; dendl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( !monmap-&gt;contains(name)) &#123;</span><br><span class=\"line\">        derr &lt;&lt; <span class=\"string\">\" not in monmap and have been in a quorum before; \"</span> &lt;&lt; <span class=\"string\">\"must have been removed \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g_conf-&gt;mon_force_quorum_join) &#123;</span><br><span class=\"line\">            dout(<span class=\"number\">0</span>)  &lt;&lt; <span class=\"string\">\" we should have died but \"</span></span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">\" mon_force_quorum_join is set -- allowing boot\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            derr &lt;&lt; <span class=\"string\">\"commit suicide!\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -ENOENT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"comment\">// we have a potentially inconsistent store state in hands. Get rid of </span></span><br><span class=\"line\">        <span class=\"comment\">// it and start fresh</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> clear_store = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(store-&gt;exists(<span class=\"string\">\"mon_sync\"</span>, <span class=\"string\">\"in_sync\"</span>))&#123;</span><br><span class=\"line\">            dout(<span class=\"number\">1</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\"clean up potentially inconsistent store state \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            clear_store = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (store-&gt;get(<span class=\"string\">\"mon_sync\"</span>, <span class=\"string\">\"force_sync\"</span>) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            dout(<span class=\"number\">1</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" force sync by clearing store state \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            clear_store = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(clear_store) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; sync_prefixes = get_sync_targets_names();</span><br><span class=\"line\">            store-&gt;clear(sync_prefixes);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   sync_last_commited_floor = store-&gt;get(<span class=\"string\">\"mon_sync\"</span>, <span class=\"string\">\"last_commited_floor\"</span>);</span><br><span class=\"line\">   dout(<span class=\"number\">10</span>)  &lt;&lt; <span class=\"string\">\"sync_last_commited_floor \"</span>&lt;&lt; sync_last_commited_floor &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">   init_paxos();  <span class=\"comment\">//pasox 初始化</span></span><br><span class=\"line\">   health_monitor-&gt;init();</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mon/Monitor.cc</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Monitor::init_paxos() &#123;</span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; __func__ &lt;&lt; dendl;</span><br><span class=\"line\">    paxos-&gt;init(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// init services</span></span><br><span class=\"line\">    <span class=\"comment\">// paxos_service 在Monitor构建时，加入了6个派生类</span></span><br><span class=\"line\">    - MDSMonitor</span><br><span class=\"line\">    - MonmapMonitor</span><br><span class=\"line\">    - OSDMonitor</span><br><span class=\"line\">    - PGMonitor</span><br><span class=\"line\">    - LogMonitor</span><br><span class=\"line\">    - AuthMonitor</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;PAXOS_NUM; ++i)&#123;</span><br><span class=\"line\">        paxos_service[i]-&gt;init(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refresh_from_paxos(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>last_pn: 上次当选为leader后生成的PN（proposal number)</li>\n<li>accepted_pn: 当前节点接受过的PN，可能是别的leader提议的PN </li>\n<li>last_committed: 本节点记录的最后被commit版本</li>\n<li>first_committed: 本节点记录的第一被commit版本<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Paxos::init()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// load paxos variables from stable storage</span></span><br><span class=\"line\">    last_pn = get_store()-&gt;get(get_name(), <span class=\"string\">\"last_pn\"</span>);</span><br><span class=\"line\">    accepted_pn = get_store()-&gt;get(get_name(), <span class=\"string\">\"accepted_pn\"</span>);</span><br><span class=\"line\">    last_committed = get_store()-&gt;get(get_name(), <span class=\"string\">\"last_committed\"</span>);</span><br><span class=\"line\">    first_commited = get_store()-&gt;get(get_name(), <span class=\"string\">\"first_committed\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" last_pn: \"</span> &lt;&lt; last_pn &lt;&lt; <span class=\"string\">\" accepted_pn: \"</span> </span><br><span class=\"line\">        &lt;&lt; accepted_pn &lt;&lt; <span class=\"string\">\" last_commited: \"</span> &lt;&lt; last_commited </span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\" first_committed: \"</span> &lt;&lt; first_committed &lt;&lt; dendl;</span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"init\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">    assert(is_consistent());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//refresh_from_paxos(NULL)<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::refresh_from_paxos(<span class=\"keyword\">bool</span> * need_bootstrap)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;PAXOS_NUM; ++i)&#123;</span><br><span class=\"line\">        paxos_service[i]-&gt;refresh(need_boostrap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;PAXOS_NUM; ++i)&#123; <span class=\"comment\">//主要是处理PGMonitor</span></span><br><span class=\"line\">        paxos_service[i]-&gt;post_paxos_update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//paxos_service vector中的对象都没有派生refresh(), 都调用基类refresh方法<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> PaxosService::refresh(<span class=\"keyword\">bool</span> *need_boostrap)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    update_from_paxos(need_boostrap);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// update_from_paxos 均被paxos_service vector中的对象进行了派生</span></span><br><span class=\"line\"><span class=\"comment\">// 这里仅仅列出MonmapMonitor 对象方法</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> MonmapMonitor:;update_from_paxos(<span class=\"keyword\">bool</span> *need_boostrap)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">version_t</span>  version = get_last_committed();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(version &lt;= mon-&gt;monmap-&gt;get_epoch())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" version \"</span> &lt;&lt; version</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\", my v \"</span> &lt;&lt; mon-&gt;monmap-&gt;epoch &lt;&lt; dendl;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//post_paxos_update() 方法，</p>\n<ul>\n<li>只有PGMonitor覆盖写了post_paxos_update</li>\n<li>其他5个类均没有使用基类<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> PGMonitor:;post_paxos_update()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mon-&gt;osdmon()-&gt;osdmap.get_epoch())&#123;</span><br><span class=\"line\">        map_pg_creates();</span><br><span class=\"line\">        send_pg_creates();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mon/Monitor.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Monitor::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dout(<span class=\"number\">2</span>) &lt;&lt; <span class=\"string\">\"init\"</span> &lt;&lt; dendl;</span><br><span class=\"line\">    lock.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//start ticker</span></span><br><span class=\"line\">    timer.init()</span><br><span class=\"line\">    new_tick()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//i'm ready!</span></span><br><span class=\"line\">    messenger-&gt;add_dispatcher_tail(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// encode command sets</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> MonCommand *cmds;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cmdsize;</span><br><span class=\"line\">    get_locally_supported_monitor_commands(&amp;cmds, &amp;cmdsize);</span><br><span class=\"line\">    MonCommand::encode_array(cmds, cmdsize, supported_commands_bl);</span><br><span class=\"line\">    get_classic_monitor_commands(&amp;cmds, &amp;cmdsize);</span><br><span class=\"line\">    MonCommand::encode_array(cmds, cmdsize, classic_commands_bl);</span><br><span class=\"line\"></span><br><span class=\"line\">    lock.Unlock();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// bootstrap() ; 接下去我们需要看peer如何处理OP_PROBE消息<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::bootstrap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ....</span></span><br><span class=\"line\">   state = STATE_PROBING;</span><br><span class=\"line\">   _reset();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// singleton monitor?</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(monmap-&gt;size() == <span class=\"number\">1</span> &amp;&amp; rank == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    win_standalone_election();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">  dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"probing other monitors\"</span> &lt;&lt;dendl;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; monmap-&gt;size(); i++) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>((<span class=\"keyword\">int</span>)i != rank)&#123;</span><br><span class=\"line\">        messenger-&gt;send_message(<span class=\"keyword\">new</span> MMonProbe(monmap-&gt;fsid, MMonProbe::OP_PROBE, name, has_ever_joined), monmap-&gt;get_inst(i));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">entity_addr_t</span>&gt;::iterator p = extra_probe_peers.begin(); p != extra_probe_peers.end(); ++p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*p != messenger-&gt;get_addr())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">entity_inst_t</span> i;</span><br><span class=\"line\">        i.name = <span class=\"keyword\">entity_name_t</span>::MON(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        i.addr = *p;</span><br><span class=\"line\">        messenger-&gt;send_message(<span class=\"keyword\">new</span> MMonProbe(monmap-&gt;fsid, MMonProbe::OP_PROBE, name, has_ever_joined), i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//handle_probe() 用来处理OP_PROBE消息<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::handle_probe(MonOpRequestRef op)&#123;</span><br><span class=\"line\">    MMonProbe *m = <span class=\"keyword\">static_cast</span>&lt;MMonProbe*&gt;(op-&gt;get_req());</span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"handle_probe \"</span>  &lt;&lt; *m &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m-&gt;fsid != monmap-&gt;fsid)&#123;</span><br><span class=\"line\">        dout(<span class=\"number\">0</span>) &lt;&lt; <span class=\"string\">\"handle_probe ignoring fsid \"</span>  &lt;&lt; m-&gt;fsid &lt;&lt; <span class=\"string\">\" != \"</span> &lt;&lt; monmap-&gt;fsid &lt;&lt; dendl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (m-&gt;op)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MMonProbe::OP_PROBE:</span><br><span class=\"line\">        handle_probe_probe(op);     <span class=\"comment\">// &lt;-- 处理OP_PROBE请求</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MMonProbe::OP_REPLY:</span><br><span class=\"line\">        handle_probe_reply(op);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> MMonProbe::OP_MISSING_FEATURES:</span><br><span class=\"line\">        derr &lt;&lt; __func__ &lt;&lt; <span class=\"string\">\" missing features, have \"</span> &lt;&lt; CEPH_FEATURES_ALL </span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\", required \"</span> &lt;&lt; m-&gt;required_features</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\", missing \"</span> &lt;&lt; (m-&gt;required_features &amp; ~CEPH_FEATURES_ALL)</span><br><span class=\"line\">        &lt;&lt; dendl; </span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//handle_probe_probe 处理流程<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Monitor::handle_probe_probe(MonOpRequestRef op)&#123;</span><br><span class=\"line\">    MMonProbe *m = <span class=\"keyword\">static_cast</span>&lt;MMonProbe*&gt;(op-&gt;get_req());</span><br><span class=\"line\"></span><br><span class=\"line\">    dout(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">\"handle_probe_probe \"</span> &lt;&lt; m-&gt;get_source_inst() &lt;&lt; *m</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\" features \"</span> &lt;&lt; m-&gt;get_connection()-&gt;get_features() &lt;&lt; dendl;</span><br><span class=\"line\"></span><br><span class=\"line\">    uint_64 missing = required_features &amp; ~m-&gt;get_connection()-&gt;get_features();</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_probing() &amp;&amp; !is_synchronizing()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(paxos-&gt;get_version() + <span class=\"number\">1</span> &lt; m-&gt;paxos_first_version)&#123;</span><br><span class=\"line\">            dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\" peer \"</span> &lt;&lt; m-&gt;get_source_addr() &lt;&lt; <span class=\"string\">\" has </span></span><br><span class=\"line\"><span class=\"string\">            first_committed \"</span> &lt;&lt; <span class=\"string\">\" ahead of us, re-bootstrapping \"</span> &lt;&lt; dendl;</span><br><span class=\"line\">            bootstrap();</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MMonProbe *r;</span><br><span class=\"line\">    r = <span class=\"keyword\">new</span> MMonProbe(monmap-&gt;fsid, MMonProbe::OP_REPLY, name, has_ever_joined);</span><br><span class=\"line\">    r-&gt;name = name;</span><br><span class=\"line\">    r-&gt;quorum = quorum;</span><br><span class=\"line\">    monmap-&gt;encode(r-&gt;monmap_bl, m-&gt;get_connection()-&gt;get_features());</span><br><span class=\"line\">    r-&gt;paxos_first_version = paxos-&gt;get_first_committed();</span><br><span class=\"line\">    r-&gt;paxos_last_version = paxos-&gt;get_version();</span><br><span class=\"line\">    m-&gt;get_connection()-&gt;send_message(r);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// did we discover a peer here?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!monmap-&gt;contains(m-&gt;get_source_addr()))&#123;</span><br><span class=\"line\">        dout(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\" adding peer \"</span>&lt;&lt; m-&gt;get_source_addr() </span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">\" to list of hints \"</span>&lt;&lt; dendl;</span><br><span class=\"line\">        extra_probe_peers.insert(m-&gt;get_source_addr());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   out:</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//handle_probe_reply()<br>void Monitor::handle_probe_reply(MonOpRequestRef op){<br>    MMonProbe <em>m = static_cast&lt;MMonProbe</em>&gt;(op-&gt;get_req());<br>    dout(10) &lt;&lt; “handle_probe_reply “ &lt;&lt; m-&gt;get_source_inst() &lt;&lt; <em>m &lt;&lt;dendl;<br>    dout(10) &lt;&lt; “ monmap is “ &lt;&lt; </em>monmap &lt;&lt; dendl; </p>\n<pre><code>//discover name and addrs during probing or electing states.\nif(!is_probing() &amp;&amp; !is_electing()){\n    return;\n}\n//newer map, or they&apos;ve joined a quorum and we haven&apos;t?\n</code></pre><p>}</p>"},{"title":"ceph rados对象属性研究","date":"2018-12-09T16:00:00.000Z","_content":"\n### rados\n\nrados组织形式：\n  - pool\n    + object\n      * xattr\n        - xfs文件属性\n        - omap\n      * data\n        - xfs文件内容\n1、rados以pool来组织数据，pool中包含许多object\n2、一个object包含两部分：\n  - 存储对象的数据\n  - 该对象的额外属性xattr\n3、对象的额外属性可以有两个存储的部分：一个是ext4文件的属性部分，这部分往往受底层文件系统的约束，比如ext4文件系统要求其最大不超过4KB；另一个是rados实现的omap，rados使用一种机制，可以为每一个object关联一个omap\n4、omap是一个key-value存储系统，最早是leveldb，当然也有其他选择，比如rocksdb。\n5、FileStore的omap中存放的对视对象的属性信息，以key-value的形式存在，那么对于不同的属性，如何定义对象的键值key呢；\n<!-- more -->\n### \n\n```c++\n//struct ghobject_t 底层文件系统中文件描述，name就对于的文件名\nstruct object_t{\n  string name;\n  object_t(): name(s) {}\n  object_t(const char *s): name(s){}\n\n  void swap(object_t& o){\n    name.swap(o.name);\n  }\n\n  void clear(){\n    name.clear();\n  }\n\n  void encode(bufferlist &bl) const{\n    ::encode(name, bl);\n  }\n\n  void decode(bufferlist::iterator &bl){\n    ::decode(name, bl);\n  }\n};\nWRITE_CLASS_ENCODER(object_t)\n```\n\n//struct sobject_t  \n  - 添加了snapshot相关信息的object_t\n  - snap为该对象对于snapshot的snap号\n  - 如果该对象不是快照，则snap字段设置为CEPH_NOSNAP，非snapshot对象也成为head对象 \n```c++\nstruct sobject_t{\n  object_t oid;\n  snapid_t snap;\n\n  sobject_t() : snap(0){}\n  sobject_t(object_t o, snapid_t s) : oid(o), snap(s) {}\n\n  void swap(sobject_t& o){\n    oid.swap(o.oid);\n    snapid_t t = snap;\n    snap = o.snap;\n    o.snap = t;\n  }\n\n  void encode(bufferlist& bl) const{\n    ::encode(oid, bl);\n    ::encode(snap, bl);\n  }\n\n  void decode(bufferlist::iterator& bl) {\n    ::decode(oid, bl);\n    ::decode(snap, bl);\n  }\n};\nWRITE_CLASS_ENCODER(sobject_t)\n```\n\n//hobject_t (hash object)\n  - object_t oid: 对象的名字\n  - snapid_t snap: 保存对象的snap\n  - int64_t pool: 该object所在pool的id\n  - string nspace： 一般为空\n  - string key： \n  - string hash： pg id\n```c++\nstruct hobject_t{\n  object_t oid;\n  snapid_t snap;\nprivate:\n  uint32_t hash;\n  bool max;\n  uint32_t nibblewise_key_cache;\n  uint32_t hash_reverse_bits;\n  static const int64_t POOL_META = -1;\n  static const int64_t POOL_TEMP_START = -2;\n  friend class spg_t;     // for POOL_TEMP_START\npublic:\n  int64_t pool;\n  string  nspace;\n\nprivate:\n  string key;\n  class hobject_t_max {};\n\npublic:\n  const string &get_key() const {\n    return key;\n  }\n\n  void set_key(const std::string &key_){\n    if(key_ == oid.name)\n      key.clear();\n    else\n      key = key_;\n  }\n\n  string to_str() const;\n\n  uint32_t get_hash() const{\n    return hash;\n  }\n\n  void set_hash()(uint32_t value){\n    hash = value;\n    build_hash_cache();\n  }\n\n  static bool match_hash(uint32_t to_check, uint32_t bits, uint32_t match){\n    return (match & ~((~0)<<bits)) == (to_check & ~((~0)<<bits));\n  }\n\n  bool match(uint32_t bits, uint32_t match) const{\n    return match_hash(hash, bits, match);\n  }\n\n  bool is_temp() const{\n    return pool <= POOL_TEMP_START && pool != INT64_MIN;\n  }\n\n  bool ls_meta() const {\n    return pool == POOL_META;\n  }\n\n  hobject_t : snap(0), hash(0), max(false), pool(INT64_MIN){\n    build_hash_cache();\n  }\n\n  hobject_t(const hobject_t &rhs) = default;\n  hobject_t(hobject_t &&rhs) = default;\n  hobject_t(hobject_t_max &&singleton) : hobject_t(){\n    max = true;\n  }\n  hobject_t &operator=(const hobject_t &rhs) = default;\n  hobject_t &operator-(hobject_t &&rhs) = default;\n  hobject_t &operator=(hobject_t_max &&singleton){\n    *this = hobject_t();\n    max = true;\n    return *this;\n  }\n\n  //maximum stored value.\n  static hobject_t_max get_max(){\n    return hobject_t_max();\n  }\n\n  hobject_t(object_t oid, const strings key, snapid_t snap, uint32_t hash, int64_t pool, string nspace): oid(oid), snap(snap), hash(hash), max(false),\n    pool(pool), nspace(nspace), key(soid,oid.name == key ? string() : key){\n      build_hash_cache();\n    }\n\n    /// @return min hobject_t ret s.t. ret.hash == this->hash\n    // 获取边界\n    hobject_t get_boundary() const{\n      if (is_max())\n        return *this;\n      hobject_t ret;\n      ret.set_hash(hash);\n      ret.pool = pool;\n      return ret;\n    }\n\n    hobject_t get_object_boundary() const {\n      if(is_max())\n        return *this;\n      hobject_t ret = *this;\n      ret.snap = 0;\n      return ret;\n    }\n\n    ///@return head version of this hobject_t\n    hobject_t get_head() const{\n      hobject_t ret(*this);\n      ret.snap = CEPH_NOSANP;\n      return ret;\n    }\n\n    ///@return snapdir version of this hobject_t\n    hobject_t get_snapdir() const{\n      hobject_t ret(*this);\n      ret.snap = CEPH_SNAPDIR;\n      return ret;\n    }\n\n    ///@return true if object is head\n    bool is_head() const {\n      return snap == CEPH_NOSANP;\n    }\n\n    ///@return true if object is neither head nor snapdir nor max\n    bool is_snap() const{\n      return !is_max() && !is_head() && !is_snapdir();\n    }\n\n    ///@return true if the object should have a snapset in it's attrs\n    bool has_snapset() const{\n      return is_head() || is_snapdir();\n    }\n\n    //Do not use when a particular hash function is need\n    explicit hobject_t(const sobject_t &o) : oid(o.oid), snap(o.snap), max(false), pool(POOL_META) {\n      set_hash(std::hash<sobject_t>()(o));\n    }\n\n    bool is_max() const{\n      assert(!max ||(*this == hobject_t(hobject_t::get_max())));\n      return max;\n    }\n\n    bool is_min() const{\n      //this needs to match how it's constructed\n      return snap==0 &&hash==0 && !max && pool==INT64_MIN;\n    }\n\n    static uint32_t _reverse_bits(uint32_t v){\n      return reverse_bits(v);\n    }\n\n    static uint32_t _reverse_nibbles(uint32_t retval){\n      return _reverse_nibbles(retval);\n    }\n\n    /**\n     * Returns set S of strings such that for any object h.match(bits, mask), t\n     * there is some string s\\f$in\\f$ S such thats is a prefix of h.to_str().\n     * Furthermore, for any s $f\\in\\f$ S, s is a prefix of h.str() implies *\n     * that h.match(bits, mask).\n     **/\n    static set<string> get_prefixes(uint32_t bits, uint32_t mask, int64_t pool)\n    {\n      uint32_t len = bits;\n      while(len % 4 /* nibbles */) len++;\n\n      set<uint32_t> from;\n      if (bits < 32)\n        from.insert(mask & ~((uint32_t)(~0) << bits));\n      else if(bits == 32)\n        from.insert(mask);\n      else\n        ceph_abort();\n\n      set<uint32_t> to;\n      fro(uint32_t i=bits; i<len; ++i){\n        for(set<uint32_t>::iterator j=from.begin(); j!=from.end(); ++j){\n          to.insert(*j | (1U<<i));\n          to.insert(*j);\n        }\n        to.swap(from);\n        to.clear();\n      }\n\n      char buf[20];\n      char *t = buf;\n      uint64_t poolid(pool);\n\n      t += snprintf(t, sizeof(buf), \"%.*llX\", 16, (long long unsigned)poolid);\n      *(t++) = '.'\n      string poolstr(buf, t - buf);\n      set<string> ret;\n      for(set<uint32_t>::iterator i=from.begin(); i != from.end(); ++i){\n        uint32_t revhash(hobject_t::_reverse_nibbles(*i));\n        snprintf(buf, sizeof(buf), \"%.*X\", (int)(sizeof(revhash))*2, revhash);\n        ret.insert(poolstr + string(buf, len/4));\n      }\n      return ret;\n    }\n\n    //filestore nibble-based key\n    uint32_t get_nibblewise_key_u32()  const{\n      assert(!max);\n      return nibblewise_key_cache;\n    }\n\n    uint64_t get_nibblewise_key()  const {\n      return max ? 0x100000000ull : nibblewise_key_cache;\n    }\n\n    // newer bit-reversed key\n    uint32_t get_bitwise_key_u32() const {\n      assert(!max);\n      return hash_reverse_bits;\n    }\n\n    uint64_t get_bitwise_key() const {\n      return max ? 0x100000000ull : hash_reverse_bits;\n    }\n\n    //please remeber to update set_bitwise_key_u32() also\n    //once you change build_hash_cache()\n    void build_hash_cache(){\n      nibblewise_key_cache = _reverse_nibbles(hash);\n      hash_reverse_bits = _reverse_bits(hash);\n    }\n\n    void set_bitwise_key_u32(uint32_t value){\n      hash = _reverse_bits(value);\n      //below is identical to build_hash_cache() and shall be\n      //updated correspondingly if you change build_hash_cache()\n      nibblewise_key_cache = _reverse_nibbles(hash);\n      hash_reverse_bits = values;\n    }\n\n    const string& get_effective_key() const{\n      if(key.length())\n        return key;\n      return oid.name;\n    }\n\n    hobject_t make_temp_hobject(const string& name) const{\n      return hobject_t(object_t(name), \"\", CEPH_NOSANP, hash, hobject_t::POOL_TEMP_START - pool, \"\");\n    }\n\n    void swap(hobject_t &o){\n      hobject_t temp(o);\n      o = (*this);\n      (*this) = temp;\n    }\n\n    const string &get_namespace() const { \n      return nspace;\n    }\n\n    bool parse(const string& s);\n    void encode(bufferlist& bl) const; \n    void decode(bufferlist::iterator& bl);\n    void decode(json_spirit::Value& v); \n    void dump(Formatter *f) const; \n    static void generate_test_instances(list<hobject_t*>& o);\n    friend int cmp(const hobject_t& l, const hobject_t& r);\n    friend bool operator>(const hobject_t& l, const hobject_t& r) { \n      return cmp(l, r) > 0;\n    }\n\n    friend bool operator>=(const hobject_t& l, const hobject_t& r) {\n        return cmp(l, r) >=0;\n    }\n\n    friend bool operator<(const hobject_t& l, const hobject_t& r) {\n      return cmp(l, r) < 0;\n    }\n\n    friend bool operator<=(const hobject_t& l, const hobject_t& r) {     \n      return cmp(l, r) <= 0;\n    }\n    friend bool operator==(const hobject_t&, const hobject_t&); \n    friend bool operator!=(const hobject_t&, const hobject_t&);\n    friend struct ghobject_t;\n};\nWRITE_CLASS_ENCODE(hboject_t)\n```\n//ghobject_t\n  - 在hobjec_t基础上，添加了generation 字段 和 shard_id 字段; 主要用于EC的rollback\n  - 副本模式下， shard_id设置为NO_SHARD(-1), 这两个字段是无效的；\n```c++\nstruct ghobject_t{\n  hboject_t hobj;\n  gen_t generation;\n  shard_id_t shard_id;\n  bool max;\n\npublic:\n  static const gen_t NO_GEN=UINT64_MAX;\n\n  ghobject_t(): generation(NO_GEN), shard_id(shard_id_t::NO_SHARD), max(false){}\n  explicit ghobject_t(const hobject_t &obj) : hobj(obj), generation(NO_GEN),\n    shard_id(shard_id_t::NO_SHARD), max(false){}\n\n  ghobject_t(const hobject_t &obj, gen_t gen, shard_id_t shard):\n    hobj(obj), generation(gen), shard_id(shard), max(false){}\n\n  static ghobject_t make_pgmeta(int64_t pool, uint32_t hash, shard_id_t shard){\n    hobject_t h(object_t(), string(), CEPH_NOSANP, hash, pool, string());\n    return ghobject_t(h, NO_GEN, shard);\n  }\n\n  bool is_pgmeta() const{\n    //make sure we are distinct from hobject_t(), which has pool INT64_MIN\n    return hobj.pool >= 0 && hobj.oid,name.empty();\n  }\n\n  bool match(uint32_t bits, uint32_t match) const{\n    return hobj.match_hash(hobj.hash, bits, match);\n  }\n\n  /// @return min ghobject_t ret s.t. ret.hash == this->hash\n  ghobject_t get_boundary() const{\n    if(hobj.is_max())\n      return *this;\n    ghobject_t ret;\n    ret.hobj.set_hash(hobj.hash);\n    ret.shard_id = shard_id;\n    ret.hobj.pool = hobj.pool;\n    retrun ret;\n  }\n\n  uint32_t get_nibblewise_key_u32() const{\n    return hobj.get_nibblewise_key_u32();\n  }\n\n  uint32_t get_nibblewise_key() const{\n    return hobj.get_nibblewise_key();\n  }\n\n  bool is_degenerate() const{\n    return generation == NO_GEN && shard_id == shard_id::NO_SHARD;\n  }\n\n  bool is_no_gen() const{\n    return generation == NO_GEN;\n  }\n\n  bool is_no_shard() const{\n    return shard_id == shard_id_t::NO_SHARD;\n  }\n\n  void set_shard(shard_id_t s){\n    shard_id = s;\n  }\n\n  bool parse(const string& s);\n\n  //maximum sorted value.\n  static ghobject_t get_max(){\n    ghobject_t h;\n    h.max = true;\n    h.hobj = hobject_t::get_max();  //so that is_max() => hobj.is_max()\n    return h;\n  }\n\n  bool is_max() const{\n    return max;\n  }\n\n  bool is_min() const{\n    return *this == ghobject_t();\n  }\n\n  void swap(ghobject_t &o){\n    ghobject_t temp(o)\n    o = (*this)\n    (*this) = temp;\n  }\n\n  void encode(bufferlist& bl) const;\n  void decode(bufferlist::iterator& bl);\n  void decode(json_spirit::Value& v);\n  size_t encoded_size() const;\n  void dump(Formatter *f) const;\n  static void generate_test_instances(list<ghobject_t*>& o);\n  friend int cmp(const ghobject_t& l, const ghobject_t& r);\n  friend bool operator>(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) > 0;\n  }\n  friend bool operator>=(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) >= 0;\n  }\n\n  friend bool operator<(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) < 0;\n  }\n  friend bool operator<=(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) <= 0;\n  }\n  friend bool operator==(const ghobject_t&, const ghobject_t&);\n  friend bool operator!=(const ghobject_t&, const ghobject_t&);\n};\nWRITE_CLASS_ENCODE(ghobject_t)\n```\n\n最直观的感觉是object id + xattr key; 两者结合一起，形成对象的键值key，但存在一个弊端\nobject id可能很长，当个对象存在很多属性的时候，object id不得不在key中出现多次，这必然会造成存储空间的浪费。\nCeph的FileStore分成了2步，第一步根据object id生成一个比较短的seq，然后seq + xattr key形成对象的某个属性的键值。\n\nomap不是通过计算从object id 获取seq的，他是首先根据object id, 存放一个Header类型的\n数据结构到LevelDB，其中Header中的一个成员变量为seq。\n- key: USER_PREFIX + header_key(header->seq) + XATTR_PREFIX + key\n- value: header\n\n```c++\n /*\n  - key: HOBJECT_TO_SEQ +ghobject_key(oid)\n  - value: header (struct _Header)\n */\n  struct _Header{\n    uint64_t seq;\n    uint64_t parent;\n    uint64_t num_children;\n\n    ghobject_t oid;\n\n    SequencerPosition spos;\n\n    void encode(bufferlist& bl) const{\n      coll_t unused;\n      ENCODE_START(2, 1, bl);\n      ::encode(seq, bl);\n      ::encode(parent, bl);\n      ::encode(num_children, bl);\n      ::encode(unused, bl);\n      ::encode(oid, bl);\n      ::encode(spos bl);\n      ENCODE_FINISH(bl);\n    }\n\n    void decode(bufferlist::iterator& bl){\n      coll_t unused;\n      DECODE_START(2, bl);\n      ::decode(seq, bl);\n      ::decode(parent, bl);\n      ::decode(num_children, bl);\n      ::decode(unused, bl);\n      ::decode(oid, bl);\n      if (struct_v >= 2)\n        ::decode(spos, bl);\n      DECODE_FINISH(bl);\n    }\n\n    void dump(Formatter *f) const{\n      f->dump_unsigned(\"seq\", seq);\n      f->dump_unsigned(\"parent\", parent);\n      f->dump_unsigned(\"num_children\", num_children);\n      f->dump_stream(\"oid\") << oid;\n    }\n\n    static void generate_test_instances(list<_Header*>& o ){\n      o.push_back(new _Header);\n      o.push_back(new _Header);\n      o.back()->parent = 20;\n      o.back()->seq = 30;\n    }\n\n    _Header() : seq(0), parent(0), num_children(1) {}\n};\n```\n如果要获取某个对象的oid的某个属性的值，需要分成两步走:\n  - 找到Header，从header中取出seq的值\n  - 根据seq的值生成该属性对应的新的最终的键值，从LevelDB中取出value\n\n```c++\n//获取对象oid的某个或者某几个属性的值\n// os/filestore/DBObjectMap.cc\nint DBObjectMap::get_xattrs(const ghobject_t& oid, const set<string>& to_get, map<string, bufferlist>* out){\n  MapHeaderLock hl(this, oid);\n  //第一步根据oid找到header\n  Header header = lookup_map_header(hl, oid);\n  if (!header)\n    return -ENOENT;\n\n  //根据找到的header中的seq值，社会你刚才属性的键，在levelDB中找到对应key的value\n  return db-get(xattr_prefix(header), to_get, out);\n}\n\n/*\n * \n */\n\nint DBObjectMap::set_xattrs(const ghobject_t& oid, const map<string, bufferlist>& to_set, const SequencerPosition *spos){\n  KeyValueDB::Transaction t = db->get_transcation();\n  MapHeaderLock hl(this, oid);\n  /*寻找oid对应的header，如若没有，则新建一个header*/\n  Header header = lookup_create_map_header(hl, oid, t);\n  if (!header)\n    return -EINVAL;\n  if (check_spos(oid, header, spos))\n    return 0;\n\n    /*根据header中的seq，得到真正的键值，然后设置一个或者多个属性*/\n  t->set(xattr_prefix(header), to_set);\n  return db->submit_transaction(t);\n}\n\nconst string DBObjectMap::USER_PREFIX = \"__USER__\";\nconst string DBObjectMap::XATTR_PREFIX= \"__AXATTR__\";\n\nstring DBObjectMap::header_key(uint64_t seq){\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"%.*\" PRId64, (int)(2*sizeof(seq)), seq);\n  return string(buf);\n}\n\nstring DBObjectMap::xattr_prefix(Header header){\n  return USER_PREFIX + header_key(header->seq) + XATTR_PREFIX;\n}\n```\n\n### seq 生成过程\n  - LevelDB中存放着一个特殊的全局意义的key-value\n  - key: SYS_PREFIX + GLOBAL_STATE_KEY \n  - value: State  \n```c++\n/// peersistent state for store @see generate_header\nstruct State{\n  static const _u8 CUR_VERSION = 3;\n  __u8 v;\n  uint64_t seq;\n  // legacy is false when complete regions never used\n  bool legacy;\n\n  State() : v(0), seq(1), legacy(false){}\n  explicit State(uint64_t seq) : v(0), seq(seq), legacy(false){}\n\n  void encode(bufferlist& bl) const{\n    ENCODE_START(3, 1, bl);\n    ::encode(v, bl);\n    ::encode(seq, bl);\n    ::encode(legacy, bl);\n    ENCODE_FINISH(bl);    \n  }\n\n  void decode(bufferlist::iterator &bl){\n    DECODE_START(3, bl);\n    if (struct_v >=2)\n      ::decode(v, bl);\n    else\n      v = 0;\n    ::decode(seq, bl);\n    if(struct_v >=3)\n      ::decode(legacy, bl);\n    else\n      legacy = false;\n    DECODE_FINISH(bl);\n  }\n\n  void dump(Formatter* f) const{\n    f->dump_unsigned(\"v\", v);\n    f->dump_unsigned(\"seq\", seq);\n    f->dump_unsigned(\"legacy\", legacy);\n  }\n\n  static void generate_test_instances(list<State*>& o){\n    o.push_back(new State(0));\n    o.push_back(new State(20));\n  } state;\n\n\n}\n```\n```c++ 该结构体只有一个成员变量，即seq，当产生新的Header的时候，会该值会递增，写入LevelDB\nDBObjectMap::Header DBObjectMap::_generate_new_header(const ghobject_t& oid, Header parent){\n  Header header = Header(new _Header(), RemoveOnDelete(this));\n  header->seq = state.seq++;\n  if (parent){\n    header->parent =  parent->seq;\n    header->spos = parent->spos;\n  }\n\n  header->num_children = 1;\n  header->oid = oid;\n  assert(!in_use.count(header->seq));\n  in_use.insert(header->seq);\n\n  write_state();\n  return header;\n}\n\n//因为是全局的，为了防止竞争，需要加锁保护。\nHeader generate_new_header(const ghobject_t &oid, Header parent) {\n    Mutex::Locker l(header_lock);//加锁保护\n    return _generate_new_header(oid, parent);\n  }\n  \nDBObjectMap::Header DBObjectMap::lookup_create_map_header(\n  const MapHeaderLock &hl, \n  const ghobject_t &oid,\n  KeyValueDB::Transaction t)\n{\n  Mutex::Locker l(header_lock); // 加锁保护\n  Header header = _lookup_map_header(hl, oid);\n  if (!header) {\n    header = _generate_new_header(oid, Header());                                                                                                      \n    set_map_header(hl, oid, *header, t);\n  }\n  return header;\n} \n```\n\n### ceph-objectstore-tool 用法\n\n\n### rgw s3 属性\nrgw s3的额外属性：\n  - user\n  - bucket\n  - bucket.instance\n```go\n//<bucket>指bucket name; <marker>指bucker id; <user>指user id\n$ radosgw-admin metadata list\n$ radosgw-admin metadata list bucket\n$ radosgw-admin metadata list bucket.instance\n$ radosgw-admin metadata list user\n\n$ radosgw-admin metadata get bucket:<bucket>\n$ radosgw-admin metadata get bucket.instance:<bucket>:<marker>\n$ radosgw-admin metadata get user:<user>   # get or set\n```\n\nuser 数据被以<user>作为object name存储在default.rgw.meta pool中，其中namespace是user uid\nbucket 数据以<bucket>作为object name存储在default.rgw.meta pool, 其中namespace：root\n\nbucket.instance 数据以.bucket.meta.<bucket>:<marker>作为 object name存储在default.rgw.meta pool中，其namespace是root。\n\n#### bucket属性\n```go\nradosgw-admin bucket stats --bucket=test\n{\n    \"bucket\": \"test\",\n    \"pool\": \".rgw.buckets.zj-1\",\n    \"index_pool\": \".rgw.buckets.index\",\n    \"id\": \"default.784974.1\",\n    \"marker\": \"default.784974.1\",\n    \"owner\": \"user-1\",\n    \"ver\": \"0#1901\",\n    \"master_ver\": \"0#0\",\n    \"mtime\": \"2015-04-07 16:23:23.000000\",\n    \"max_marker\": \"0#\",\n    \"usage\": {\n        \"rgw.main\": {\n            \"size_kb\": 1048870,\n            \"size_kb_actual\": 1048908,\n            \"num_objects\": 17\n        }\n    },\n    \"bucket_quota\": {\n        \"enabled\": false,\n        \"max_size_kb\": -1,\n        \"max_objects\": -1\n    }\n}\n```\nbucket的名称，所在的data pool, index pool, bucket id\n```c++\n    bucket_id\n      - zone_name     -->   default\n      - instance_id   -->   784974\n      - bucket id     -->   1\n```\n#### bucket index 属性\n```go\nrados -p .rgw.buckets.index ls - | grep \"default.784974.1\"\n.dir.default.784974.1\n```\nbucket index object 名称为： .dir.{buckt id}\n\n#### 查看index 的keys\n```c++\n# rados -p .rgw.buckets.index listomapkeys .dir.default.784974.1\n/demo/region.conf.json\n```\n\n### rgw_max_chunk_size & rgw_obj_stripe_size\n\n- rgw_max_chunk_size : default: (524388) 512k\n  - RadosGW下发到RADOS集群的单个IO的大小\n  - 当写入的对象大小大于rgw_max_chunk_size:\n    + rados层的一个对象，大小为实际大小；\n    + rados层的命名： {bucket_id}_{对象文件的名字}\n  - 当写入的对象大小大于rgw_max_chunk_size:\n    + 分成多种对象存储，\n      1、首对象（head_obj) 大小为rgw_max_chunk_size\n      2、中间对象： 大小为rgw_obj_stripe_size\n      3、尾对象：   小于或等于rgw_obj_stripe_size\n    + 其它的对象按照rgw_obj_stripe_size切分成多个obj存入rados\n    + head object命名规则： {bucket_id}_{对象文件的名字}\n    + 中间对象、尾对象命名：{bucket_id}_shadow_{长度为32的随机字符}_{条带编号, 从1起}\n    + head_obj需要将中间对象、尾对象关联起来：\n    ```c++\n    # rados -p .rgw.buckets listxattr default.ubuntu12.04.iso\n    user.rgw.acl\n    user.rgw.content_type\n    user.rgw.etag\n    user.rgw.idtag\n    user.rgw.manifest\n    user.rgw.x-amz-date\n\n    rados -p .rgw.buckets getxattr  default.11383165.2_scaler.iso  user.rgw.manifest  > /root/scaler.iso.manifest\n\n# ceph-dencoder type RGWObjManifest import /root/ubuntu12.iso.manifest decode dump_json\n{\n    \"objs\": [],\n    \"obj_size\": 2842374144,     <-----------------对象文件大小\n    \"explicit_objs\": \"false\",\n    \"head_obj\": {\n        \"bucket\": {\n            \"name\": \"bean_book\",\n            \"pool\": \".rgw.buckets\",\n            \"data_extra_pool\": \".rgw.buckets.extra\",\n            \"index_pool\": \".rgw.buckets.index\",\n            \"marker\": \"default.11383165.2\",\n            \"bucket_id\": \"default.11383165.2\"\n        },\n        \"key\": \"\",\n        \"ns\": \"\",\n        \"object\": \"scaler.iso\",         <-----对象名\n        \"instance\": \"\"\n    },\n    \"head_size\": 524288,\n    \"max_head_size\": 524288,\n    \"prefix\": \".mGwYpWb3FXieaaaDNdaPzfs546ysNnT_\",  <---中间对象和尾对象的随机前缀\n    \"tail_bucket\": {\n        \"name\": \"bean_book\",\n        \"pool\": \".rgw.buckets\",\n        \"data_extra_pool\": \".rgw.buckets.extra\",\n        \"index_pool\": \".rgw.buckets.index\",\n        \"marker\": \"default.11383165.2\",\n        \"bucket_id\": \"default.11383165.2\"\n    },\n    \"rules\": [\n        {\n            \"key\": 0,\n            \"val\": {\n                \"start_part_num\": 0,\n                \"start_ofs\": 524288,\n                \"part_size\": 0,\n                \"stripe_max_size\": 4194304,\n                \"override_prefix\": \"\"\n            }\n        }\n    ]\n}\n    ```\n\n```c++\nclass RGWObjManifest{\nprotected:\n  \n\n}\n```\n","source":"_posts/ceph_object_attr.md","raw":"---\ntitle: ceph rados对象属性研究\ndate: 2018-12-10\ncategories:\n  - ceph\ntags:\n  - ceph \n---\n\n### rados\n\nrados组织形式：\n  - pool\n    + object\n      * xattr\n        - xfs文件属性\n        - omap\n      * data\n        - xfs文件内容\n1、rados以pool来组织数据，pool中包含许多object\n2、一个object包含两部分：\n  - 存储对象的数据\n  - 该对象的额外属性xattr\n3、对象的额外属性可以有两个存储的部分：一个是ext4文件的属性部分，这部分往往受底层文件系统的约束，比如ext4文件系统要求其最大不超过4KB；另一个是rados实现的omap，rados使用一种机制，可以为每一个object关联一个omap\n4、omap是一个key-value存储系统，最早是leveldb，当然也有其他选择，比如rocksdb。\n5、FileStore的omap中存放的对视对象的属性信息，以key-value的形式存在，那么对于不同的属性，如何定义对象的键值key呢；\n<!-- more -->\n### \n\n```c++\n//struct ghobject_t 底层文件系统中文件描述，name就对于的文件名\nstruct object_t{\n  string name;\n  object_t(): name(s) {}\n  object_t(const char *s): name(s){}\n\n  void swap(object_t& o){\n    name.swap(o.name);\n  }\n\n  void clear(){\n    name.clear();\n  }\n\n  void encode(bufferlist &bl) const{\n    ::encode(name, bl);\n  }\n\n  void decode(bufferlist::iterator &bl){\n    ::decode(name, bl);\n  }\n};\nWRITE_CLASS_ENCODER(object_t)\n```\n\n//struct sobject_t  \n  - 添加了snapshot相关信息的object_t\n  - snap为该对象对于snapshot的snap号\n  - 如果该对象不是快照，则snap字段设置为CEPH_NOSNAP，非snapshot对象也成为head对象 \n```c++\nstruct sobject_t{\n  object_t oid;\n  snapid_t snap;\n\n  sobject_t() : snap(0){}\n  sobject_t(object_t o, snapid_t s) : oid(o), snap(s) {}\n\n  void swap(sobject_t& o){\n    oid.swap(o.oid);\n    snapid_t t = snap;\n    snap = o.snap;\n    o.snap = t;\n  }\n\n  void encode(bufferlist& bl) const{\n    ::encode(oid, bl);\n    ::encode(snap, bl);\n  }\n\n  void decode(bufferlist::iterator& bl) {\n    ::decode(oid, bl);\n    ::decode(snap, bl);\n  }\n};\nWRITE_CLASS_ENCODER(sobject_t)\n```\n\n//hobject_t (hash object)\n  - object_t oid: 对象的名字\n  - snapid_t snap: 保存对象的snap\n  - int64_t pool: 该object所在pool的id\n  - string nspace： 一般为空\n  - string key： \n  - string hash： pg id\n```c++\nstruct hobject_t{\n  object_t oid;\n  snapid_t snap;\nprivate:\n  uint32_t hash;\n  bool max;\n  uint32_t nibblewise_key_cache;\n  uint32_t hash_reverse_bits;\n  static const int64_t POOL_META = -1;\n  static const int64_t POOL_TEMP_START = -2;\n  friend class spg_t;     // for POOL_TEMP_START\npublic:\n  int64_t pool;\n  string  nspace;\n\nprivate:\n  string key;\n  class hobject_t_max {};\n\npublic:\n  const string &get_key() const {\n    return key;\n  }\n\n  void set_key(const std::string &key_){\n    if(key_ == oid.name)\n      key.clear();\n    else\n      key = key_;\n  }\n\n  string to_str() const;\n\n  uint32_t get_hash() const{\n    return hash;\n  }\n\n  void set_hash()(uint32_t value){\n    hash = value;\n    build_hash_cache();\n  }\n\n  static bool match_hash(uint32_t to_check, uint32_t bits, uint32_t match){\n    return (match & ~((~0)<<bits)) == (to_check & ~((~0)<<bits));\n  }\n\n  bool match(uint32_t bits, uint32_t match) const{\n    return match_hash(hash, bits, match);\n  }\n\n  bool is_temp() const{\n    return pool <= POOL_TEMP_START && pool != INT64_MIN;\n  }\n\n  bool ls_meta() const {\n    return pool == POOL_META;\n  }\n\n  hobject_t : snap(0), hash(0), max(false), pool(INT64_MIN){\n    build_hash_cache();\n  }\n\n  hobject_t(const hobject_t &rhs) = default;\n  hobject_t(hobject_t &&rhs) = default;\n  hobject_t(hobject_t_max &&singleton) : hobject_t(){\n    max = true;\n  }\n  hobject_t &operator=(const hobject_t &rhs) = default;\n  hobject_t &operator-(hobject_t &&rhs) = default;\n  hobject_t &operator=(hobject_t_max &&singleton){\n    *this = hobject_t();\n    max = true;\n    return *this;\n  }\n\n  //maximum stored value.\n  static hobject_t_max get_max(){\n    return hobject_t_max();\n  }\n\n  hobject_t(object_t oid, const strings key, snapid_t snap, uint32_t hash, int64_t pool, string nspace): oid(oid), snap(snap), hash(hash), max(false),\n    pool(pool), nspace(nspace), key(soid,oid.name == key ? string() : key){\n      build_hash_cache();\n    }\n\n    /// @return min hobject_t ret s.t. ret.hash == this->hash\n    // 获取边界\n    hobject_t get_boundary() const{\n      if (is_max())\n        return *this;\n      hobject_t ret;\n      ret.set_hash(hash);\n      ret.pool = pool;\n      return ret;\n    }\n\n    hobject_t get_object_boundary() const {\n      if(is_max())\n        return *this;\n      hobject_t ret = *this;\n      ret.snap = 0;\n      return ret;\n    }\n\n    ///@return head version of this hobject_t\n    hobject_t get_head() const{\n      hobject_t ret(*this);\n      ret.snap = CEPH_NOSANP;\n      return ret;\n    }\n\n    ///@return snapdir version of this hobject_t\n    hobject_t get_snapdir() const{\n      hobject_t ret(*this);\n      ret.snap = CEPH_SNAPDIR;\n      return ret;\n    }\n\n    ///@return true if object is head\n    bool is_head() const {\n      return snap == CEPH_NOSANP;\n    }\n\n    ///@return true if object is neither head nor snapdir nor max\n    bool is_snap() const{\n      return !is_max() && !is_head() && !is_snapdir();\n    }\n\n    ///@return true if the object should have a snapset in it's attrs\n    bool has_snapset() const{\n      return is_head() || is_snapdir();\n    }\n\n    //Do not use when a particular hash function is need\n    explicit hobject_t(const sobject_t &o) : oid(o.oid), snap(o.snap), max(false), pool(POOL_META) {\n      set_hash(std::hash<sobject_t>()(o));\n    }\n\n    bool is_max() const{\n      assert(!max ||(*this == hobject_t(hobject_t::get_max())));\n      return max;\n    }\n\n    bool is_min() const{\n      //this needs to match how it's constructed\n      return snap==0 &&hash==0 && !max && pool==INT64_MIN;\n    }\n\n    static uint32_t _reverse_bits(uint32_t v){\n      return reverse_bits(v);\n    }\n\n    static uint32_t _reverse_nibbles(uint32_t retval){\n      return _reverse_nibbles(retval);\n    }\n\n    /**\n     * Returns set S of strings such that for any object h.match(bits, mask), t\n     * there is some string s\\f$in\\f$ S such thats is a prefix of h.to_str().\n     * Furthermore, for any s $f\\in\\f$ S, s is a prefix of h.str() implies *\n     * that h.match(bits, mask).\n     **/\n    static set<string> get_prefixes(uint32_t bits, uint32_t mask, int64_t pool)\n    {\n      uint32_t len = bits;\n      while(len % 4 /* nibbles */) len++;\n\n      set<uint32_t> from;\n      if (bits < 32)\n        from.insert(mask & ~((uint32_t)(~0) << bits));\n      else if(bits == 32)\n        from.insert(mask);\n      else\n        ceph_abort();\n\n      set<uint32_t> to;\n      fro(uint32_t i=bits; i<len; ++i){\n        for(set<uint32_t>::iterator j=from.begin(); j!=from.end(); ++j){\n          to.insert(*j | (1U<<i));\n          to.insert(*j);\n        }\n        to.swap(from);\n        to.clear();\n      }\n\n      char buf[20];\n      char *t = buf;\n      uint64_t poolid(pool);\n\n      t += snprintf(t, sizeof(buf), \"%.*llX\", 16, (long long unsigned)poolid);\n      *(t++) = '.'\n      string poolstr(buf, t - buf);\n      set<string> ret;\n      for(set<uint32_t>::iterator i=from.begin(); i != from.end(); ++i){\n        uint32_t revhash(hobject_t::_reverse_nibbles(*i));\n        snprintf(buf, sizeof(buf), \"%.*X\", (int)(sizeof(revhash))*2, revhash);\n        ret.insert(poolstr + string(buf, len/4));\n      }\n      return ret;\n    }\n\n    //filestore nibble-based key\n    uint32_t get_nibblewise_key_u32()  const{\n      assert(!max);\n      return nibblewise_key_cache;\n    }\n\n    uint64_t get_nibblewise_key()  const {\n      return max ? 0x100000000ull : nibblewise_key_cache;\n    }\n\n    // newer bit-reversed key\n    uint32_t get_bitwise_key_u32() const {\n      assert(!max);\n      return hash_reverse_bits;\n    }\n\n    uint64_t get_bitwise_key() const {\n      return max ? 0x100000000ull : hash_reverse_bits;\n    }\n\n    //please remeber to update set_bitwise_key_u32() also\n    //once you change build_hash_cache()\n    void build_hash_cache(){\n      nibblewise_key_cache = _reverse_nibbles(hash);\n      hash_reverse_bits = _reverse_bits(hash);\n    }\n\n    void set_bitwise_key_u32(uint32_t value){\n      hash = _reverse_bits(value);\n      //below is identical to build_hash_cache() and shall be\n      //updated correspondingly if you change build_hash_cache()\n      nibblewise_key_cache = _reverse_nibbles(hash);\n      hash_reverse_bits = values;\n    }\n\n    const string& get_effective_key() const{\n      if(key.length())\n        return key;\n      return oid.name;\n    }\n\n    hobject_t make_temp_hobject(const string& name) const{\n      return hobject_t(object_t(name), \"\", CEPH_NOSANP, hash, hobject_t::POOL_TEMP_START - pool, \"\");\n    }\n\n    void swap(hobject_t &o){\n      hobject_t temp(o);\n      o = (*this);\n      (*this) = temp;\n    }\n\n    const string &get_namespace() const { \n      return nspace;\n    }\n\n    bool parse(const string& s);\n    void encode(bufferlist& bl) const; \n    void decode(bufferlist::iterator& bl);\n    void decode(json_spirit::Value& v); \n    void dump(Formatter *f) const; \n    static void generate_test_instances(list<hobject_t*>& o);\n    friend int cmp(const hobject_t& l, const hobject_t& r);\n    friend bool operator>(const hobject_t& l, const hobject_t& r) { \n      return cmp(l, r) > 0;\n    }\n\n    friend bool operator>=(const hobject_t& l, const hobject_t& r) {\n        return cmp(l, r) >=0;\n    }\n\n    friend bool operator<(const hobject_t& l, const hobject_t& r) {\n      return cmp(l, r) < 0;\n    }\n\n    friend bool operator<=(const hobject_t& l, const hobject_t& r) {     \n      return cmp(l, r) <= 0;\n    }\n    friend bool operator==(const hobject_t&, const hobject_t&); \n    friend bool operator!=(const hobject_t&, const hobject_t&);\n    friend struct ghobject_t;\n};\nWRITE_CLASS_ENCODE(hboject_t)\n```\n//ghobject_t\n  - 在hobjec_t基础上，添加了generation 字段 和 shard_id 字段; 主要用于EC的rollback\n  - 副本模式下， shard_id设置为NO_SHARD(-1), 这两个字段是无效的；\n```c++\nstruct ghobject_t{\n  hboject_t hobj;\n  gen_t generation;\n  shard_id_t shard_id;\n  bool max;\n\npublic:\n  static const gen_t NO_GEN=UINT64_MAX;\n\n  ghobject_t(): generation(NO_GEN), shard_id(shard_id_t::NO_SHARD), max(false){}\n  explicit ghobject_t(const hobject_t &obj) : hobj(obj), generation(NO_GEN),\n    shard_id(shard_id_t::NO_SHARD), max(false){}\n\n  ghobject_t(const hobject_t &obj, gen_t gen, shard_id_t shard):\n    hobj(obj), generation(gen), shard_id(shard), max(false){}\n\n  static ghobject_t make_pgmeta(int64_t pool, uint32_t hash, shard_id_t shard){\n    hobject_t h(object_t(), string(), CEPH_NOSANP, hash, pool, string());\n    return ghobject_t(h, NO_GEN, shard);\n  }\n\n  bool is_pgmeta() const{\n    //make sure we are distinct from hobject_t(), which has pool INT64_MIN\n    return hobj.pool >= 0 && hobj.oid,name.empty();\n  }\n\n  bool match(uint32_t bits, uint32_t match) const{\n    return hobj.match_hash(hobj.hash, bits, match);\n  }\n\n  /// @return min ghobject_t ret s.t. ret.hash == this->hash\n  ghobject_t get_boundary() const{\n    if(hobj.is_max())\n      return *this;\n    ghobject_t ret;\n    ret.hobj.set_hash(hobj.hash);\n    ret.shard_id = shard_id;\n    ret.hobj.pool = hobj.pool;\n    retrun ret;\n  }\n\n  uint32_t get_nibblewise_key_u32() const{\n    return hobj.get_nibblewise_key_u32();\n  }\n\n  uint32_t get_nibblewise_key() const{\n    return hobj.get_nibblewise_key();\n  }\n\n  bool is_degenerate() const{\n    return generation == NO_GEN && shard_id == shard_id::NO_SHARD;\n  }\n\n  bool is_no_gen() const{\n    return generation == NO_GEN;\n  }\n\n  bool is_no_shard() const{\n    return shard_id == shard_id_t::NO_SHARD;\n  }\n\n  void set_shard(shard_id_t s){\n    shard_id = s;\n  }\n\n  bool parse(const string& s);\n\n  //maximum sorted value.\n  static ghobject_t get_max(){\n    ghobject_t h;\n    h.max = true;\n    h.hobj = hobject_t::get_max();  //so that is_max() => hobj.is_max()\n    return h;\n  }\n\n  bool is_max() const{\n    return max;\n  }\n\n  bool is_min() const{\n    return *this == ghobject_t();\n  }\n\n  void swap(ghobject_t &o){\n    ghobject_t temp(o)\n    o = (*this)\n    (*this) = temp;\n  }\n\n  void encode(bufferlist& bl) const;\n  void decode(bufferlist::iterator& bl);\n  void decode(json_spirit::Value& v);\n  size_t encoded_size() const;\n  void dump(Formatter *f) const;\n  static void generate_test_instances(list<ghobject_t*>& o);\n  friend int cmp(const ghobject_t& l, const ghobject_t& r);\n  friend bool operator>(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) > 0;\n  }\n  friend bool operator>=(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) >= 0;\n  }\n\n  friend bool operator<(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) < 0;\n  }\n  friend bool operator<=(const ghobject_t& l, const ghobject_t& r){\n    return cmp(l, r) <= 0;\n  }\n  friend bool operator==(const ghobject_t&, const ghobject_t&);\n  friend bool operator!=(const ghobject_t&, const ghobject_t&);\n};\nWRITE_CLASS_ENCODE(ghobject_t)\n```\n\n最直观的感觉是object id + xattr key; 两者结合一起，形成对象的键值key，但存在一个弊端\nobject id可能很长，当个对象存在很多属性的时候，object id不得不在key中出现多次，这必然会造成存储空间的浪费。\nCeph的FileStore分成了2步，第一步根据object id生成一个比较短的seq，然后seq + xattr key形成对象的某个属性的键值。\n\nomap不是通过计算从object id 获取seq的，他是首先根据object id, 存放一个Header类型的\n数据结构到LevelDB，其中Header中的一个成员变量为seq。\n- key: USER_PREFIX + header_key(header->seq) + XATTR_PREFIX + key\n- value: header\n\n```c++\n /*\n  - key: HOBJECT_TO_SEQ +ghobject_key(oid)\n  - value: header (struct _Header)\n */\n  struct _Header{\n    uint64_t seq;\n    uint64_t parent;\n    uint64_t num_children;\n\n    ghobject_t oid;\n\n    SequencerPosition spos;\n\n    void encode(bufferlist& bl) const{\n      coll_t unused;\n      ENCODE_START(2, 1, bl);\n      ::encode(seq, bl);\n      ::encode(parent, bl);\n      ::encode(num_children, bl);\n      ::encode(unused, bl);\n      ::encode(oid, bl);\n      ::encode(spos bl);\n      ENCODE_FINISH(bl);\n    }\n\n    void decode(bufferlist::iterator& bl){\n      coll_t unused;\n      DECODE_START(2, bl);\n      ::decode(seq, bl);\n      ::decode(parent, bl);\n      ::decode(num_children, bl);\n      ::decode(unused, bl);\n      ::decode(oid, bl);\n      if (struct_v >= 2)\n        ::decode(spos, bl);\n      DECODE_FINISH(bl);\n    }\n\n    void dump(Formatter *f) const{\n      f->dump_unsigned(\"seq\", seq);\n      f->dump_unsigned(\"parent\", parent);\n      f->dump_unsigned(\"num_children\", num_children);\n      f->dump_stream(\"oid\") << oid;\n    }\n\n    static void generate_test_instances(list<_Header*>& o ){\n      o.push_back(new _Header);\n      o.push_back(new _Header);\n      o.back()->parent = 20;\n      o.back()->seq = 30;\n    }\n\n    _Header() : seq(0), parent(0), num_children(1) {}\n};\n```\n如果要获取某个对象的oid的某个属性的值，需要分成两步走:\n  - 找到Header，从header中取出seq的值\n  - 根据seq的值生成该属性对应的新的最终的键值，从LevelDB中取出value\n\n```c++\n//获取对象oid的某个或者某几个属性的值\n// os/filestore/DBObjectMap.cc\nint DBObjectMap::get_xattrs(const ghobject_t& oid, const set<string>& to_get, map<string, bufferlist>* out){\n  MapHeaderLock hl(this, oid);\n  //第一步根据oid找到header\n  Header header = lookup_map_header(hl, oid);\n  if (!header)\n    return -ENOENT;\n\n  //根据找到的header中的seq值，社会你刚才属性的键，在levelDB中找到对应key的value\n  return db-get(xattr_prefix(header), to_get, out);\n}\n\n/*\n * \n */\n\nint DBObjectMap::set_xattrs(const ghobject_t& oid, const map<string, bufferlist>& to_set, const SequencerPosition *spos){\n  KeyValueDB::Transaction t = db->get_transcation();\n  MapHeaderLock hl(this, oid);\n  /*寻找oid对应的header，如若没有，则新建一个header*/\n  Header header = lookup_create_map_header(hl, oid, t);\n  if (!header)\n    return -EINVAL;\n  if (check_spos(oid, header, spos))\n    return 0;\n\n    /*根据header中的seq，得到真正的键值，然后设置一个或者多个属性*/\n  t->set(xattr_prefix(header), to_set);\n  return db->submit_transaction(t);\n}\n\nconst string DBObjectMap::USER_PREFIX = \"__USER__\";\nconst string DBObjectMap::XATTR_PREFIX= \"__AXATTR__\";\n\nstring DBObjectMap::header_key(uint64_t seq){\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"%.*\" PRId64, (int)(2*sizeof(seq)), seq);\n  return string(buf);\n}\n\nstring DBObjectMap::xattr_prefix(Header header){\n  return USER_PREFIX + header_key(header->seq) + XATTR_PREFIX;\n}\n```\n\n### seq 生成过程\n  - LevelDB中存放着一个特殊的全局意义的key-value\n  - key: SYS_PREFIX + GLOBAL_STATE_KEY \n  - value: State  \n```c++\n/// peersistent state for store @see generate_header\nstruct State{\n  static const _u8 CUR_VERSION = 3;\n  __u8 v;\n  uint64_t seq;\n  // legacy is false when complete regions never used\n  bool legacy;\n\n  State() : v(0), seq(1), legacy(false){}\n  explicit State(uint64_t seq) : v(0), seq(seq), legacy(false){}\n\n  void encode(bufferlist& bl) const{\n    ENCODE_START(3, 1, bl);\n    ::encode(v, bl);\n    ::encode(seq, bl);\n    ::encode(legacy, bl);\n    ENCODE_FINISH(bl);    \n  }\n\n  void decode(bufferlist::iterator &bl){\n    DECODE_START(3, bl);\n    if (struct_v >=2)\n      ::decode(v, bl);\n    else\n      v = 0;\n    ::decode(seq, bl);\n    if(struct_v >=3)\n      ::decode(legacy, bl);\n    else\n      legacy = false;\n    DECODE_FINISH(bl);\n  }\n\n  void dump(Formatter* f) const{\n    f->dump_unsigned(\"v\", v);\n    f->dump_unsigned(\"seq\", seq);\n    f->dump_unsigned(\"legacy\", legacy);\n  }\n\n  static void generate_test_instances(list<State*>& o){\n    o.push_back(new State(0));\n    o.push_back(new State(20));\n  } state;\n\n\n}\n```\n```c++ 该结构体只有一个成员变量，即seq，当产生新的Header的时候，会该值会递增，写入LevelDB\nDBObjectMap::Header DBObjectMap::_generate_new_header(const ghobject_t& oid, Header parent){\n  Header header = Header(new _Header(), RemoveOnDelete(this));\n  header->seq = state.seq++;\n  if (parent){\n    header->parent =  parent->seq;\n    header->spos = parent->spos;\n  }\n\n  header->num_children = 1;\n  header->oid = oid;\n  assert(!in_use.count(header->seq));\n  in_use.insert(header->seq);\n\n  write_state();\n  return header;\n}\n\n//因为是全局的，为了防止竞争，需要加锁保护。\nHeader generate_new_header(const ghobject_t &oid, Header parent) {\n    Mutex::Locker l(header_lock);//加锁保护\n    return _generate_new_header(oid, parent);\n  }\n  \nDBObjectMap::Header DBObjectMap::lookup_create_map_header(\n  const MapHeaderLock &hl, \n  const ghobject_t &oid,\n  KeyValueDB::Transaction t)\n{\n  Mutex::Locker l(header_lock); // 加锁保护\n  Header header = _lookup_map_header(hl, oid);\n  if (!header) {\n    header = _generate_new_header(oid, Header());                                                                                                      \n    set_map_header(hl, oid, *header, t);\n  }\n  return header;\n} \n```\n\n### ceph-objectstore-tool 用法\n\n\n### rgw s3 属性\nrgw s3的额外属性：\n  - user\n  - bucket\n  - bucket.instance\n```go\n//<bucket>指bucket name; <marker>指bucker id; <user>指user id\n$ radosgw-admin metadata list\n$ radosgw-admin metadata list bucket\n$ radosgw-admin metadata list bucket.instance\n$ radosgw-admin metadata list user\n\n$ radosgw-admin metadata get bucket:<bucket>\n$ radosgw-admin metadata get bucket.instance:<bucket>:<marker>\n$ radosgw-admin metadata get user:<user>   # get or set\n```\n\nuser 数据被以<user>作为object name存储在default.rgw.meta pool中，其中namespace是user uid\nbucket 数据以<bucket>作为object name存储在default.rgw.meta pool, 其中namespace：root\n\nbucket.instance 数据以.bucket.meta.<bucket>:<marker>作为 object name存储在default.rgw.meta pool中，其namespace是root。\n\n#### bucket属性\n```go\nradosgw-admin bucket stats --bucket=test\n{\n    \"bucket\": \"test\",\n    \"pool\": \".rgw.buckets.zj-1\",\n    \"index_pool\": \".rgw.buckets.index\",\n    \"id\": \"default.784974.1\",\n    \"marker\": \"default.784974.1\",\n    \"owner\": \"user-1\",\n    \"ver\": \"0#1901\",\n    \"master_ver\": \"0#0\",\n    \"mtime\": \"2015-04-07 16:23:23.000000\",\n    \"max_marker\": \"0#\",\n    \"usage\": {\n        \"rgw.main\": {\n            \"size_kb\": 1048870,\n            \"size_kb_actual\": 1048908,\n            \"num_objects\": 17\n        }\n    },\n    \"bucket_quota\": {\n        \"enabled\": false,\n        \"max_size_kb\": -1,\n        \"max_objects\": -1\n    }\n}\n```\nbucket的名称，所在的data pool, index pool, bucket id\n```c++\n    bucket_id\n      - zone_name     -->   default\n      - instance_id   -->   784974\n      - bucket id     -->   1\n```\n#### bucket index 属性\n```go\nrados -p .rgw.buckets.index ls - | grep \"default.784974.1\"\n.dir.default.784974.1\n```\nbucket index object 名称为： .dir.{buckt id}\n\n#### 查看index 的keys\n```c++\n# rados -p .rgw.buckets.index listomapkeys .dir.default.784974.1\n/demo/region.conf.json\n```\n\n### rgw_max_chunk_size & rgw_obj_stripe_size\n\n- rgw_max_chunk_size : default: (524388) 512k\n  - RadosGW下发到RADOS集群的单个IO的大小\n  - 当写入的对象大小大于rgw_max_chunk_size:\n    + rados层的一个对象，大小为实际大小；\n    + rados层的命名： {bucket_id}_{对象文件的名字}\n  - 当写入的对象大小大于rgw_max_chunk_size:\n    + 分成多种对象存储，\n      1、首对象（head_obj) 大小为rgw_max_chunk_size\n      2、中间对象： 大小为rgw_obj_stripe_size\n      3、尾对象：   小于或等于rgw_obj_stripe_size\n    + 其它的对象按照rgw_obj_stripe_size切分成多个obj存入rados\n    + head object命名规则： {bucket_id}_{对象文件的名字}\n    + 中间对象、尾对象命名：{bucket_id}_shadow_{长度为32的随机字符}_{条带编号, 从1起}\n    + head_obj需要将中间对象、尾对象关联起来：\n    ```c++\n    # rados -p .rgw.buckets listxattr default.ubuntu12.04.iso\n    user.rgw.acl\n    user.rgw.content_type\n    user.rgw.etag\n    user.rgw.idtag\n    user.rgw.manifest\n    user.rgw.x-amz-date\n\n    rados -p .rgw.buckets getxattr  default.11383165.2_scaler.iso  user.rgw.manifest  > /root/scaler.iso.manifest\n\n# ceph-dencoder type RGWObjManifest import /root/ubuntu12.iso.manifest decode dump_json\n{\n    \"objs\": [],\n    \"obj_size\": 2842374144,     <-----------------对象文件大小\n    \"explicit_objs\": \"false\",\n    \"head_obj\": {\n        \"bucket\": {\n            \"name\": \"bean_book\",\n            \"pool\": \".rgw.buckets\",\n            \"data_extra_pool\": \".rgw.buckets.extra\",\n            \"index_pool\": \".rgw.buckets.index\",\n            \"marker\": \"default.11383165.2\",\n            \"bucket_id\": \"default.11383165.2\"\n        },\n        \"key\": \"\",\n        \"ns\": \"\",\n        \"object\": \"scaler.iso\",         <-----对象名\n        \"instance\": \"\"\n    },\n    \"head_size\": 524288,\n    \"max_head_size\": 524288,\n    \"prefix\": \".mGwYpWb3FXieaaaDNdaPzfs546ysNnT_\",  <---中间对象和尾对象的随机前缀\n    \"tail_bucket\": {\n        \"name\": \"bean_book\",\n        \"pool\": \".rgw.buckets\",\n        \"data_extra_pool\": \".rgw.buckets.extra\",\n        \"index_pool\": \".rgw.buckets.index\",\n        \"marker\": \"default.11383165.2\",\n        \"bucket_id\": \"default.11383165.2\"\n    },\n    \"rules\": [\n        {\n            \"key\": 0,\n            \"val\": {\n                \"start_part_num\": 0,\n                \"start_ofs\": 524288,\n                \"part_size\": 0,\n                \"stripe_max_size\": 4194304,\n                \"override_prefix\": \"\"\n            }\n        }\n    ]\n}\n    ```\n\n```c++\nclass RGWObjManifest{\nprotected:\n  \n\n}\n```\n","slug":"ceph_object_attr","published":1,"updated":"2018-12-25T11:13:36.228Z","_id":"cjq3l8d4l00015shaqc9zy2co","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"rados\"><a href=\"#rados\" class=\"headerlink\" title=\"rados\"></a>rados</h3><p>rados组织形式：</p>\n<ul>\n<li>pool<ul>\n<li>object<ul>\n<li>xattr<ul>\n<li>xfs文件属性</li>\n<li>omap</li>\n</ul>\n</li>\n<li>data<ul>\n<li>xfs文件内容<br>1、rados以pool来组织数据，pool中包含许多object<br>2、一个object包含两部分：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>存储对象的数据</li>\n<li>该对象的额外属性xattr<br>3、对象的额外属性可以有两个存储的部分：一个是ext4文件的属性部分，这部分往往受底层文件系统的约束，比如ext4文件系统要求其最大不超过4KB；另一个是rados实现的omap，rados使用一种机制，可以为每一个object关联一个omap<br>4、omap是一个key-value存储系统，最早是leveldb，当然也有其他选择，比如rocksdb。<br>5、FileStore的omap中存放的对视对象的属性信息，以key-value的形式存在，那么对于不同的属性，如何定义对象的键值key呢；<a id=\"more\"></a>\n### </li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//struct ghobject_t 底层文件系统中文件描述，name就对于的文件名</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">object_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">  <span class=\"keyword\">object_t</span>(): name(s) &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">object_t</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s): name(s)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">object_t</span>&amp; o)</span></span>&#123;</span><br><span class=\"line\">    name.swap(o.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    name.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist &amp;bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    ::encode(name, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator &amp;bl)</span></span>&#123;</span><br><span class=\"line\">    ::decode(name, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODER(<span class=\"keyword\">object_t</span>)</span><br></pre></td></tr></table></figure>\n<p>//struct sobject_t  </p>\n<ul>\n<li>添加了snapshot相关信息的object_t</li>\n<li>snap为该对象对于snapshot的snap号</li>\n<li>如果该对象不是快照，则snap字段设置为CEPH_NOSNAP，非snapshot对象也成为head对象 <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sobject_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">object_t</span> oid;</span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> snap;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">sobject_t</span>() : snap(<span class=\"number\">0</span>)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">sobject_t</span>(<span class=\"keyword\">object_t</span> o, <span class=\"keyword\">snapid_t</span> s) : oid(o), snap(s) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">sobject_t</span>&amp; o)</span></span>&#123;</span><br><span class=\"line\">    oid.swap(o.oid);</span><br><span class=\"line\">    <span class=\"keyword\">snapid_t</span> t = snap;</span><br><span class=\"line\">    snap = o.snap;</span><br><span class=\"line\">    o.snap = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    ::encode(oid, bl);</span><br><span class=\"line\">    ::encode(snap, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span> </span>&#123;</span><br><span class=\"line\">    ::decode(oid, bl);</span><br><span class=\"line\">    ::decode(snap, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODER(<span class=\"keyword\">sobject_t</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//hobject_t (hash object)</p>\n<ul>\n<li>object_t oid: 对象的名字</li>\n<li>snapid_t snap: 保存对象的snap</li>\n<li>int64_t pool: 该object所在pool的id</li>\n<li>string nspace： 一般为空</li>\n<li>string key： </li>\n<li>string hash： pg id<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hobject_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">object_t</span> oid;</span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> snap;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> hash;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> max;</span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> nibblewise_key_cache;</span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> hash_reverse_bits;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int64_t</span> POOL_META = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int64_t</span> POOL_TEMP_START = <span class=\"number\">-2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">spg_t</span>;</span>     <span class=\"comment\">// for POOL_TEMP_START</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int64_t</span> pool;</span><br><span class=\"line\">  <span class=\"built_in\">string</span>  nspace;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">string</span> key;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hobject_t_max</span> &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">get_key</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_key</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;key_)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(key_ == oid.name)</span><br><span class=\"line\">      key.clear();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      key = key_;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">to_str</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> get_hash() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_hash</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> value)</span></span>&#123;</span><br><span class=\"line\">    hash = value;</span><br><span class=\"line\">    build_hash_cache();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">match_hash</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> to_check, <span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> match)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (match &amp; ~((~<span class=\"number\">0</span>)&lt;&lt;bits)) == (to_check &amp; ~((~<span class=\"number\">0</span>)&lt;&lt;bits));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> match)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match_hash(hash, bits, match);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_temp</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pool &lt;= POOL_TEMP_START &amp;&amp; pool != INT64_MIN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ls_meta</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pool == POOL_META;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> : snap(<span class=\"number\">0</span>), hash(<span class=\"number\">0</span>), max(<span class=\"literal\">false</span>), pool(INT64_MIN)&#123;</span><br><span class=\"line\">    build_hash_cache();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span> &amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">hobject_t</span> &amp;&amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(hobject_t_max &amp;&amp;singleton) : <span class=\"keyword\">hobject_t</span>()&#123;</span><br><span class=\"line\">    max = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> &amp;<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span> &amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> &amp;<span class=\"keyword\">operator</span>-(<span class=\"keyword\">hobject_t</span> &amp;&amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> &amp;<span class=\"keyword\">operator</span>=(hobject_t_max &amp;&amp;singleton)&#123;</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> = <span class=\"keyword\">hobject_t</span>();</span><br><span class=\"line\">    max = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//maximum stored value.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> hobject_t_max <span class=\"title\">get_max</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobject_t_max();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">object_t</span> oid, <span class=\"keyword\">const</span> strings key, <span class=\"keyword\">snapid_t</span> snap, <span class=\"keyword\">uint32_t</span> hash, <span class=\"keyword\">int64_t</span> pool, <span class=\"built_in\">string</span> nspace): oid(oid), snap(snap), hash(hash), max(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    pool(pool), nspace(nspace), key(soid,oid.name == key ? <span class=\"built_in\">string</span>() : key)&#123;</span><br><span class=\"line\">      build_hash_cache();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// @return min hobject_t ret s.t. ret.hash == this-&gt;hash</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取边界</span></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_boundary() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (is_max())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret;</span><br><span class=\"line\">      ret.set_hash(hash);</span><br><span class=\"line\">      ret.pool = pool;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_object_boundary() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(is_max())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      ret.snap = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return head version of this hobject_t</span></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_head() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      ret.snap = CEPH_NOSANP;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return snapdir version of this hobject_t</span></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_snapdir() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      ret.snap = CEPH_SNAPDIR;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return true if object is head</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_head</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> snap == CEPH_NOSANP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return true if object is neither head nor snapdir nor max</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_snap</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> !is_max() &amp;&amp; !is_head() &amp;&amp; !is_snapdir();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return true if the object should have a snapset in it's attrs</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">has_snapset</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> is_head() || is_snapdir();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Do not use when a particular hash function is need</span></span><br><span class=\"line\">    explicit hobject_t(const sobject_t &amp;o) : oid(o.oid), snap(o.snap), max(false), pool(POOL_META) &#123;</span><br><span class=\"line\">      set_hash(<span class=\"built_in\">std</span>::hash&lt;<span class=\"keyword\">sobject_t</span>&gt;()(o));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_max</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      assert(!max ||(*<span class=\"keyword\">this</span> == <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">hobject_t</span>::get_max())));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_min</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//this needs to match how it's constructed</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> snap==<span class=\"number\">0</span> &amp;&amp;hash==<span class=\"number\">0</span> &amp;&amp; !max &amp;&amp; pool==INT64_MIN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> _reverse_bits(<span class=\"keyword\">uint32_t</span> v)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> reverse_bits(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> _reverse_nibbles(<span class=\"keyword\">uint32_t</span> retval)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _reverse_nibbles(retval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns set S of strings such that for any object h.match(bits, mask), t</span></span><br><span class=\"line\"><span class=\"comment\">     * there is some string s\\f$in\\f$ S such thats is a prefix of h.to_str().</span></span><br><span class=\"line\"><span class=\"comment\">     * Furthermore, for any s $f\\in\\f$ S, s is a prefix of h.str() implies *</span></span><br><span class=\"line\"><span class=\"comment\">     * that h.match(bits, mask).</span></span><br><span class=\"line\"><span class=\"comment\">     **/</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; get_prefixes(<span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> mask, <span class=\"keyword\">int64_t</span> pool)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">uint32_t</span> len = bits;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(len % <span class=\"number\">4</span> <span class=\"comment\">/* nibbles */</span>) len++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt; from;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bits &lt; <span class=\"number\">32</span>)</span><br><span class=\"line\">        from.insert(mask &amp; ~((<span class=\"keyword\">uint32_t</span>)(~<span class=\"number\">0</span>) &lt;&lt; bits));</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(bits == <span class=\"number\">32</span>)</span><br><span class=\"line\">        from.insert(mask);</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        ceph_abort();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt; to;</span><br><span class=\"line\">      fro(<span class=\"keyword\">uint32_t</span> i=bits; i&lt;len; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;::iterator j=from.begin(); j!=from.end(); ++j)&#123;</span><br><span class=\"line\">          to.insert(*j | (<span class=\"number\">1U</span>&lt;&lt;i));</span><br><span class=\"line\">          to.insert(*j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        to.swap(from);</span><br><span class=\"line\">        to.clear();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">char</span> buf[<span class=\"number\">20</span>];</span><br><span class=\"line\">      <span class=\"keyword\">char</span> *t = buf;</span><br><span class=\"line\">      <span class=\"keyword\">uint64_t</span> poolid(pool);</span><br><span class=\"line\"></span><br><span class=\"line\">      t += <span class=\"built_in\">snprintf</span>(t, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">\"%.*llX\"</span>, <span class=\"number\">16</span>, (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"keyword\">unsigned</span>)poolid);</span><br><span class=\"line\">      *(t++) = <span class=\"string\">'.'</span></span><br><span class=\"line\">      <span class=\"built_in\">string</span> poolstr(buf, t - buf);</span><br><span class=\"line\">      <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;::iterator i=from.begin(); i != from.end(); ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> revhash(<span class=\"keyword\">hobject_t</span>::_reverse_nibbles(*i));</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">\"%.*X\"</span>, (<span class=\"keyword\">int</span>)(<span class=\"keyword\">sizeof</span>(revhash))*<span class=\"number\">2</span>, revhash);</span><br><span class=\"line\">        ret.insert(poolstr + <span class=\"built_in\">string</span>(buf, len/<span class=\"number\">4</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//filestore nibble-based key</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> get_nibblewise_key_u32()  <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      assert(!max);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nibblewise_key_cache;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> get_nibblewise_key()  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max ? <span class=\"number\">0x100000000</span>ull : nibblewise_key_cache;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// newer bit-reversed key</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> get_bitwise_key_u32() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      assert(!max);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> hash_reverse_bits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> get_bitwise_key() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max ? <span class=\"number\">0x100000000</span>ull : hash_reverse_bits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//please remeber to update set_bitwise_key_u32() also</span></span><br><span class=\"line\">    <span class=\"comment\">//once you change build_hash_cache()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_hash_cache</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      nibblewise_key_cache = _reverse_nibbles(hash);</span><br><span class=\"line\">      hash_reverse_bits = _reverse_bits(hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_bitwise_key_u32</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> value)</span></span>&#123;</span><br><span class=\"line\">      hash = _reverse_bits(value);</span><br><span class=\"line\">      <span class=\"comment\">//below is identical to build_hash_cache() and shall be</span></span><br><span class=\"line\">      <span class=\"comment\">//updated correspondingly if you change build_hash_cache()</span></span><br><span class=\"line\">      nibblewise_key_cache = _reverse_nibbles(hash);</span><br><span class=\"line\">      hash_reverse_bits = values;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">get_effective_key</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(key.length())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oid.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> make_temp_hobject(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; name) <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">object_t</span>(name), <span class=\"string\">\"\"</span>, CEPH_NOSANP, hash, <span class=\"keyword\">hobject_t</span>::POOL_TEMP_START - pool, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">hobject_t</span> &amp;o)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> temp(o);</span><br><span class=\"line\">      o = (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      (*<span class=\"keyword\">this</span>) = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">get_namespace</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> nspace;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">parse</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(json_spirit::Value&amp; v)</span></span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter *f)</span> <span class=\"keyword\">const</span></span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;<span class=\"keyword\">hobject_t</span>*&gt;&amp; o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> cmp(l, r) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cmp(l, r) &gt;=<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cmp(l, r) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123;     </span><br><span class=\"line\">      <span class=\"keyword\">return</span> cmp(l, r) &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;); </span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;);</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ghobject_t</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODE(<span class=\"keyword\">hboject_t</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//ghobject_t</p>\n<ul>\n<li>在hobjec_t基础上，添加了generation 字段 和 shard_id 字段; 主要用于EC的rollback</li>\n<li>副本模式下， shard_id设置为NO_SHARD(-1), 这两个字段是无效的；<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ghobject_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">hboject_t</span> hobj;</span><br><span class=\"line\">  <span class=\"keyword\">gen_t</span> generation;</span><br><span class=\"line\">  <span class=\"keyword\">shard_id_t</span> shard_id;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> max;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">gen_t</span> NO_GEN=UINT64_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">ghobject_t</span>(): generation(NO_GEN), shard_id(<span class=\"keyword\">shard_id_t</span>::NO_SHARD), max(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\">  explicit ghobject_t(const hobject_t &amp;obj) : hobj(obj), generation(NO_GEN),</span><br><span class=\"line\">    shard_id(<span class=\"keyword\">shard_id_t</span>::NO_SHARD), max(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">ghobject_t</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span> &amp;obj, <span class=\"keyword\">gen_t</span> gen, <span class=\"keyword\">shard_id_t</span> shard):</span><br><span class=\"line\">    hobj(obj), generation(gen), shard_id(shard), max(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ghobject_t <span class=\"title\">make_pgmeta</span><span class=\"params\">(<span class=\"keyword\">int64_t</span> pool, <span class=\"keyword\">uint32_t</span> hash, <span class=\"keyword\">shard_id_t</span> shard)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> h(<span class=\"keyword\">object_t</span>(), <span class=\"built_in\">string</span>(), CEPH_NOSANP, hash, pool, <span class=\"built_in\">string</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">ghobject_t</span>(h, NO_GEN, shard);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_pgmeta</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//make sure we are distinct from hobject_t(), which has pool INT64_MIN</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.pool &gt;= <span class=\"number\">0</span> &amp;&amp; hobj.oid,name.empty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> match)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.match_hash(hobj.hash, bits, match);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// @return min ghobject_t ret s.t. ret.hash == this-&gt;hash</span></span><br><span class=\"line\">  <span class=\"keyword\">ghobject_t</span> get_boundary() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(hobj.is_max())</span><br><span class=\"line\">      <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> ret;</span><br><span class=\"line\">    ret.hobj.set_hash(hobj.hash);</span><br><span class=\"line\">    ret.shard_id = shard_id;</span><br><span class=\"line\">    ret.hobj.pool = hobj.pool;</span><br><span class=\"line\">    retrun ret;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> get_nibblewise_key_u32() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.get_nibblewise_key_u32();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> get_nibblewise_key() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.get_nibblewise_key();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_degenerate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> generation == NO_GEN &amp;&amp; shard_id == shard_id::NO_SHARD;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_no_gen</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> generation == NO_GEN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_no_shard</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shard_id == <span class=\"keyword\">shard_id_t</span>::NO_SHARD;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_shard</span><span class=\"params\">(<span class=\"keyword\">shard_id_t</span> s)</span></span>&#123;</span><br><span class=\"line\">    shard_id = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">parse</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//maximum sorted value.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ghobject_t <span class=\"title\">get_max</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> h;</span><br><span class=\"line\">    h.max = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    h.hobj = <span class=\"keyword\">hobject_t</span>::get_max();  <span class=\"comment\">//so that is_max() =&gt; hobj.is_max()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_max</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_min</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span> == <span class=\"keyword\">ghobject_t</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">ghobject_t</span> &amp;o)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> temp(o)</span><br><span class=\"line\">    o = (*<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    (*<span class=\"keyword\">this</span>) = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(json_spirit::Value&amp; v)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> encoded_size() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter *f)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;<span class=\"keyword\">ghobject_t</span>*&gt;&amp; o)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;);</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODE(<span class=\"keyword\">ghobject_t</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最直观的感觉是object id + xattr key; 两者结合一起，形成对象的键值key，但存在一个弊端<br>object id可能很长，当个对象存在很多属性的时候，object id不得不在key中出现多次，这必然会造成存储空间的浪费。<br>Ceph的FileStore分成了2步，第一步根据object id生成一个比较短的seq，然后seq + xattr key形成对象的某个属性的键值。</p>\n<p>omap不是通过计算从object id 获取seq的，他是首先根据object id, 存放一个Header类型的<br>数据结构到LevelDB，其中Header中的一个成员变量为seq。</p>\n<ul>\n<li>key: USER_PREFIX + header_key(header-&gt;seq) + XATTR_PREFIX + key</li>\n<li>value: header</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  - key: HOBJECT_TO_SEQ +ghobject_key(oid)</span></span><br><span class=\"line\"><span class=\"comment\">  - value: header (struct _Header)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Header</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> seq;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> parent;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> num_children;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> oid;</span><br><span class=\"line\"></span><br><span class=\"line\">    SequencerPosition spos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">coll_t</span> unused;</span><br><span class=\"line\">      ENCODE_START(<span class=\"number\">2</span>, <span class=\"number\">1</span>, bl);</span><br><span class=\"line\">      ::encode(seq, bl);</span><br><span class=\"line\">      ::encode(parent, bl);</span><br><span class=\"line\">      ::encode(num_children, bl);</span><br><span class=\"line\">      ::encode(unused, bl);</span><br><span class=\"line\">      ::encode(oid, bl);</span><br><span class=\"line\">      ::encode(spos bl);</span><br><span class=\"line\">      ENCODE_FINISH(bl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">coll_t</span> unused;</span><br><span class=\"line\">      DECODE_START(<span class=\"number\">2</span>, bl);</span><br><span class=\"line\">      ::decode(seq, bl);</span><br><span class=\"line\">      ::decode(parent, bl);</span><br><span class=\"line\">      ::decode(num_children, bl);</span><br><span class=\"line\">      ::decode(unused, bl);</span><br><span class=\"line\">      ::decode(oid, bl);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (struct_v &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">        ::decode(spos, bl);</span><br><span class=\"line\">      DECODE_FINISH(bl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter *f)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      f-&gt;dump_unsigned(<span class=\"string\">\"seq\"</span>, seq);</span><br><span class=\"line\">      f-&gt;dump_unsigned(<span class=\"string\">\"parent\"</span>, parent);</span><br><span class=\"line\">      f-&gt;dump_unsigned(<span class=\"string\">\"num_children\"</span>, num_children);</span><br><span class=\"line\">      f-&gt;dump_stream(<span class=\"string\">\"oid\"</span>) &lt;&lt; oid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;_Header*&gt;&amp; o )</span></span>&#123;</span><br><span class=\"line\">      o.push_back(<span class=\"keyword\">new</span> _Header);</span><br><span class=\"line\">      o.push_back(<span class=\"keyword\">new</span> _Header);</span><br><span class=\"line\">      o.back()-&gt;parent = <span class=\"number\">20</span>;</span><br><span class=\"line\">      o.back()-&gt;seq = <span class=\"number\">30</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _Header() : seq(<span class=\"number\">0</span>), parent(<span class=\"number\">0</span>), num_children(<span class=\"number\">1</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果要获取某个对象的oid的某个属性的值，需要分成两步走:</p>\n<ul>\n<li>找到Header，从header中取出seq的值</li>\n<li>根据seq的值生成该属性对应的新的最终的键值，从LevelDB中取出value</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取对象oid的某个或者某几个属性的值</span></span><br><span class=\"line\"><span class=\"comment\">// os/filestore/DBObjectMap.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> DBObjectMap::get_xattrs(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; to_get, <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, bufferlist&gt;* out)&#123;</span><br><span class=\"line\">  <span class=\"function\">MapHeaderLock <span class=\"title\">hl</span><span class=\"params\">(<span class=\"keyword\">this</span>, oid)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//第一步根据oid找到header</span></span><br><span class=\"line\">  Header header = lookup_map_header(hl, oid);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!header)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据找到的header中的seq值，社会你刚才属性的键，在levelDB中找到对应key的value</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> db-get(xattr_prefix(header), to_get, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> DBObjectMap::set_xattrs(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, bufferlist&gt;&amp; to_set, <span class=\"keyword\">const</span> SequencerPosition *spos)&#123;</span><br><span class=\"line\">  KeyValueDB::Transaction t = db-&gt;get_transcation();</span><br><span class=\"line\">  <span class=\"function\">MapHeaderLock <span class=\"title\">hl</span><span class=\"params\">(<span class=\"keyword\">this</span>, oid)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">/*寻找oid对应的header，如若没有，则新建一个header*/</span></span><br><span class=\"line\">  Header header = lookup_create_map_header(hl, oid, t);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!header)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (check_spos(oid, header, spos))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*根据header中的seq，得到真正的键值，然后设置一个或者多个属性*/</span></span><br><span class=\"line\">  t-&gt;<span class=\"built_in\">set</span>(xattr_prefix(header), to_set);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> db-&gt;submit_transaction(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> DBObjectMap::USER_PREFIX = <span class=\"string\">\"__USER__\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> DBObjectMap::XATTR_PREFIX= <span class=\"string\">\"__AXATTR__\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> DBObjectMap::header_key(<span class=\"keyword\">uint64_t</span> seq)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">  <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">\"%.*\"</span> PRId64, (<span class=\"keyword\">int</span>)(<span class=\"number\">2</span>*<span class=\"keyword\">sizeof</span>(seq)), seq);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">string</span>(buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> DBObjectMap::xattr_prefix(Header header)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> USER_PREFIX + header_key(header-&gt;seq) + XATTR_PREFIX;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"seq-生成过程\"><a href=\"#seq-生成过程\" class=\"headerlink\" title=\"seq 生成过程\"></a>seq 生成过程</h3><ul>\n<li>LevelDB中存放着一个特殊的全局意义的key-value</li>\n<li>key: SYS_PREFIX + GLOBAL_STATE_KEY </li>\n<li>value: State  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// peersistent state for store @see generate_header</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">State</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> _u8 CUR_VERSION = <span class=\"number\">3</span>;</span><br><span class=\"line\">  __u8 v;</span><br><span class=\"line\">  <span class=\"keyword\">uint64_t</span> seq;</span><br><span class=\"line\">  <span class=\"comment\">// legacy is false when complete regions never used</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> legacy;</span><br><span class=\"line\"></span><br><span class=\"line\">  State() : v(<span class=\"number\">0</span>), seq(<span class=\"number\">1</span>), legacy(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\">  explicit State(uint64_t seq) : v(0), seq(seq), legacy(false)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    ENCODE_START(<span class=\"number\">3</span>, <span class=\"number\">1</span>, bl);</span><br><span class=\"line\">    ::encode(v, bl);</span><br><span class=\"line\">    ::encode(seq, bl);</span><br><span class=\"line\">    ::encode(legacy, bl);</span><br><span class=\"line\">    ENCODE_FINISH(bl);    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator &amp;bl)</span></span>&#123;</span><br><span class=\"line\">    DECODE_START(<span class=\"number\">3</span>, bl);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (struct_v &gt;=<span class=\"number\">2</span>)</span><br><span class=\"line\">      ::decode(v, bl);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ::decode(seq, bl);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(struct_v &gt;=<span class=\"number\">3</span>)</span><br><span class=\"line\">      ::decode(legacy, bl);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      legacy = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    DECODE_FINISH(bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter* f)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    f-&gt;dump_unsigned(<span class=\"string\">\"v\"</span>, v);</span><br><span class=\"line\">    f-&gt;dump_unsigned(<span class=\"string\">\"seq\"</span>, seq);</span><br><span class=\"line\">    f-&gt;dump_unsigned(<span class=\"string\">\"legacy\"</span>, legacy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;State*&gt;&amp; o)</span></span>&#123;</span><br><span class=\"line\">    o.push_back(<span class=\"keyword\">new</span> State(<span class=\"number\">0</span>));</span><br><span class=\"line\">    o.push_back(<span class=\"keyword\">new</span> State(<span class=\"number\">20</span>));</span><br><span class=\"line\">  &#125; state;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>该结构体只有一个成员变量，即seq，当产生新的Header的时候，会该值会递增，写入LevelDB</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBObjectMap::Header DBObjectMap::_generate_new_header(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; oid, Header parent)&#123;</span><br><span class=\"line\">  Header header = Header(<span class=\"keyword\">new</span> _Header(), RemoveOnDelete(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  header-&gt;seq = state.seq++;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent)&#123;</span><br><span class=\"line\">    header-&gt;parent =  parent-&gt;seq;</span><br><span class=\"line\">    header-&gt;spos = parent-&gt;spos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  header-&gt;num_children = <span class=\"number\">1</span>;</span><br><span class=\"line\">  header-&gt;oid = oid;</span><br><span class=\"line\">  assert(!in_use.count(header-&gt;seq));</span><br><span class=\"line\">  in_use.insert(header-&gt;seq);</span><br><span class=\"line\"></span><br><span class=\"line\">  write_state();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> header;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为是全局的，为了防止竞争，需要加锁保护。</span></span><br><span class=\"line\"><span class=\"function\">Header <span class=\"title\">generate_new_header</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span> &amp;oid, Header parent)</span> </span>&#123;</span><br><span class=\"line\">    Mutex::<span class=\"function\">Locker <span class=\"title\">l</span><span class=\"params\">(header_lock)</span></span>;<span class=\"comment\">//加锁保护</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _generate_new_header(oid, parent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">DBObjectMap::Header DBObjectMap::lookup_create_map_header(</span><br><span class=\"line\">  <span class=\"keyword\">const</span> MapHeaderLock &amp;hl, </span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span> &amp;oid,</span><br><span class=\"line\">  KeyValueDB::Transaction t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Mutex::<span class=\"function\">Locker <span class=\"title\">l</span><span class=\"params\">(header_lock)</span></span>; <span class=\"comment\">// 加锁保护</span></span><br><span class=\"line\">  Header header = _lookup_map_header(hl, oid);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!header) &#123;</span><br><span class=\"line\">    header = _generate_new_header(oid, Header());                                                                                                      </span><br><span class=\"line\">    set_map_header(hl, oid, *header, t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> header;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ceph-objectstore-tool-用法\"><a href=\"#ceph-objectstore-tool-用法\" class=\"headerlink\" title=\"ceph-objectstore-tool 用法\"></a>ceph-objectstore-tool 用法</h3><h3 id=\"rgw-s3-属性\"><a href=\"#rgw-s3-属性\" class=\"headerlink\" title=\"rgw s3 属性\"></a>rgw s3 属性</h3><p>rgw s3的额外属性：</p>\n<ul>\n<li>user</li>\n<li>bucket</li>\n<li>bucket.instance<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//&lt;bucket&gt;指bucket name; &lt;marker&gt;指bucker id; &lt;user&gt;指user id</span></span><br><span class=\"line\">$ radosgw-admin metadata list</span><br><span class=\"line\">$ radosgw-admin metadata list bucket</span><br><span class=\"line\">$ radosgw-admin metadata list bucket.instance</span><br><span class=\"line\">$ radosgw-admin metadata list user</span><br><span class=\"line\"></span><br><span class=\"line\">$ radosgw-admin metadata get bucket:&lt;bucket&gt;</span><br><span class=\"line\">$ radosgw-admin metadata get bucket.instance:&lt;bucket&gt;:&lt;marker&gt;</span><br><span class=\"line\">$ radosgw-admin metadata get user:&lt;user&gt;   # get or set</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>user 数据被以<user>作为object name存储在default.rgw.meta pool中，其中namespace是user uid<br>bucket 数据以<bucket>作为object name存储在default.rgw.meta pool, 其中namespace：root</bucket></user></p>\n<p>bucket.instance 数据以.bucket.meta.<bucket>:<marker>作为 object name存储在default.rgw.meta pool中，其namespace是root。</marker></bucket></p>\n<h4 id=\"bucket属性\"><a href=\"#bucket属性\" class=\"headerlink\" title=\"bucket属性\"></a>bucket属性</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">radosgw-admin bucket stats --bucket=test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"bucket\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pool\"</span>: <span class=\"string\">\".rgw.buckets.zj-1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"index_pool\"</span>: <span class=\"string\">\".rgw.buckets.index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>: <span class=\"string\">\"default.784974.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"marker\"</span>: <span class=\"string\">\"default.784974.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"owner\"</span>: <span class=\"string\">\"user-1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"ver\"</span>: <span class=\"string\">\"0#1901\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"master_ver\"</span>: <span class=\"string\">\"0#0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"mtime\"</span>: <span class=\"string\">\"2015-04-07 16:23:23.000000\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"max_marker\"</span>: <span class=\"string\">\"0#\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"usage\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"rgw.main\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"size_kb\"</span>: <span class=\"number\">1048870</span>,</span><br><span class=\"line\">            <span class=\"string\">\"size_kb_actual\"</span>: <span class=\"number\">1048908</span>,</span><br><span class=\"line\">            <span class=\"string\">\"num_objects\"</span>: <span class=\"number\">17</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"bucket_quota\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"enabled\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"max_size_kb\"</span>: <span class=\"number\">-1</span>,</span><br><span class=\"line\">        <span class=\"string\">\"max_objects\"</span>: <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bucket的名称，所在的data pool, index pool, bucket id<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bucket_id</span><br><span class=\"line\">  - zone_name     --&gt;   <span class=\"keyword\">default</span></span><br><span class=\"line\">  - instance_id   --&gt;   <span class=\"number\">784974</span></span><br><span class=\"line\">  - bucket id     --&gt;   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"bucket-index-属性\"><a href=\"#bucket-index-属性\" class=\"headerlink\" title=\"bucket index 属性\"></a>bucket index 属性</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rados -p .rgw.buckets.index ls - | grep <span class=\"string\">\"default.784974.1\"</span></span><br><span class=\"line\">.dir.<span class=\"keyword\">default</span><span class=\"number\">.784974</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n<p>bucket index object 名称为： .dir.{buckt id}</p>\n<h4 id=\"查看index-的keys\"><a href=\"#查看index-的keys\" class=\"headerlink\" title=\"查看index 的keys\"></a>查看index 的keys</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># rados -p .rgw.buckets.index listomapkeys .dir.default.784974.1</span></span><br><span class=\"line\">/demo/region.conf.json</span><br></pre></td></tr></table></figure>\n<h3 id=\"rgw-max-chunk-size-amp-rgw-obj-stripe-size\"><a href=\"#rgw-max-chunk-size-amp-rgw-obj-stripe-size\" class=\"headerlink\" title=\"rgw_max_chunk_size &amp; rgw_obj_stripe_size\"></a>rgw_max_chunk_size &amp; rgw_obj_stripe_size</h3><ul>\n<li>rgw_max_chunk_size : default: (524388) 512k<ul>\n<li>RadosGW下发到RADOS集群的单个IO的大小</li>\n<li>当写入的对象大小大于rgw_max_chunk_size:<ul>\n<li>rados层的一个对象，大小为实际大小；</li>\n<li>rados层的命名： {bucket_id}_{对象文件的名字}</li>\n</ul>\n</li>\n<li>当写入的对象大小大于rgw_max_chunk_size:<ul>\n<li>分成多种对象存储，<br>1、首对象（head_obj) 大小为rgw_max_chunk_size<br>2、中间对象： 大小为rgw_obj_stripe_size<br>3、尾对象：   小于或等于rgw_obj_stripe_size</li>\n<li>其它的对象按照rgw_obj_stripe_size切分成多个obj存入rados</li>\n<li>head object命名规则： {bucket_id}_{对象文件的名字}</li>\n<li>中间对象、尾对象命名：{bucket_id}<em>shadow</em>{长度为32的随机字符}_{条带编号, 从1起}</li>\n<li>head_obj需要将中间对象、尾对象关联起来：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\"># rados -p .rgw.buckets listxattr default.ubuntu12.04.iso</span></span><br><span class=\"line\">    user.rgw.acl</span><br><span class=\"line\">    user.rgw.content_type</span><br><span class=\"line\">    user.rgw.etag</span><br><span class=\"line\">    user.rgw.idtag</span><br><span class=\"line\">    user.rgw.manifest</span><br><span class=\"line\">    user.rgw.x-amz-date</span><br><span class=\"line\"></span><br><span class=\"line\">    rados -p .rgw.buckets getxattr  <span class=\"keyword\">default</span><span class=\"number\">.11383165</span><span class=\"number\">.2</span>_scaler.iso  user.rgw.manifest  &gt; /root/scaler.iso.manifest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># ceph-dencoder type RGWObjManifest import /root/ubuntu12.iso.manifest decode dump_json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"objs\"</span>: [],</span><br><span class=\"line\">    <span class=\"string\">\"obj_size\"</span>: <span class=\"number\">2842374144</span>,     &lt;-----------------对象文件大小</span><br><span class=\"line\">    <span class=\"string\">\"explicit_objs\"</span>: <span class=\"string\">\"false\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"head_obj\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"bucket\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"name\"</span>: <span class=\"string\">\"bean_book\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"pool\"</span>: <span class=\"string\">\".rgw.buckets\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"data_extra_pool\"</span>: <span class=\"string\">\".rgw.buckets.extra\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"index_pool\"</span>: <span class=\"string\">\".rgw.buckets.index\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"marker\"</span>: <span class=\"string\">\"default.11383165.2\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"bucket_id\"</span>: <span class=\"string\">\"default.11383165.2\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"key\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ns\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"object\"</span>: <span class=\"string\">\"scaler.iso\"</span>,         &lt;-----对象名</span><br><span class=\"line\">        <span class=\"string\">\"instance\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"head_size\"</span>: <span class=\"number\">524288</span>,</span><br><span class=\"line\">    <span class=\"string\">\"max_head_size\"</span>: <span class=\"number\">524288</span>,</span><br><span class=\"line\">    <span class=\"string\">\"prefix\"</span>: <span class=\"string\">\".mGwYpWb3FXieaaaDNdaPzfs546ysNnT_\"</span>,  &lt;---中间对象和尾对象的随机前缀</span><br><span class=\"line\">    <span class=\"string\">\"tail_bucket\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"bean_book\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"pool\"</span>: <span class=\"string\">\".rgw.buckets\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"data_extra_pool\"</span>: <span class=\"string\">\".rgw.buckets.extra\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"index_pool\"</span>: <span class=\"string\">\".rgw.buckets.index\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"marker\"</span>: <span class=\"string\">\"default.11383165.2\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"bucket_id\"</span>: <span class=\"string\">\"default.11383165.2\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"string\">\"val\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"start_part_num\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"start_ofs\"</span>: <span class=\"number\">524288</span>,</span><br><span class=\"line\">                <span class=\"string\">\"part_size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"stripe_max_size\"</span>: <span class=\"number\">4194304</span>,</span><br><span class=\"line\">                <span class=\"string\">\"override_prefix\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RGWObjManifest</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"rados\"><a href=\"#rados\" class=\"headerlink\" title=\"rados\"></a>rados</h3><p>rados组织形式：</p>\n<ul>\n<li>pool<ul>\n<li>object<ul>\n<li>xattr<ul>\n<li>xfs文件属性</li>\n<li>omap</li>\n</ul>\n</li>\n<li>data<ul>\n<li>xfs文件内容<br>1、rados以pool来组织数据，pool中包含许多object<br>2、一个object包含两部分：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>存储对象的数据</li>\n<li>该对象的额外属性xattr<br>3、对象的额外属性可以有两个存储的部分：一个是ext4文件的属性部分，这部分往往受底层文件系统的约束，比如ext4文件系统要求其最大不超过4KB；另一个是rados实现的omap，rados使用一种机制，可以为每一个object关联一个omap<br>4、omap是一个key-value存储系统，最早是leveldb，当然也有其他选择，比如rocksdb。<br>5、FileStore的omap中存放的对视对象的属性信息，以key-value的形式存在，那么对于不同的属性，如何定义对象的键值key呢；","more":"### </li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//struct ghobject_t 底层文件系统中文件描述，name就对于的文件名</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">object_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">  <span class=\"keyword\">object_t</span>(): name(s) &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">object_t</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s): name(s)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">object_t</span>&amp; o)</span></span>&#123;</span><br><span class=\"line\">    name.swap(o.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    name.clear();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist &amp;bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    ::encode(name, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator &amp;bl)</span></span>&#123;</span><br><span class=\"line\">    ::decode(name, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODER(<span class=\"keyword\">object_t</span>)</span><br></pre></td></tr></table></figure>\n<p>//struct sobject_t  </p>\n<ul>\n<li>添加了snapshot相关信息的object_t</li>\n<li>snap为该对象对于snapshot的snap号</li>\n<li>如果该对象不是快照，则snap字段设置为CEPH_NOSNAP，非snapshot对象也成为head对象 <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sobject_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">object_t</span> oid;</span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> snap;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">sobject_t</span>() : snap(<span class=\"number\">0</span>)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">sobject_t</span>(<span class=\"keyword\">object_t</span> o, <span class=\"keyword\">snapid_t</span> s) : oid(o), snap(s) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">sobject_t</span>&amp; o)</span></span>&#123;</span><br><span class=\"line\">    oid.swap(o.oid);</span><br><span class=\"line\">    <span class=\"keyword\">snapid_t</span> t = snap;</span><br><span class=\"line\">    snap = o.snap;</span><br><span class=\"line\">    o.snap = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    ::encode(oid, bl);</span><br><span class=\"line\">    ::encode(snap, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span> </span>&#123;</span><br><span class=\"line\">    ::decode(oid, bl);</span><br><span class=\"line\">    ::decode(snap, bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODER(<span class=\"keyword\">sobject_t</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//hobject_t (hash object)</p>\n<ul>\n<li>object_t oid: 对象的名字</li>\n<li>snapid_t snap: 保存对象的snap</li>\n<li>int64_t pool: 该object所在pool的id</li>\n<li>string nspace： 一般为空</li>\n<li>string key： </li>\n<li>string hash： pg id<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hobject_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">object_t</span> oid;</span><br><span class=\"line\">  <span class=\"keyword\">snapid_t</span> snap;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> hash;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> max;</span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> nibblewise_key_cache;</span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> hash_reverse_bits;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int64_t</span> POOL_META = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int64_t</span> POOL_TEMP_START = <span class=\"number\">-2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">spg_t</span>;</span>     <span class=\"comment\">// for POOL_TEMP_START</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int64_t</span> pool;</span><br><span class=\"line\">  <span class=\"built_in\">string</span>  nspace;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">string</span> key;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hobject_t_max</span> &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">get_key</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_key</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;key_)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(key_ == oid.name)</span><br><span class=\"line\">      key.clear();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      key = key_;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">to_str</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> get_hash() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_hash</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> value)</span></span>&#123;</span><br><span class=\"line\">    hash = value;</span><br><span class=\"line\">    build_hash_cache();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">match_hash</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> to_check, <span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> match)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (match &amp; ~((~<span class=\"number\">0</span>)&lt;&lt;bits)) == (to_check &amp; ~((~<span class=\"number\">0</span>)&lt;&lt;bits));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> match)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match_hash(hash, bits, match);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_temp</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pool &lt;= POOL_TEMP_START &amp;&amp; pool != INT64_MIN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ls_meta</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pool == POOL_META;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> : snap(<span class=\"number\">0</span>), hash(<span class=\"number\">0</span>), max(<span class=\"literal\">false</span>), pool(INT64_MIN)&#123;</span><br><span class=\"line\">    build_hash_cache();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span> &amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">hobject_t</span> &amp;&amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(hobject_t_max &amp;&amp;singleton) : <span class=\"keyword\">hobject_t</span>()&#123;</span><br><span class=\"line\">    max = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> &amp;<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span> &amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> &amp;<span class=\"keyword\">operator</span>-(<span class=\"keyword\">hobject_t</span> &amp;&amp;rhs) = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span> &amp;<span class=\"keyword\">operator</span>=(hobject_t_max &amp;&amp;singleton)&#123;</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> = <span class=\"keyword\">hobject_t</span>();</span><br><span class=\"line\">    max = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//maximum stored value.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> hobject_t_max <span class=\"title\">get_max</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobject_t_max();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">object_t</span> oid, <span class=\"keyword\">const</span> strings key, <span class=\"keyword\">snapid_t</span> snap, <span class=\"keyword\">uint32_t</span> hash, <span class=\"keyword\">int64_t</span> pool, <span class=\"built_in\">string</span> nspace): oid(oid), snap(snap), hash(hash), max(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    pool(pool), nspace(nspace), key(soid,oid.name == key ? <span class=\"built_in\">string</span>() : key)&#123;</span><br><span class=\"line\">      build_hash_cache();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// @return min hobject_t ret s.t. ret.hash == this-&gt;hash</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取边界</span></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_boundary() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (is_max())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret;</span><br><span class=\"line\">      ret.set_hash(hash);</span><br><span class=\"line\">      ret.pool = pool;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_object_boundary() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(is_max())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">      ret.snap = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return head version of this hobject_t</span></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_head() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      ret.snap = CEPH_NOSANP;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return snapdir version of this hobject_t</span></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> get_snapdir() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> ret(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      ret.snap = CEPH_SNAPDIR;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return true if object is head</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_head</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> snap == CEPH_NOSANP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return true if object is neither head nor snapdir nor max</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_snap</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> !is_max() &amp;&amp; !is_head() &amp;&amp; !is_snapdir();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">///@return true if the object should have a snapset in it's attrs</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">has_snapset</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> is_head() || is_snapdir();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Do not use when a particular hash function is need</span></span><br><span class=\"line\">    explicit hobject_t(const sobject_t &amp;o) : oid(o.oid), snap(o.snap), max(false), pool(POOL_META) &#123;</span><br><span class=\"line\">      set_hash(<span class=\"built_in\">std</span>::hash&lt;<span class=\"keyword\">sobject_t</span>&gt;()(o));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_max</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      assert(!max ||(*<span class=\"keyword\">this</span> == <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">hobject_t</span>::get_max())));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_min</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//this needs to match how it's constructed</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> snap==<span class=\"number\">0</span> &amp;&amp;hash==<span class=\"number\">0</span> &amp;&amp; !max &amp;&amp; pool==INT64_MIN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> _reverse_bits(<span class=\"keyword\">uint32_t</span> v)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> reverse_bits(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> _reverse_nibbles(<span class=\"keyword\">uint32_t</span> retval)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _reverse_nibbles(retval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns set S of strings such that for any object h.match(bits, mask), t</span></span><br><span class=\"line\"><span class=\"comment\">     * there is some string s\\f$in\\f$ S such thats is a prefix of h.to_str().</span></span><br><span class=\"line\"><span class=\"comment\">     * Furthermore, for any s $f\\in\\f$ S, s is a prefix of h.str() implies *</span></span><br><span class=\"line\"><span class=\"comment\">     * that h.match(bits, mask).</span></span><br><span class=\"line\"><span class=\"comment\">     **/</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; get_prefixes(<span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> mask, <span class=\"keyword\">int64_t</span> pool)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">uint32_t</span> len = bits;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(len % <span class=\"number\">4</span> <span class=\"comment\">/* nibbles */</span>) len++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt; from;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bits &lt; <span class=\"number\">32</span>)</span><br><span class=\"line\">        from.insert(mask &amp; ~((<span class=\"keyword\">uint32_t</span>)(~<span class=\"number\">0</span>) &lt;&lt; bits));</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(bits == <span class=\"number\">32</span>)</span><br><span class=\"line\">        from.insert(mask);</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        ceph_abort();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt; to;</span><br><span class=\"line\">      fro(<span class=\"keyword\">uint32_t</span> i=bits; i&lt;len; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;::iterator j=from.begin(); j!=from.end(); ++j)&#123;</span><br><span class=\"line\">          to.insert(*j | (<span class=\"number\">1U</span>&lt;&lt;i));</span><br><span class=\"line\">          to.insert(*j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        to.swap(from);</span><br><span class=\"line\">        to.clear();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">char</span> buf[<span class=\"number\">20</span>];</span><br><span class=\"line\">      <span class=\"keyword\">char</span> *t = buf;</span><br><span class=\"line\">      <span class=\"keyword\">uint64_t</span> poolid(pool);</span><br><span class=\"line\"></span><br><span class=\"line\">      t += <span class=\"built_in\">snprintf</span>(t, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">\"%.*llX\"</span>, <span class=\"number\">16</span>, (<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"keyword\">unsigned</span>)poolid);</span><br><span class=\"line\">      *(t++) = <span class=\"string\">'.'</span></span><br><span class=\"line\">      <span class=\"built_in\">string</span> poolstr(buf, t - buf);</span><br><span class=\"line\">      <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; ret;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">uint32_t</span>&gt;::iterator i=from.begin(); i != from.end(); ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> revhash(<span class=\"keyword\">hobject_t</span>::_reverse_nibbles(*i));</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">\"%.*X\"</span>, (<span class=\"keyword\">int</span>)(<span class=\"keyword\">sizeof</span>(revhash))*<span class=\"number\">2</span>, revhash);</span><br><span class=\"line\">        ret.insert(poolstr + <span class=\"built_in\">string</span>(buf, len/<span class=\"number\">4</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//filestore nibble-based key</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> get_nibblewise_key_u32()  <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      assert(!max);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nibblewise_key_cache;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> get_nibblewise_key()  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max ? <span class=\"number\">0x100000000</span>ull : nibblewise_key_cache;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// newer bit-reversed key</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> get_bitwise_key_u32() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      assert(!max);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> hash_reverse_bits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> get_bitwise_key() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max ? <span class=\"number\">0x100000000</span>ull : hash_reverse_bits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//please remeber to update set_bitwise_key_u32() also</span></span><br><span class=\"line\">    <span class=\"comment\">//once you change build_hash_cache()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_hash_cache</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      nibblewise_key_cache = _reverse_nibbles(hash);</span><br><span class=\"line\">      hash_reverse_bits = _reverse_bits(hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_bitwise_key_u32</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> value)</span></span>&#123;</span><br><span class=\"line\">      hash = _reverse_bits(value);</span><br><span class=\"line\">      <span class=\"comment\">//below is identical to build_hash_cache() and shall be</span></span><br><span class=\"line\">      <span class=\"comment\">//updated correspondingly if you change build_hash_cache()</span></span><br><span class=\"line\">      nibblewise_key_cache = _reverse_nibbles(hash);</span><br><span class=\"line\">      hash_reverse_bits = values;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">get_effective_key</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(key.length())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oid.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> make_temp_hobject(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; name) <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">hobject_t</span>(<span class=\"keyword\">object_t</span>(name), <span class=\"string\">\"\"</span>, CEPH_NOSANP, hash, <span class=\"keyword\">hobject_t</span>::POOL_TEMP_START - pool, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">hobject_t</span> &amp;o)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">hobject_t</span> temp(o);</span><br><span class=\"line\">      o = (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      (*<span class=\"keyword\">this</span>) = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;<span class=\"title\">get_namespace</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> nspace;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">parse</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(json_spirit::Value&amp; v)</span></span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter *f)</span> <span class=\"keyword\">const</span></span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;<span class=\"keyword\">hobject_t</span>*&gt;&amp; o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> cmp(l, r) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cmp(l, r) &gt;=<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cmp(l, r) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp; r) &#123;     </span><br><span class=\"line\">      <span class=\"keyword\">return</span> cmp(l, r) &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;); </span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span>&amp;);</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ghobject_t</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODE(<span class=\"keyword\">hboject_t</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>//ghobject_t</p>\n<ul>\n<li>在hobjec_t基础上，添加了generation 字段 和 shard_id 字段; 主要用于EC的rollback</li>\n<li>副本模式下， shard_id设置为NO_SHARD(-1), 这两个字段是无效的；<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ghobject_t</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">hboject_t</span> hobj;</span><br><span class=\"line\">  <span class=\"keyword\">gen_t</span> generation;</span><br><span class=\"line\">  <span class=\"keyword\">shard_id_t</span> shard_id;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> max;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">gen_t</span> NO_GEN=UINT64_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">ghobject_t</span>(): generation(NO_GEN), shard_id(<span class=\"keyword\">shard_id_t</span>::NO_SHARD), max(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\">  explicit ghobject_t(const hobject_t &amp;obj) : hobj(obj), generation(NO_GEN),</span><br><span class=\"line\">    shard_id(<span class=\"keyword\">shard_id_t</span>::NO_SHARD), max(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">ghobject_t</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">hobject_t</span> &amp;obj, <span class=\"keyword\">gen_t</span> gen, <span class=\"keyword\">shard_id_t</span> shard):</span><br><span class=\"line\">    hobj(obj), generation(gen), shard_id(shard), max(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ghobject_t <span class=\"title\">make_pgmeta</span><span class=\"params\">(<span class=\"keyword\">int64_t</span> pool, <span class=\"keyword\">uint32_t</span> hash, <span class=\"keyword\">shard_id_t</span> shard)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">hobject_t</span> h(<span class=\"keyword\">object_t</span>(), <span class=\"built_in\">string</span>(), CEPH_NOSANP, hash, pool, <span class=\"built_in\">string</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">ghobject_t</span>(h, NO_GEN, shard);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_pgmeta</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//make sure we are distinct from hobject_t(), which has pool INT64_MIN</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.pool &gt;= <span class=\"number\">0</span> &amp;&amp; hobj.oid,name.empty();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> bits, <span class=\"keyword\">uint32_t</span> match)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.match_hash(hobj.hash, bits, match);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// @return min ghobject_t ret s.t. ret.hash == this-&gt;hash</span></span><br><span class=\"line\">  <span class=\"keyword\">ghobject_t</span> get_boundary() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(hobj.is_max())</span><br><span class=\"line\">      <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> ret;</span><br><span class=\"line\">    ret.hobj.set_hash(hobj.hash);</span><br><span class=\"line\">    ret.shard_id = shard_id;</span><br><span class=\"line\">    ret.hobj.pool = hobj.pool;</span><br><span class=\"line\">    retrun ret;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> get_nibblewise_key_u32() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.get_nibblewise_key_u32();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> get_nibblewise_key() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hobj.get_nibblewise_key();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_degenerate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> generation == NO_GEN &amp;&amp; shard_id == shard_id::NO_SHARD;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_no_gen</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> generation == NO_GEN;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_no_shard</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shard_id == <span class=\"keyword\">shard_id_t</span>::NO_SHARD;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_shard</span><span class=\"params\">(<span class=\"keyword\">shard_id_t</span> s)</span></span>&#123;</span><br><span class=\"line\">    shard_id = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">parse</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//maximum sorted value.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ghobject_t <span class=\"title\">get_max</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> h;</span><br><span class=\"line\">    h.max = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    h.hobj = <span class=\"keyword\">hobject_t</span>::get_max();  <span class=\"comment\">//so that is_max() =&gt; hobj.is_max()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_max</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_min</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span> == <span class=\"keyword\">ghobject_t</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">ghobject_t</span> &amp;o)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> temp(o)</span><br><span class=\"line\">    o = (*<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    (*<span class=\"keyword\">this</span>) = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(json_spirit::Value&amp; v)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> encoded_size() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter *f)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;<span class=\"keyword\">ghobject_t</span>*&gt;&amp; o)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; l, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cmp(l, r) &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;);</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">WRITE_CLASS_ENCODE(<span class=\"keyword\">ghobject_t</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最直观的感觉是object id + xattr key; 两者结合一起，形成对象的键值key，但存在一个弊端<br>object id可能很长，当个对象存在很多属性的时候，object id不得不在key中出现多次，这必然会造成存储空间的浪费。<br>Ceph的FileStore分成了2步，第一步根据object id生成一个比较短的seq，然后seq + xattr key形成对象的某个属性的键值。</p>\n<p>omap不是通过计算从object id 获取seq的，他是首先根据object id, 存放一个Header类型的<br>数据结构到LevelDB，其中Header中的一个成员变量为seq。</p>\n<ul>\n<li>key: USER_PREFIX + header_key(header-&gt;seq) + XATTR_PREFIX + key</li>\n<li>value: header</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  - key: HOBJECT_TO_SEQ +ghobject_key(oid)</span></span><br><span class=\"line\"><span class=\"comment\">  - value: header (struct _Header)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Header</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> seq;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> parent;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> num_children;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">ghobject_t</span> oid;</span><br><span class=\"line\"></span><br><span class=\"line\">    SequencerPosition spos;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">coll_t</span> unused;</span><br><span class=\"line\">      ENCODE_START(<span class=\"number\">2</span>, <span class=\"number\">1</span>, bl);</span><br><span class=\"line\">      ::encode(seq, bl);</span><br><span class=\"line\">      ::encode(parent, bl);</span><br><span class=\"line\">      ::encode(num_children, bl);</span><br><span class=\"line\">      ::encode(unused, bl);</span><br><span class=\"line\">      ::encode(oid, bl);</span><br><span class=\"line\">      ::encode(spos bl);</span><br><span class=\"line\">      ENCODE_FINISH(bl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator&amp; bl)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">coll_t</span> unused;</span><br><span class=\"line\">      DECODE_START(<span class=\"number\">2</span>, bl);</span><br><span class=\"line\">      ::decode(seq, bl);</span><br><span class=\"line\">      ::decode(parent, bl);</span><br><span class=\"line\">      ::decode(num_children, bl);</span><br><span class=\"line\">      ::decode(unused, bl);</span><br><span class=\"line\">      ::decode(oid, bl);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (struct_v &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">        ::decode(spos, bl);</span><br><span class=\"line\">      DECODE_FINISH(bl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter *f)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">      f-&gt;dump_unsigned(<span class=\"string\">\"seq\"</span>, seq);</span><br><span class=\"line\">      f-&gt;dump_unsigned(<span class=\"string\">\"parent\"</span>, parent);</span><br><span class=\"line\">      f-&gt;dump_unsigned(<span class=\"string\">\"num_children\"</span>, num_children);</span><br><span class=\"line\">      f-&gt;dump_stream(<span class=\"string\">\"oid\"</span>) &lt;&lt; oid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;_Header*&gt;&amp; o )</span></span>&#123;</span><br><span class=\"line\">      o.push_back(<span class=\"keyword\">new</span> _Header);</span><br><span class=\"line\">      o.push_back(<span class=\"keyword\">new</span> _Header);</span><br><span class=\"line\">      o.back()-&gt;parent = <span class=\"number\">20</span>;</span><br><span class=\"line\">      o.back()-&gt;seq = <span class=\"number\">30</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _Header() : seq(<span class=\"number\">0</span>), parent(<span class=\"number\">0</span>), num_children(<span class=\"number\">1</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果要获取某个对象的oid的某个属性的值，需要分成两步走:</p>\n<ul>\n<li>找到Header，从header中取出seq的值</li>\n<li>根据seq的值生成该属性对应的新的最终的键值，从LevelDB中取出value</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取对象oid的某个或者某几个属性的值</span></span><br><span class=\"line\"><span class=\"comment\">// os/filestore/DBObjectMap.cc</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> DBObjectMap::get_xattrs(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; to_get, <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, bufferlist&gt;* out)&#123;</span><br><span class=\"line\">  <span class=\"function\">MapHeaderLock <span class=\"title\">hl</span><span class=\"params\">(<span class=\"keyword\">this</span>, oid)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//第一步根据oid找到header</span></span><br><span class=\"line\">  Header header = lookup_map_header(hl, oid);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!header)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据找到的header中的seq值，社会你刚才属性的键，在levelDB中找到对应key的value</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> db-get(xattr_prefix(header), to_get, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> DBObjectMap::set_xattrs(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; oid, <span class=\"keyword\">const</span> <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, bufferlist&gt;&amp; to_set, <span class=\"keyword\">const</span> SequencerPosition *spos)&#123;</span><br><span class=\"line\">  KeyValueDB::Transaction t = db-&gt;get_transcation();</span><br><span class=\"line\">  <span class=\"function\">MapHeaderLock <span class=\"title\">hl</span><span class=\"params\">(<span class=\"keyword\">this</span>, oid)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">/*寻找oid对应的header，如若没有，则新建一个header*/</span></span><br><span class=\"line\">  Header header = lookup_create_map_header(hl, oid, t);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!header)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (check_spos(oid, header, spos))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*根据header中的seq，得到真正的键值，然后设置一个或者多个属性*/</span></span><br><span class=\"line\">  t-&gt;<span class=\"built_in\">set</span>(xattr_prefix(header), to_set);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> db-&gt;submit_transaction(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> DBObjectMap::USER_PREFIX = <span class=\"string\">\"__USER__\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> DBObjectMap::XATTR_PREFIX= <span class=\"string\">\"__AXATTR__\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> DBObjectMap::header_key(<span class=\"keyword\">uint64_t</span> seq)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">  <span class=\"built_in\">snprintf</span>(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"string\">\"%.*\"</span> PRId64, (<span class=\"keyword\">int</span>)(<span class=\"number\">2</span>*<span class=\"keyword\">sizeof</span>(seq)), seq);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">string</span>(buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> DBObjectMap::xattr_prefix(Header header)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> USER_PREFIX + header_key(header-&gt;seq) + XATTR_PREFIX;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"seq-生成过程\"><a href=\"#seq-生成过程\" class=\"headerlink\" title=\"seq 生成过程\"></a>seq 生成过程</h3><ul>\n<li>LevelDB中存放着一个特殊的全局意义的key-value</li>\n<li>key: SYS_PREFIX + GLOBAL_STATE_KEY </li>\n<li>value: State  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// peersistent state for store @see generate_header</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">State</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> _u8 CUR_VERSION = <span class=\"number\">3</span>;</span><br><span class=\"line\">  __u8 v;</span><br><span class=\"line\">  <span class=\"keyword\">uint64_t</span> seq;</span><br><span class=\"line\">  <span class=\"comment\">// legacy is false when complete regions never used</span></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> legacy;</span><br><span class=\"line\"></span><br><span class=\"line\">  State() : v(<span class=\"number\">0</span>), seq(<span class=\"number\">1</span>), legacy(<span class=\"literal\">false</span>)&#123;&#125;</span><br><span class=\"line\">  explicit State(uint64_t seq) : v(0), seq(seq), legacy(false)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(bufferlist&amp; bl)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    ENCODE_START(<span class=\"number\">3</span>, <span class=\"number\">1</span>, bl);</span><br><span class=\"line\">    ::encode(v, bl);</span><br><span class=\"line\">    ::encode(seq, bl);</span><br><span class=\"line\">    ::encode(legacy, bl);</span><br><span class=\"line\">    ENCODE_FINISH(bl);    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(bufferlist::iterator &amp;bl)</span></span>&#123;</span><br><span class=\"line\">    DECODE_START(<span class=\"number\">3</span>, bl);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (struct_v &gt;=<span class=\"number\">2</span>)</span><br><span class=\"line\">      ::decode(v, bl);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ::decode(seq, bl);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(struct_v &gt;=<span class=\"number\">3</span>)</span><br><span class=\"line\">      ::decode(legacy, bl);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      legacy = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    DECODE_FINISH(bl);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(Formatter* f)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">    f-&gt;dump_unsigned(<span class=\"string\">\"v\"</span>, v);</span><br><span class=\"line\">    f-&gt;dump_unsigned(<span class=\"string\">\"seq\"</span>, seq);</span><br><span class=\"line\">    f-&gt;dump_unsigned(<span class=\"string\">\"legacy\"</span>, legacy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generate_test_instances</span><span class=\"params\">(<span class=\"built_in\">list</span>&lt;State*&gt;&amp; o)</span></span>&#123;</span><br><span class=\"line\">    o.push_back(<span class=\"keyword\">new</span> State(<span class=\"number\">0</span>));</span><br><span class=\"line\">    o.push_back(<span class=\"keyword\">new</span> State(<span class=\"number\">20</span>));</span><br><span class=\"line\">  &#125; state;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>该结构体只有一个成员变量，即seq，当产生新的Header的时候，会该值会递增，写入LevelDB</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBObjectMap::Header DBObjectMap::_generate_new_header(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span>&amp; oid, Header parent)&#123;</span><br><span class=\"line\">  Header header = Header(<span class=\"keyword\">new</span> _Header(), RemoveOnDelete(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  header-&gt;seq = state.seq++;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent)&#123;</span><br><span class=\"line\">    header-&gt;parent =  parent-&gt;seq;</span><br><span class=\"line\">    header-&gt;spos = parent-&gt;spos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  header-&gt;num_children = <span class=\"number\">1</span>;</span><br><span class=\"line\">  header-&gt;oid = oid;</span><br><span class=\"line\">  assert(!in_use.count(header-&gt;seq));</span><br><span class=\"line\">  in_use.insert(header-&gt;seq);</span><br><span class=\"line\"></span><br><span class=\"line\">  write_state();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> header;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为是全局的，为了防止竞争，需要加锁保护。</span></span><br><span class=\"line\"><span class=\"function\">Header <span class=\"title\">generate_new_header</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span> &amp;oid, Header parent)</span> </span>&#123;</span><br><span class=\"line\">    Mutex::<span class=\"function\">Locker <span class=\"title\">l</span><span class=\"params\">(header_lock)</span></span>;<span class=\"comment\">//加锁保护</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _generate_new_header(oid, parent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">DBObjectMap::Header DBObjectMap::lookup_create_map_header(</span><br><span class=\"line\">  <span class=\"keyword\">const</span> MapHeaderLock &amp;hl, </span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">ghobject_t</span> &amp;oid,</span><br><span class=\"line\">  KeyValueDB::Transaction t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Mutex::<span class=\"function\">Locker <span class=\"title\">l</span><span class=\"params\">(header_lock)</span></span>; <span class=\"comment\">// 加锁保护</span></span><br><span class=\"line\">  Header header = _lookup_map_header(hl, oid);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!header) &#123;</span><br><span class=\"line\">    header = _generate_new_header(oid, Header());                                                                                                      </span><br><span class=\"line\">    set_map_header(hl, oid, *header, t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> header;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ceph-objectstore-tool-用法\"><a href=\"#ceph-objectstore-tool-用法\" class=\"headerlink\" title=\"ceph-objectstore-tool 用法\"></a>ceph-objectstore-tool 用法</h3><h3 id=\"rgw-s3-属性\"><a href=\"#rgw-s3-属性\" class=\"headerlink\" title=\"rgw s3 属性\"></a>rgw s3 属性</h3><p>rgw s3的额外属性：</p>\n<ul>\n<li>user</li>\n<li>bucket</li>\n<li>bucket.instance<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//&lt;bucket&gt;指bucket name; &lt;marker&gt;指bucker id; &lt;user&gt;指user id</span></span><br><span class=\"line\">$ radosgw-admin metadata list</span><br><span class=\"line\">$ radosgw-admin metadata list bucket</span><br><span class=\"line\">$ radosgw-admin metadata list bucket.instance</span><br><span class=\"line\">$ radosgw-admin metadata list user</span><br><span class=\"line\"></span><br><span class=\"line\">$ radosgw-admin metadata get bucket:&lt;bucket&gt;</span><br><span class=\"line\">$ radosgw-admin metadata get bucket.instance:&lt;bucket&gt;:&lt;marker&gt;</span><br><span class=\"line\">$ radosgw-admin metadata get user:&lt;user&gt;   # get or set</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>user 数据被以<user>作为object name存储在default.rgw.meta pool中，其中namespace是user uid<br>bucket 数据以<bucket>作为object name存储在default.rgw.meta pool, 其中namespace：root</bucket></user></p>\n<p>bucket.instance 数据以.bucket.meta.<bucket>:<marker>作为 object name存储在default.rgw.meta pool中，其namespace是root。</marker></bucket></p>\n<h4 id=\"bucket属性\"><a href=\"#bucket属性\" class=\"headerlink\" title=\"bucket属性\"></a>bucket属性</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">radosgw-admin bucket stats --bucket=test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"bucket\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pool\"</span>: <span class=\"string\">\".rgw.buckets.zj-1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"index_pool\"</span>: <span class=\"string\">\".rgw.buckets.index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>: <span class=\"string\">\"default.784974.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"marker\"</span>: <span class=\"string\">\"default.784974.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"owner\"</span>: <span class=\"string\">\"user-1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"ver\"</span>: <span class=\"string\">\"0#1901\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"master_ver\"</span>: <span class=\"string\">\"0#0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"mtime\"</span>: <span class=\"string\">\"2015-04-07 16:23:23.000000\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"max_marker\"</span>: <span class=\"string\">\"0#\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"usage\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"rgw.main\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"size_kb\"</span>: <span class=\"number\">1048870</span>,</span><br><span class=\"line\">            <span class=\"string\">\"size_kb_actual\"</span>: <span class=\"number\">1048908</span>,</span><br><span class=\"line\">            <span class=\"string\">\"num_objects\"</span>: <span class=\"number\">17</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"bucket_quota\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"enabled\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"max_size_kb\"</span>: <span class=\"number\">-1</span>,</span><br><span class=\"line\">        <span class=\"string\">\"max_objects\"</span>: <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bucket的名称，所在的data pool, index pool, bucket id<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bucket_id</span><br><span class=\"line\">  - zone_name     --&gt;   <span class=\"keyword\">default</span></span><br><span class=\"line\">  - instance_id   --&gt;   <span class=\"number\">784974</span></span><br><span class=\"line\">  - bucket id     --&gt;   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"bucket-index-属性\"><a href=\"#bucket-index-属性\" class=\"headerlink\" title=\"bucket index 属性\"></a>bucket index 属性</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rados -p .rgw.buckets.index ls - | grep <span class=\"string\">\"default.784974.1\"</span></span><br><span class=\"line\">.dir.<span class=\"keyword\">default</span><span class=\"number\">.784974</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n<p>bucket index object 名称为： .dir.{buckt id}</p>\n<h4 id=\"查看index-的keys\"><a href=\"#查看index-的keys\" class=\"headerlink\" title=\"查看index 的keys\"></a>查看index 的keys</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># rados -p .rgw.buckets.index listomapkeys .dir.default.784974.1</span></span><br><span class=\"line\">/demo/region.conf.json</span><br></pre></td></tr></table></figure>\n<h3 id=\"rgw-max-chunk-size-amp-rgw-obj-stripe-size\"><a href=\"#rgw-max-chunk-size-amp-rgw-obj-stripe-size\" class=\"headerlink\" title=\"rgw_max_chunk_size &amp; rgw_obj_stripe_size\"></a>rgw_max_chunk_size &amp; rgw_obj_stripe_size</h3><ul>\n<li>rgw_max_chunk_size : default: (524388) 512k<ul>\n<li>RadosGW下发到RADOS集群的单个IO的大小</li>\n<li>当写入的对象大小大于rgw_max_chunk_size:<ul>\n<li>rados层的一个对象，大小为实际大小；</li>\n<li>rados层的命名： {bucket_id}_{对象文件的名字}</li>\n</ul>\n</li>\n<li>当写入的对象大小大于rgw_max_chunk_size:<ul>\n<li>分成多种对象存储，<br>1、首对象（head_obj) 大小为rgw_max_chunk_size<br>2、中间对象： 大小为rgw_obj_stripe_size<br>3、尾对象：   小于或等于rgw_obj_stripe_size</li>\n<li>其它的对象按照rgw_obj_stripe_size切分成多个obj存入rados</li>\n<li>head object命名规则： {bucket_id}_{对象文件的名字}</li>\n<li>中间对象、尾对象命名：{bucket_id}<em>shadow</em>{长度为32的随机字符}_{条带编号, 从1起}</li>\n<li>head_obj需要将中间对象、尾对象关联起来：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\"># rados -p .rgw.buckets listxattr default.ubuntu12.04.iso</span></span><br><span class=\"line\">    user.rgw.acl</span><br><span class=\"line\">    user.rgw.content_type</span><br><span class=\"line\">    user.rgw.etag</span><br><span class=\"line\">    user.rgw.idtag</span><br><span class=\"line\">    user.rgw.manifest</span><br><span class=\"line\">    user.rgw.x-amz-date</span><br><span class=\"line\"></span><br><span class=\"line\">    rados -p .rgw.buckets getxattr  <span class=\"keyword\">default</span><span class=\"number\">.11383165</span><span class=\"number\">.2</span>_scaler.iso  user.rgw.manifest  &gt; /root/scaler.iso.manifest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># ceph-dencoder type RGWObjManifest import /root/ubuntu12.iso.manifest decode dump_json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"objs\"</span>: [],</span><br><span class=\"line\">    <span class=\"string\">\"obj_size\"</span>: <span class=\"number\">2842374144</span>,     &lt;-----------------对象文件大小</span><br><span class=\"line\">    <span class=\"string\">\"explicit_objs\"</span>: <span class=\"string\">\"false\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"head_obj\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"bucket\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"name\"</span>: <span class=\"string\">\"bean_book\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"pool\"</span>: <span class=\"string\">\".rgw.buckets\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"data_extra_pool\"</span>: <span class=\"string\">\".rgw.buckets.extra\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"index_pool\"</span>: <span class=\"string\">\".rgw.buckets.index\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"marker\"</span>: <span class=\"string\">\"default.11383165.2\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"bucket_id\"</span>: <span class=\"string\">\"default.11383165.2\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"key\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ns\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"object\"</span>: <span class=\"string\">\"scaler.iso\"</span>,         &lt;-----对象名</span><br><span class=\"line\">        <span class=\"string\">\"instance\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"head_size\"</span>: <span class=\"number\">524288</span>,</span><br><span class=\"line\">    <span class=\"string\">\"max_head_size\"</span>: <span class=\"number\">524288</span>,</span><br><span class=\"line\">    <span class=\"string\">\"prefix\"</span>: <span class=\"string\">\".mGwYpWb3FXieaaaDNdaPzfs546ysNnT_\"</span>,  &lt;---中间对象和尾对象的随机前缀</span><br><span class=\"line\">    <span class=\"string\">\"tail_bucket\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"bean_book\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"pool\"</span>: <span class=\"string\">\".rgw.buckets\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"data_extra_pool\"</span>: <span class=\"string\">\".rgw.buckets.extra\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"index_pool\"</span>: <span class=\"string\">\".rgw.buckets.index\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"marker\"</span>: <span class=\"string\">\"default.11383165.2\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"bucket_id\"</span>: <span class=\"string\">\"default.11383165.2\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"string\">\"val\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"start_part_num\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"start_ofs\"</span>: <span class=\"number\">524288</span>,</span><br><span class=\"line\">                <span class=\"string\">\"part_size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"stripe_max_size\"</span>: <span class=\"number\">4194304</span>,</span><br><span class=\"line\">                <span class=\"string\">\"override_prefix\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RGWObjManifest</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"go之基础重温","date":"2018-04-14T16:00:00.000Z","_content":"- 值语义\n     -  大多数类型基于值语义，包括基本类型：byte, int, bool, float32, float64 和string\n     - 复合类型： array, struct, pointer\n\n- 引用语义\n变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收。\n获取指针类型所指向的值，使用：\" * \" 取值符号 。\n\n    - 数组切片slice\n    - map\n    - channel\n    - interface\n    - 指针\n\n- new 和 make 区别\n    - new 用于值类型和用户自定义的类型（如struct）\n   ```go\n   new 内建函数原型：func new(Type)  *Type\n   new 返回指向类型的指针。\n```\n    -   make 用于内置（slice，map 和channel)\n    ```go\n   make内建函数原型： func make(t Type, size ...IntegerType) Type\n   make返回引用类型\n  ```\n\n在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量；\n不能直接使用nil值的slice 和map\n\n- Go中的struct与其他语言的类(class)有同等地位，Go中放弃了包括继承在内的大量面向对象特性，只保留了组合composition这个基础特性；\n- Go中未被初始化的值都被初始化为该类型的零值；\n\n```go\ntype Rect struct{\n  x int\n  y int\n}\n//初始化\nrect := new(Rect)\nrect := &Rect{}\nrect := &Rect{1,  2}\nrect := &Rect{\n  x: 1,\n  y: 2,\n}\n\n//约定俗成的规矩，而非强制\n/* 对象的创建通常由一个全局的创建函数完成，NewXXX来命名，表示构造函数 */\nfunc NewRect(x, y, width, height int) *Rect{\n  return &Rect{\n    x: x,\n    y: y,\n  }\n}\n```\n\n- 匿名组合\n```go\ntype Foo struct{\n    Rect\n    z int\n}\n\nfunc NewFoo(x, y, z) *Foo{\n  return &Foo{\n    Base: Base{x: x, y: y},\n    z: z,\n  }\n\n  //形式2， y后面的逗号\n  return &Foo{\n        Base: Base{\n            X: x,\n            Y: y,\n        },\n        z: z,\n    }\n}\nvar  f *Foo\nf.Base.Bfunc()\nf.Bfunc()\n```\n\n- 可见性\n\n  需要使某个符号对其他包可见，需要将该符号定义为以大写字母开头\n\n- interface 接口 \n- interface 赋值 \n```go\nfunc (this *Foo)add(size int){\n  this.X += size\n}\n\nfunc (this Foo)less(m int) bool {\n  return Foo.X > m\n}\n\ntype Add interface{\n  add(s int)\n  less(m int) bool\n}\n\nvar f = Foo{Base{X: 1, Y: 2}, 3}\nvar a Add = &foo        //pointer      (1)\nvar a Add = foo         // error       (2)\n\n 应该用语句(1)。原因在于，Go语言可以根据下面的函数：\nfunc (this Foo) less(m int) bool\n自动生成一个新的Less()方法：\nfunc (this *Foo) less(m int) bool {\nreturn (*this).less(m)\n}\n\n这样，类型*Foo就既存在less()方法，也存在add()方法，满足Add接口。而从另一方面来说，根据\nfunc (this *Foo) add(size int)\n这个函数无法自动生成以下这个成员方法：\nfunc (this Foo) add(size int) {\n  (&this).add(size)\n}\n因为(&this).add()改变的只是函数参数a，对外部实际要操作的对象并无影响，这不符合用\n户的预期。所以，Go语言不会自动为其生成该函数。因此，类型Foo只存在less()方法，\n缺少add()方法，不满足Add接口，故此上面的语句(2)不能赋值。\n```\n\n- 接口查询:\n\n```go\nvar f = Foo{Base{X:1, Y: 2}, 3}\nif f_, ok := f.(Add); ok{\n    ...\n}\n\nvar v1 interface{} = ...\nswitch v := v1.(type){\ncase int:\ncase string:\ndefault:\n...\n}\n```\n","source":"_posts/go_base.md","raw":"---\ntitle: go之基础重温\ndate: 2018-04-15\ncategories:\n  - golang\ntags:\n  - golang\n---\n- 值语义\n     -  大多数类型基于值语义，包括基本类型：byte, int, bool, float32, float64 和string\n     - 复合类型： array, struct, pointer\n\n- 引用语义\n变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收。\n获取指针类型所指向的值，使用：\" * \" 取值符号 。\n\n    - 数组切片slice\n    - map\n    - channel\n    - interface\n    - 指针\n\n- new 和 make 区别\n    - new 用于值类型和用户自定义的类型（如struct）\n   ```go\n   new 内建函数原型：func new(Type)  *Type\n   new 返回指向类型的指针。\n```\n    -   make 用于内置（slice，map 和channel)\n    ```go\n   make内建函数原型： func make(t Type, size ...IntegerType) Type\n   make返回引用类型\n  ```\n\n在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量；\n不能直接使用nil值的slice 和map\n\n- Go中的struct与其他语言的类(class)有同等地位，Go中放弃了包括继承在内的大量面向对象特性，只保留了组合composition这个基础特性；\n- Go中未被初始化的值都被初始化为该类型的零值；\n\n```go\ntype Rect struct{\n  x int\n  y int\n}\n//初始化\nrect := new(Rect)\nrect := &Rect{}\nrect := &Rect{1,  2}\nrect := &Rect{\n  x: 1,\n  y: 2,\n}\n\n//约定俗成的规矩，而非强制\n/* 对象的创建通常由一个全局的创建函数完成，NewXXX来命名，表示构造函数 */\nfunc NewRect(x, y, width, height int) *Rect{\n  return &Rect{\n    x: x,\n    y: y,\n  }\n}\n```\n\n- 匿名组合\n```go\ntype Foo struct{\n    Rect\n    z int\n}\n\nfunc NewFoo(x, y, z) *Foo{\n  return &Foo{\n    Base: Base{x: x, y: y},\n    z: z,\n  }\n\n  //形式2， y后面的逗号\n  return &Foo{\n        Base: Base{\n            X: x,\n            Y: y,\n        },\n        z: z,\n    }\n}\nvar  f *Foo\nf.Base.Bfunc()\nf.Bfunc()\n```\n\n- 可见性\n\n  需要使某个符号对其他包可见，需要将该符号定义为以大写字母开头\n\n- interface 接口 \n- interface 赋值 \n```go\nfunc (this *Foo)add(size int){\n  this.X += size\n}\n\nfunc (this Foo)less(m int) bool {\n  return Foo.X > m\n}\n\ntype Add interface{\n  add(s int)\n  less(m int) bool\n}\n\nvar f = Foo{Base{X: 1, Y: 2}, 3}\nvar a Add = &foo        //pointer      (1)\nvar a Add = foo         // error       (2)\n\n 应该用语句(1)。原因在于，Go语言可以根据下面的函数：\nfunc (this Foo) less(m int) bool\n自动生成一个新的Less()方法：\nfunc (this *Foo) less(m int) bool {\nreturn (*this).less(m)\n}\n\n这样，类型*Foo就既存在less()方法，也存在add()方法，满足Add接口。而从另一方面来说，根据\nfunc (this *Foo) add(size int)\n这个函数无法自动生成以下这个成员方法：\nfunc (this Foo) add(size int) {\n  (&this).add(size)\n}\n因为(&this).add()改变的只是函数参数a，对外部实际要操作的对象并无影响，这不符合用\n户的预期。所以，Go语言不会自动为其生成该函数。因此，类型Foo只存在less()方法，\n缺少add()方法，不满足Add接口，故此上面的语句(2)不能赋值。\n```\n\n- 接口查询:\n\n```go\nvar f = Foo{Base{X:1, Y: 2}, 3}\nif f_, ok := f.(Add); ok{\n    ...\n}\n\nvar v1 interface{} = ...\nswitch v := v1.(type){\ncase int:\ncase string:\ndefault:\n...\n}\n```\n","slug":"go_base","published":1,"updated":"2020-02-14T03:40:47.990Z","_id":"cjq3l8d4p00035sha3cs7okq0","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><p>值语义</p>\n<ul>\n<li>大多数类型基于值语义，包括基本类型：byte, int, bool, float32, float64 和string</li>\n<li>复合类型： array, struct, pointer</li>\n</ul>\n</li>\n<li><p>引用语义<br>变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收。<br>获取指针类型所指向的值，使用：” * “ 取值符号 。</p>\n<ul>\n<li>数组切片slice</li>\n<li>map</li>\n<li>channel</li>\n<li>interface</li>\n<li>指针</li>\n</ul>\n</li>\n<li><p>new 和 make 区别</p>\n<ul>\n<li><p>new 用于值类型和用户自定义的类型（如struct）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">new</span> 内建函数原型：<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">new</span><span class=\"params\">(Type)</span>  *<span class=\"title\">Type</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">new</span> 返回指向类型的指针。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>make 用于内置（slice，map 和channel)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">make</span>内建函数原型： <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">make</span><span class=\"params\">(t Type, size ...IntegerType)</span> <span class=\"title\">Type</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">make</span>返回引用类型</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量；<br>不能直接使用nil值的slice 和map</p>\n<ul>\n<li>Go中的struct与其他语言的类(class)有同等地位，Go中放弃了包括继承在内的大量面向对象特性，只保留了组合composition这个基础特性；</li>\n<li>Go中未被初始化的值都被初始化为该类型的零值；</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Rect <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">  x <span class=\"keyword\">int</span></span><br><span class=\"line\">  y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\">rect := <span class=\"built_in\">new</span>(Rect)</span><br><span class=\"line\">rect := &amp;Rect&#123;&#125;</span><br><span class=\"line\">rect := &amp;Rect&#123;<span class=\"number\">1</span>,  <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">rect := &amp;Rect&#123;</span><br><span class=\"line\">  x: <span class=\"number\">1</span>,</span><br><span class=\"line\">  y: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//约定俗成的规矩，而非强制</span></span><br><span class=\"line\"><span class=\"comment\">/* 对象的创建通常由一个全局的创建函数完成，NewXXX来命名，表示构造函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRect</span><span class=\"params\">(x, y, width, height <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Rect</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Rect&#123;</span><br><span class=\"line\">    x: x,</span><br><span class=\"line\">    y: y,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>匿名组合</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Rect</span><br><span class=\"line\">    z <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFoo</span><span class=\"params\">(x, y, z)</span> *<span class=\"title\">Foo</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Foo&#123;</span><br><span class=\"line\">    Base: Base&#123;x: x, y: y&#125;,</span><br><span class=\"line\">    z: z,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//形式2， y后面的逗号</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Foo&#123;</span><br><span class=\"line\">        Base: Base&#123;</span><br><span class=\"line\">            X: x,</span><br><span class=\"line\">            Y: y,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        z: z,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span>  f *Foo</span><br><span class=\"line\">f.Base.Bfunc()</span><br><span class=\"line\">f.Bfunc()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可见性</p>\n<p>需要使某个符号对其他包可见，需要将该符号定义为以大写字母开头</p>\n</li>\n<li><p>interface 接口 </p>\n</li>\n<li><p>interface 赋值 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *Foo)</span><span class=\"title\">add</span><span class=\"params\">(size <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">  this.X += size</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this Foo)</span><span class=\"title\">less</span><span class=\"params\">(m <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Foo.X &gt; m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Add <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">  add(s <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  less(m <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = Foo&#123;Base&#123;X: <span class=\"number\">1</span>, Y: <span class=\"number\">2</span>&#125;, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a Add = &amp;foo        <span class=\"comment\">//pointer      (1)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a Add = foo         <span class=\"comment\">// error       (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"> 应该用语句(<span class=\"number\">1</span>)。原因在于，Go语言可以根据下面的函数：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this Foo)</span> <span class=\"title\">less</span><span class=\"params\">(m <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\">自动生成一个新的<span class=\"title\">Less</span><span class=\"params\">()</span>方法：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(this *Foo)</span> <span class=\"title\">less</span><span class=\"params\">(m <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (*this).less(m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这样，类型*Foo就既存在less()方法，也存在add()方法，满足Add接口。而从另一方面来说，根据</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *Foo)</span> <span class=\"title\">add</span><span class=\"params\">(size <span class=\"keyword\">int</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">这个函数无法自动生成以下这个成员方法：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(this Foo)</span> <span class=\"title\">add</span><span class=\"params\">(size <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  (&amp;this).add(size)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">因为(&amp;this).add()改变的只是函数参数a，对外部实际要操作的对象并无影响，这不符合用</span><br><span class=\"line\">户的预期。所以，Go语言不会自动为其生成该函数。因此，类型Foo只存在less()方法，</span><br><span class=\"line\">缺少add()方法，不满足Add接口，故此上面的语句(<span class=\"number\">2</span>)不能赋值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口查询:</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = Foo&#123;Base&#123;X:<span class=\"number\">1</span>, Y: <span class=\"number\">2</span>&#125;, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> f_, ok := f.(Add); ok&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">interface</span>&#123;&#125; = ...</span><br><span class=\"line\"><span class=\"keyword\">switch</span> v := v1.(<span class=\"keyword\">type</span>)&#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>值语义</p>\n<ul>\n<li>大多数类型基于值语义，包括基本类型：byte, int, bool, float32, float64 和string</li>\n<li>复合类型： array, struct, pointer</li>\n</ul>\n</li>\n<li><p>引用语义<br>变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收。<br>获取指针类型所指向的值，使用：” * “ 取值符号 。</p>\n<ul>\n<li>数组切片slice</li>\n<li>map</li>\n<li>channel</li>\n<li>interface</li>\n<li>指针</li>\n</ul>\n</li>\n<li><p>new 和 make 区别</p>\n<ul>\n<li><p>new 用于值类型和用户自定义的类型（如struct）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">new</span> 内建函数原型：<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">new</span><span class=\"params\">(Type)</span>  *<span class=\"title\">Type</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">new</span> 返回指向类型的指针。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>make 用于内置（slice，map 和channel)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">make</span>内建函数原型： <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">make</span><span class=\"params\">(t Type, size ...IntegerType)</span> <span class=\"title\">Type</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">make</span>返回引用类型</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量；<br>不能直接使用nil值的slice 和map</p>\n<ul>\n<li>Go中的struct与其他语言的类(class)有同等地位，Go中放弃了包括继承在内的大量面向对象特性，只保留了组合composition这个基础特性；</li>\n<li>Go中未被初始化的值都被初始化为该类型的零值；</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Rect <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">  x <span class=\"keyword\">int</span></span><br><span class=\"line\">  y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\">rect := <span class=\"built_in\">new</span>(Rect)</span><br><span class=\"line\">rect := &amp;Rect&#123;&#125;</span><br><span class=\"line\">rect := &amp;Rect&#123;<span class=\"number\">1</span>,  <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">rect := &amp;Rect&#123;</span><br><span class=\"line\">  x: <span class=\"number\">1</span>,</span><br><span class=\"line\">  y: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//约定俗成的规矩，而非强制</span></span><br><span class=\"line\"><span class=\"comment\">/* 对象的创建通常由一个全局的创建函数完成，NewXXX来命名，表示构造函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRect</span><span class=\"params\">(x, y, width, height <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Rect</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Rect&#123;</span><br><span class=\"line\">    x: x,</span><br><span class=\"line\">    y: y,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>匿名组合</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Rect</span><br><span class=\"line\">    z <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFoo</span><span class=\"params\">(x, y, z)</span> *<span class=\"title\">Foo</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Foo&#123;</span><br><span class=\"line\">    Base: Base&#123;x: x, y: y&#125;,</span><br><span class=\"line\">    z: z,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//形式2， y后面的逗号</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Foo&#123;</span><br><span class=\"line\">        Base: Base&#123;</span><br><span class=\"line\">            X: x,</span><br><span class=\"line\">            Y: y,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        z: z,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span>  f *Foo</span><br><span class=\"line\">f.Base.Bfunc()</span><br><span class=\"line\">f.Bfunc()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可见性</p>\n<p>需要使某个符号对其他包可见，需要将该符号定义为以大写字母开头</p>\n</li>\n<li><p>interface 接口 </p>\n</li>\n<li><p>interface 赋值 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *Foo)</span><span class=\"title\">add</span><span class=\"params\">(size <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">  this.X += size</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this Foo)</span><span class=\"title\">less</span><span class=\"params\">(m <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Foo.X &gt; m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Add <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">  add(s <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  less(m <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = Foo&#123;Base&#123;X: <span class=\"number\">1</span>, Y: <span class=\"number\">2</span>&#125;, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a Add = &amp;foo        <span class=\"comment\">//pointer      (1)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a Add = foo         <span class=\"comment\">// error       (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"> 应该用语句(<span class=\"number\">1</span>)。原因在于，Go语言可以根据下面的函数：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this Foo)</span> <span class=\"title\">less</span><span class=\"params\">(m <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\">自动生成一个新的<span class=\"title\">Less</span><span class=\"params\">()</span>方法：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(this *Foo)</span> <span class=\"title\">less</span><span class=\"params\">(m <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (*this).less(m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这样，类型*Foo就既存在less()方法，也存在add()方法，满足Add接口。而从另一方面来说，根据</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *Foo)</span> <span class=\"title\">add</span><span class=\"params\">(size <span class=\"keyword\">int</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">这个函数无法自动生成以下这个成员方法：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(this Foo)</span> <span class=\"title\">add</span><span class=\"params\">(size <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  (&amp;this).add(size)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">因为(&amp;this).add()改变的只是函数参数a，对外部实际要操作的对象并无影响，这不符合用</span><br><span class=\"line\">户的预期。所以，Go语言不会自动为其生成该函数。因此，类型Foo只存在less()方法，</span><br><span class=\"line\">缺少add()方法，不满足Add接口，故此上面的语句(<span class=\"number\">2</span>)不能赋值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口查询:</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = Foo&#123;Base&#123;X:<span class=\"number\">1</span>, Y: <span class=\"number\">2</span>&#125;, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> f_, ok := f.(Add); ok&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">interface</span>&#123;&#125; = ...</span><br><span class=\"line\"><span class=\"keyword\">switch</span> v := v1.(<span class=\"keyword\">type</span>)&#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"design model 之 subcribe/publish","date":"2018-08-09T16:00:00.000Z","_content":"### 简单工厂模式\n```go\ntype sayer interface {\n    say()\n}\n\ntype man struct{\n\n}\n\nfunc (m *man)say(){\n    fmt.Printf(\"I am man\")\n}\n\ntype woman struct{\n\n}\n\nfunc (w *woman)say(){\n    fmt.Printf(\"I am woman\")\n}\n\nfunc factory(t string) sayer{\n    if t==\"man\" {\n        return &man{}\n    }else{\n        return &woman{}\n    }\n}\n\nfunc main(){\n    s := factory(\"man\")\n    s.say()\n}\n```","source":"_posts/design.md","raw":"---\n  title: design model 之 subcribe/publish \n  date: 2018-08-10\n  categories:\n    - 设计模式\n  tags:\n    - golang\n---\n### 简单工厂模式\n```go\ntype sayer interface {\n    say()\n}\n\ntype man struct{\n\n}\n\nfunc (m *man)say(){\n    fmt.Printf(\"I am man\")\n}\n\ntype woman struct{\n\n}\n\nfunc (w *woman)say(){\n    fmt.Printf(\"I am woman\")\n}\n\nfunc factory(t string) sayer{\n    if t==\"man\" {\n        return &man{}\n    }else{\n        return &woman{}\n    }\n}\n\nfunc main(){\n    s := factory(\"man\")\n    s.say()\n}\n```","slug":"design","published":1,"updated":"2018-12-25T11:15:32.349Z","_id":"cjq3l8d4q00045shak3a7tmmh","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> sayer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    say()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> man <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *man)</span><span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"I am man\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> woman <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(w *woman)</span><span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"I am woman\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">factory</span><span class=\"params\">(t <span class=\"keyword\">string</span>)</span> <span class=\"title\">sayer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t==<span class=\"string\">\"man\"</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;man&#123;&#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;woman&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    s := factory(<span class=\"string\">\"man\"</span>)</span><br><span class=\"line\">    s.say()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> sayer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    say()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> man <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *man)</span><span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"I am man\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> woman <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(w *woman)</span><span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"I am woman\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">factory</span><span class=\"params\">(t <span class=\"keyword\">string</span>)</span> <span class=\"title\">sayer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t==<span class=\"string\">\"man\"</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;man&#123;&#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;woman&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    s := factory(<span class=\"string\">\"man\"</span>)</span><br><span class=\"line\">    s.say()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"cache lru","date":"2018-04-14T16:00:00.000Z","_content":"\n### lru\n\n```golang\npackage lru\n\n//LRU Cache\nimport (\n    \"container/list\"\n)\n\ntype CacheNode struct {\n    key   interface{}\n    value interface{}\n}\n\nfunc NewCacheNode(k, v interface{}) *CacheNode {\n    return &CacheNode{k, v}\n}\n\ntype Lru struct {\n    capacity int\n    dlist    *list.List\n    cacheMap map[interface{}]*list.Element\n}\n\nfunc NewLru(cap int) *Lru {\n    return &Lru{\n        capacity: cap,\n        dlist:    list.New(),\n        cacheMap: make(map[interface{}]*list.Element),\n    }\n}\n\nfunc (lru *Lru) Size() int {\n    return lru.dlist.Len()\n}\n\nfunc (lru *Lru) Set(k, v interface{}) error {\n    if lru.dlist == nil {\n        return error.New(\"lrucache need init\")\n    }\n\n    //key exist, movetoFront, update value\n    if pElement, ok := lru.cacheMap[k]; ok {\n      lru.dlist.MoveToFront(pElement)\n      pElement.Value.(*CacheNode).Value = v\n      return nil\n  }\n\n  //not exist\n  newElement := lru.dlist.PushFront(&CacheNode{k, v})\n  lru.cacheMap[k] = newElement\n\n  if lru.dlist.Len() > lru.capacity {\n      lastElement := lru.dlist.Back()\n      if lastElement == nil {\n          return nil\n      }\n\n      cacheNode := lastElement.Value.(*CacheNode)\n      delete(lru.cacheMap, cacheNode.key)\n      lru.dlist.Remove(lastElement)\n  }\n  return nil\n}\n\nfunc (lru *Lru) Get(k interface{}) (v interface{}, err error) {\n  if lru.cacheMap == nil {\n      return v, errors.New(\"LRUCache need init\")\n  }\n\n  if pElement, ok := lru.cacheMap[k]; ok {\n      lru.dlist.MoveToFront(pElement)\n      return pElement.Value.(*CacheNode).Value, nil\n  }\n  return v, nil\n}\n\nfunc (lru *LRUCache) Remove(k interface{}) bool {\n  if lru.cacheMap == nil {\n      return false\n  }\n\n  if pElement, ok := lru.cacheMap[k]; ok {\n      cacheNode := pElement.Value.(*CacheNode)\n      delete(lru.cacheMap, cacheNode.Key)\n      lru.dlist.Remove(pElement)\n      return true\n  }\n  return false\n}\n```\n","source":"_posts/go_cache_lru.md","raw":"---\n    title: cache lru\n    date: 2018-04-15\n    categories:\n    - golang\n    tags:\n      - cache\n---\n\n### lru\n\n```golang\npackage lru\n\n//LRU Cache\nimport (\n    \"container/list\"\n)\n\ntype CacheNode struct {\n    key   interface{}\n    value interface{}\n}\n\nfunc NewCacheNode(k, v interface{}) *CacheNode {\n    return &CacheNode{k, v}\n}\n\ntype Lru struct {\n    capacity int\n    dlist    *list.List\n    cacheMap map[interface{}]*list.Element\n}\n\nfunc NewLru(cap int) *Lru {\n    return &Lru{\n        capacity: cap,\n        dlist:    list.New(),\n        cacheMap: make(map[interface{}]*list.Element),\n    }\n}\n\nfunc (lru *Lru) Size() int {\n    return lru.dlist.Len()\n}\n\nfunc (lru *Lru) Set(k, v interface{}) error {\n    if lru.dlist == nil {\n        return error.New(\"lrucache need init\")\n    }\n\n    //key exist, movetoFront, update value\n    if pElement, ok := lru.cacheMap[k]; ok {\n      lru.dlist.MoveToFront(pElement)\n      pElement.Value.(*CacheNode).Value = v\n      return nil\n  }\n\n  //not exist\n  newElement := lru.dlist.PushFront(&CacheNode{k, v})\n  lru.cacheMap[k] = newElement\n\n  if lru.dlist.Len() > lru.capacity {\n      lastElement := lru.dlist.Back()\n      if lastElement == nil {\n          return nil\n      }\n\n      cacheNode := lastElement.Value.(*CacheNode)\n      delete(lru.cacheMap, cacheNode.key)\n      lru.dlist.Remove(lastElement)\n  }\n  return nil\n}\n\nfunc (lru *Lru) Get(k interface{}) (v interface{}, err error) {\n  if lru.cacheMap == nil {\n      return v, errors.New(\"LRUCache need init\")\n  }\n\n  if pElement, ok := lru.cacheMap[k]; ok {\n      lru.dlist.MoveToFront(pElement)\n      return pElement.Value.(*CacheNode).Value, nil\n  }\n  return v, nil\n}\n\nfunc (lru *LRUCache) Remove(k interface{}) bool {\n  if lru.cacheMap == nil {\n      return false\n  }\n\n  if pElement, ok := lru.cacheMap[k]; ok {\n      cacheNode := pElement.Value.(*CacheNode)\n      delete(lru.cacheMap, cacheNode.Key)\n      lru.dlist.Remove(pElement)\n      return true\n  }\n  return false\n}\n```\n","slug":"go_cache_lru","published":1,"updated":"2018-12-25T11:22:48.298Z","_id":"cjq3l8d4q00055shaaxspi6lt","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"lru\"><a href=\"#lru\" class=\"headerlink\" title=\"lru\"></a>lru</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//LRU Cache</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"container/list\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> CacheNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    key   <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    value <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCacheNode</span><span class=\"params\">(k, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> *<span class=\"title\">CacheNode</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;CacheNode&#123;k, v&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Lru <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    capacity <span class=\"keyword\">int</span></span><br><span class=\"line\">    dlist    *list.List</span><br><span class=\"line\">    cacheMap <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]*list.Element</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLru</span><span class=\"params\">(<span class=\"built_in\">cap</span> <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Lru</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Lru&#123;</span><br><span class=\"line\">        capacity: <span class=\"built_in\">cap</span>,</span><br><span class=\"line\">        dlist:    list.New(),</span><br><span class=\"line\">        cacheMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]*list.Element),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *Lru)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lru.dlist.Len()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *Lru)</span> <span class=\"title\">Set</span><span class=\"params\">(k, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> lru.dlist == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error.New(<span class=\"string\">\"lrucache need init\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//key exist, movetoFront, update value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pElement, ok := lru.cacheMap[k]; ok &#123;</span><br><span class=\"line\">      lru.dlist.MoveToFront(pElement)</span><br><span class=\"line\">      pElement.Value.(*CacheNode).Value = v</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//not exist</span></span><br><span class=\"line\">  newElement := lru.dlist.PushFront(&amp;CacheNode&#123;k, v&#125;)</span><br><span class=\"line\">  lru.cacheMap[k] = newElement</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lru.dlist.Len() &gt; lru.capacity &#123;</span><br><span class=\"line\">      lastElement := lru.dlist.Back()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> lastElement == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      cacheNode := lastElement.Value.(*CacheNode)</span><br><span class=\"line\">      <span class=\"built_in\">delete</span>(lru.cacheMap, cacheNode.key)</span><br><span class=\"line\">      lru.dlist.Remove(lastElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *Lru)</span> <span class=\"title\">Get</span><span class=\"params\">(k <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> lru.cacheMap == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> v, errors.New(<span class=\"string\">\"LRUCache need init\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> pElement, ok := lru.cacheMap[k]; ok &#123;</span><br><span class=\"line\">      lru.dlist.MoveToFront(pElement)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pElement.Value.(*CacheNode).Value, <span class=\"literal\">nil</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *LRUCache)</span> <span class=\"title\">Remove</span><span class=\"params\">(k <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> lru.cacheMap == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> pElement, ok := lru.cacheMap[k]; ok &#123;</span><br><span class=\"line\">      cacheNode := pElement.Value.(*CacheNode)</span><br><span class=\"line\">      <span class=\"built_in\">delete</span>(lru.cacheMap, cacheNode.Key)</span><br><span class=\"line\">      lru.dlist.Remove(pElement)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"lru\"><a href=\"#lru\" class=\"headerlink\" title=\"lru\"></a>lru</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//LRU Cache</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"container/list\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> CacheNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    key   <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    value <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCacheNode</span><span class=\"params\">(k, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> *<span class=\"title\">CacheNode</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;CacheNode&#123;k, v&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Lru <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    capacity <span class=\"keyword\">int</span></span><br><span class=\"line\">    dlist    *list.List</span><br><span class=\"line\">    cacheMap <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]*list.Element</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLru</span><span class=\"params\">(<span class=\"built_in\">cap</span> <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Lru</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Lru&#123;</span><br><span class=\"line\">        capacity: <span class=\"built_in\">cap</span>,</span><br><span class=\"line\">        dlist:    list.New(),</span><br><span class=\"line\">        cacheMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]*list.Element),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *Lru)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lru.dlist.Len()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *Lru)</span> <span class=\"title\">Set</span><span class=\"params\">(k, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> lru.dlist == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error.New(<span class=\"string\">\"lrucache need init\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//key exist, movetoFront, update value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pElement, ok := lru.cacheMap[k]; ok &#123;</span><br><span class=\"line\">      lru.dlist.MoveToFront(pElement)</span><br><span class=\"line\">      pElement.Value.(*CacheNode).Value = v</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//not exist</span></span><br><span class=\"line\">  newElement := lru.dlist.PushFront(&amp;CacheNode&#123;k, v&#125;)</span><br><span class=\"line\">  lru.cacheMap[k] = newElement</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lru.dlist.Len() &gt; lru.capacity &#123;</span><br><span class=\"line\">      lastElement := lru.dlist.Back()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> lastElement == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      cacheNode := lastElement.Value.(*CacheNode)</span><br><span class=\"line\">      <span class=\"built_in\">delete</span>(lru.cacheMap, cacheNode.key)</span><br><span class=\"line\">      lru.dlist.Remove(lastElement)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *Lru)</span> <span class=\"title\">Get</span><span class=\"params\">(k <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> lru.cacheMap == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> v, errors.New(<span class=\"string\">\"LRUCache need init\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> pElement, ok := lru.cacheMap[k]; ok &#123;</span><br><span class=\"line\">      lru.dlist.MoveToFront(pElement)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pElement.Value.(*CacheNode).Value, <span class=\"literal\">nil</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(lru *LRUCache)</span> <span class=\"title\">Remove</span><span class=\"params\">(k <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> lru.cacheMap == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> pElement, ok := lru.cacheMap[k]; ok &#123;</span><br><span class=\"line\">      cacheNode := pElement.Value.(*CacheNode)</span><br><span class=\"line\">      <span class=\"built_in\">delete</span>(lru.cacheMap, cacheNode.Key)</span><br><span class=\"line\">      lru.dlist.Remove(pElement)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"c++11基础整理","date":"2018-04-08T16:00:00.000Z","_content":"\n### 关键字：\n- override： 确保成员函数为虚并覆盖基类的虚函数\n    + 用于标注在派生类函数中\n    + 该函数必须和基类的函数有相同的签名(即参数，返回值，const等一致)\n    + 在基类中，该函数必须声明为virtual\n\n- final: 一旦成员虚函数被声明为final，派生类不能再覆盖它\n    + 表面它的派生类不能再覆盖写该成员函数；\n    + 该函数在其基类声明必须为virutal\n<!-- more -->\n```c++\nstruct A\n{\n    virtual void foo();\n    void bar();\n    void foo2();\n};\n \nstruct B : A\n{\n    void foo() const override; // 错误： B::foo 不覆写 A::foo\n                               // （签名不匹配）\n    void foo() override;       // OK ： B::foo 覆写 A::foo\n    void bar() override;       // 错误： A::bar 非虚\n    void foo2();               // OK, 运行多态时不能覆盖基类函数\n};\n```\n```c++\n    struct Base\n    {\n        virtual void foo();\n    };\n     \n    struct A : Base\n    {\n        void foo() final; // A::foo 被覆写且是最终覆写\n        void bar() final; // 错误：非虚函数不能被覆写或是 final\n    };\n     \n    struct B final : A // struct B 为 final\n    {\n        void foo() override; // 错误： foo 不能被覆写，因为它在 A 中是 final\n    };\n     \n    struct C : B // 错误： B 为 final\n    {\n    };\n```\n\n### NULL 与 nullptr\n\n- NULL是一个宏，值为0；\n- typedef decltype(nullptr) nullptr_t;\n\n```c++\nvoid foo(int);      // (1)\nvoid foo(void*);    // (2)\n\nfoo(NULL);      //期望调用（2），但实际上模板推断为（1）\nfoo(nullptr);   //模板推断为（2）\n```\n\n\n关联关系(人与气候)，聚合关系（人与人群）、组合关系（人和脑袋），依赖关系（人和空气）\n\n","source":"_posts/c++11_base.md","raw":"---\ntitle: c++11基础整理\ndate: 2018-04-09\ncategories:\n    - c++\ntags:\n    - c++11\n---\n\n### 关键字：\n- override： 确保成员函数为虚并覆盖基类的虚函数\n    + 用于标注在派生类函数中\n    + 该函数必须和基类的函数有相同的签名(即参数，返回值，const等一致)\n    + 在基类中，该函数必须声明为virtual\n\n- final: 一旦成员虚函数被声明为final，派生类不能再覆盖它\n    + 表面它的派生类不能再覆盖写该成员函数；\n    + 该函数在其基类声明必须为virutal\n<!-- more -->\n```c++\nstruct A\n{\n    virtual void foo();\n    void bar();\n    void foo2();\n};\n \nstruct B : A\n{\n    void foo() const override; // 错误： B::foo 不覆写 A::foo\n                               // （签名不匹配）\n    void foo() override;       // OK ： B::foo 覆写 A::foo\n    void bar() override;       // 错误： A::bar 非虚\n    void foo2();               // OK, 运行多态时不能覆盖基类函数\n};\n```\n```c++\n    struct Base\n    {\n        virtual void foo();\n    };\n     \n    struct A : Base\n    {\n        void foo() final; // A::foo 被覆写且是最终覆写\n        void bar() final; // 错误：非虚函数不能被覆写或是 final\n    };\n     \n    struct B final : A // struct B 为 final\n    {\n        void foo() override; // 错误： foo 不能被覆写，因为它在 A 中是 final\n    };\n     \n    struct C : B // 错误： B 为 final\n    {\n    };\n```\n\n### NULL 与 nullptr\n\n- NULL是一个宏，值为0；\n- typedef decltype(nullptr) nullptr_t;\n\n```c++\nvoid foo(int);      // (1)\nvoid foo(void*);    // (2)\n\nfoo(NULL);      //期望调用（2），但实际上模板推断为（1）\nfoo(nullptr);   //模板推断为（2）\n```\n\n\n关联关系(人与气候)，聚合关系（人与人群）、组合关系（人和脑袋），依赖关系（人和空气）\n\n","slug":"c++11_base","published":1,"updated":"2018-12-25T11:08:38.384Z","_id":"cjq3l8d4r00065shabmnjpnz6","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"关键字：\"><a href=\"#关键字：\" class=\"headerlink\" title=\"关键字：\"></a>关键字：</h3><ul>\n<li><p>override： 确保成员函数为虚并覆盖基类的虚函数</p>\n<ul>\n<li>用于标注在派生类函数中</li>\n<li>该函数必须和基类的函数有相同的签名(即参数，返回值，const等一致)</li>\n<li>在基类中，该函数必须声明为virtual</li>\n</ul>\n</li>\n<li><p>final: 一旦成员虚函数被声明为final，派生类不能再覆盖它</p>\n<ul>\n<li>表面它的派生类不能再覆盖写该成员函数；</li>\n<li>该函数在其基类声明必须为virutal<a id=\"more\"></a>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span> :</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> override</span>; <span class=\"comment\">// 错误： B::foo 不覆写 A::foo</span></span><br><span class=\"line\">                               <span class=\"comment\">// （签名不匹配）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> override</span>;       <span class=\"comment\">// OK ： B::foo 覆写 A::foo</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> override</span>;       <span class=\"comment\">// 错误： A::bar 非虚</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span>;               <span class=\"comment\">// OK, 运行多态时不能覆盖基类函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> :</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> final</span>; <span class=\"comment\">// A::foo 被覆写且是最终覆写</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> final</span>; <span class=\"comment\">// 错误：非虚函数不能被覆写或是 final</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span> <span class=\"title\">final</span> :</span> A <span class=\"comment\">// struct B 为 final</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> override</span>; <span class=\"comment\">// 错误： foo 不能被覆写，因为它在 A 中是 final</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C</span> :</span> B <span class=\"comment\">// 错误： B 为 final</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NULL-与-nullptr\"><a href=\"#NULL-与-nullptr\" class=\"headerlink\" title=\"NULL 与 nullptr\"></a>NULL 与 nullptr</h3><ul>\n<li>NULL是一个宏，值为0；</li>\n<li>typedef decltype(nullptr) nullptr_t;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;      <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>*)</span></span>;    <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"literal\">NULL</span>);      <span class=\"comment\">//期望调用（2），但实际上模板推断为（1）</span></span><br><span class=\"line\">foo(<span class=\"literal\">nullptr</span>);   <span class=\"comment\">//模板推断为（2）</span></span><br></pre></td></tr></table></figure>\n<p>关联关系(人与气候)，聚合关系（人与人群）、组合关系（人和脑袋），依赖关系（人和空气）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"关键字：\"><a href=\"#关键字：\" class=\"headerlink\" title=\"关键字：\"></a>关键字：</h3><ul>\n<li><p>override： 确保成员函数为虚并覆盖基类的虚函数</p>\n<ul>\n<li>用于标注在派生类函数中</li>\n<li>该函数必须和基类的函数有相同的签名(即参数，返回值，const等一致)</li>\n<li>在基类中，该函数必须声明为virtual</li>\n</ul>\n</li>\n<li><p>final: 一旦成员虚函数被声明为final，派生类不能再覆盖它</p>\n<ul>\n<li>表面它的派生类不能再覆盖写该成员函数；</li>\n<li>该函数在其基类声明必须为virutal","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span> :</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> override</span>; <span class=\"comment\">// 错误： B::foo 不覆写 A::foo</span></span><br><span class=\"line\">                               <span class=\"comment\">// （签名不匹配）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> override</span>;       <span class=\"comment\">// OK ： B::foo 覆写 A::foo</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> override</span>;       <span class=\"comment\">// 错误： A::bar 非虚</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span>;               <span class=\"comment\">// OK, 运行多态时不能覆盖基类函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> :</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> final</span>; <span class=\"comment\">// A::foo 被覆写且是最终覆写</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> final</span>; <span class=\"comment\">// 错误：非虚函数不能被覆写或是 final</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span> <span class=\"title\">final</span> :</span> A <span class=\"comment\">// struct B 为 final</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> override</span>; <span class=\"comment\">// 错误： foo 不能被覆写，因为它在 A 中是 final</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C</span> :</span> B <span class=\"comment\">// 错误： B 为 final</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NULL-与-nullptr\"><a href=\"#NULL-与-nullptr\" class=\"headerlink\" title=\"NULL 与 nullptr\"></a>NULL 与 nullptr</h3><ul>\n<li>NULL是一个宏，值为0；</li>\n<li>typedef decltype(nullptr) nullptr_t;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;      <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>*)</span></span>;    <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"literal\">NULL</span>);      <span class=\"comment\">//期望调用（2），但实际上模板推断为（1）</span></span><br><span class=\"line\">foo(<span class=\"literal\">nullptr</span>);   <span class=\"comment\">//模板推断为（2）</span></span><br></pre></td></tr></table></figure>\n<p>关联关系(人与气候)，聚合关系（人与人群）、组合关系（人和脑袋），依赖关系（人和空气）</p>"},{"title":"rgw put object流程","date":"2018-04-14T16:00:00.000Z","_content":"\n### op处理\n\n/// rgw/rgw_op.cc\n```c++\nvoid RGWPutObj::execute(){\n    \n}\n```","source":"_posts/rgw_put_object.md","raw":"---\ntitle: rgw put object流程\ndate: 2018-04-15\ncategories:\n    - ceph\ntags:\n    - s3\n    - rgw\n    - ceph\n---\n\n### op处理\n\n/// rgw/rgw_op.cc\n```c++\nvoid RGWPutObj::execute(){\n    \n}\n```","slug":"rgw_put_object","published":1,"updated":"2018-12-25T11:19:37.885Z","_id":"cjq3l8d4s00085sha9whvdw9w","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"op处理\"><a href=\"#op处理\" class=\"headerlink\" title=\"op处理\"></a>op处理</h3><p>/// rgw/rgw_op.cc<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RGWPutObj::execute()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"op处理\"><a href=\"#op处理\" class=\"headerlink\" title=\"op处理\"></a>op处理</h3><p>/// rgw/rgw_op.cc<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> RGWPutObj::execute()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"paxos","date":"2018-04-14T16:00:00.000Z","_content":"\n### 这个leader节点是怎么确定的？\n答案：zookeeper系统自己选举出来的，所有server节点（observer除外），都参与这个选举。这样做的好处是：当现在leader挂掉了之后，系统可以重新选举一个节点做leader。\nZookeeper的选举算法能保证：只要超过半数节点还活着，就一定能选举出唯一个一个节点作为leader。\n\n- 选举发生时机\n   - 当任何一个节点进入looking状态时，选举开始，进入looking状态有如下原因：\n   1、节点刚启动，使自己进入选举状态\n   2、发现leader节点挂掉了\n   Zookeeper中的leader怎么知道follower还活着？follower怎么知道leader还活着？leader会定时向follower发ping消息；follower会定时向leader发ping消息。当发现无法ping通leader时，就会将自己的状态改为LOOKING，并发起新一轮选举。处于选举模式时，zookeeper服务不可用。\n- 一个节点成为leader条件\n    一个节点要成为leader，必须得到至少n/2+1（即半数以上节点）投票，实际上，在实现时，还可以考虑其它规则，比如节点权重。\n    为什么要保证至少n/2+1的节点同意？因为这样能保证本节点得到多数派的支持。因为每一个节点，只能支持一个节点成为leader，因此，只要一个节点获得至少n/2+1选票，就一定会比其它任何节点得到的选票多。\n    这个规则意味着，如果超过半数以上的节点挂掉，zookeeper是选举不出leader节点的，因此，zookeeper集群最多允许n/2节点故障。\n\n### 选举leader中涉及到的问题\n  选举算法目标是确保一定要选出一个唯一的leader节点。这有两层含义：\n    - 一定要选出一个节点作为leader\n    - 这个leader一定要唯一\n    为此，要解决如下问题：\n      1、在一次选举中，节点应该把票投给谁？\n      规则：每个节点有一个唯一id，在选举中，节点总是把票投给id最大的那个节点，这样，id大的节点更有可能成为leader，天生就是做领导的料。\n      2、在一次选举过程中，有些节点由于没有启动而没参加（有些人去国外了，没有赶上这次大选，当他回国后，进入looking状态，要发起选举，怎么办？），后来这个节点启动了，此时要求选举，怎么解决？\n      3、运行过程中，leader节点挂掉了，怎么办？\n        此时其它节点会发现leader挂了，会发起新一轮选举，最后选出新leader。\n\n### 尝试解决方案\n    1、直接指定一个节点做leader，例如，永远都让id最大节点当leader，这个想法最简单。问题：这个节点挂了怎么办？这会出现单点问题。\n    2、每次选举中，让活着节点中，id最大节点当leader。问题：1、其它节点怎么知道活着节点中，谁id最大？\n\n### 选举算法流程\n    选举开始时，每个节点为自己生成一张投票，推荐自己成为leader，并把投票发送给其它节点，这相当于paxos算法中的proposer角色。接下来，节点启动一个接收线程接收其它节点发送过来的投票，并对选票进行处理，这相当于paxos中的acceptor角色。简单说，节点之间通过这种消息发送（投票），最终选举出leader。\n\n    当收到其他它节点的选票之后，会和自己的投票比较，如果比自己的投票好（比如推荐的leader的id更大，选举轮数更新），则更新自己的选票，接下来把收到的选票放在选票列表里（该列表存储了所有节点的投票，是一个key-value结构，key为节点的id，value为该节点的投票）。并再次把自己的投票发送给其它节点。\n\n    接下来节点会统计选票列表中每个节点获得的票数，如果有一个节点获得超过半数的选票，则认为该节点是leader。如果本节点就是，则将自身的状态置为leading，表明自己是leader；否则将自己的状态置为following，表明自己是follower。\n\n    通过若干轮的消息交换，最终，会有一个节点获得超过一半的选票而成为leader。这种方法的精髓在于，每个节点在不需要获得所有节点的信息（投票结果）的前提下，达成一致意见，选出leader\n\n### 运行机制\n    选举leader之后，只有leader节点才能发起提案，其他节点(Peon角色)根据本地历史选择接受或拒绝Leader的提案，并向Leader回复结果。Leader统计并提交超过半数Paxos节点接受的提案。\n\n### 常规过程（Normal Case）\n常规服务状态下存在一个唯一的Leader以及一个已经确认的大多数节点Quorum，Leader将每个写请求被封装成一个新的提案发送给Quorum中的每个节点，其过程如下，注意这里的Quorum固定：\n- Leader将提案追加在本地Log，并向Quorum中的所有节点发送begin消息，消息中携带提案值、Pn及指向前一条提案version的last_commit；\n- Peon收到begin消息，如果accept过更高的pn则忽略，否则提案写入本地Log并返回accept消息。同时Peon会将当前的lease过期掉，在下一次收到lease前不再提供服务；\n- Leader收到全部Quorum的accept后进行commit。将Log项在本地DB执行，返回调用方并向所有Quorum节点发送commit消息；\n- Peon收到commit消息同样在本地DB执行，完成commit；\n- Leader追加lease消息将整个集群带入到active状态。\n\n### 选主（Leader Election）\nPeon的Lease超时或Leader任何消息超时都会将整个集群带回到Probing状态，整个集群确定新的Members并最终进入Election状态进行选主。每个节点会在本地维护并在通信中交互选主轮次编号election_epoch，election_epoch单调递增，会在开始选主和选主结束时都加一，因此可以根据其奇偶来判断是否在选主轮次，选主过程如下：\n\n将election_epoch加1，向Monmap中的所有其他节点发送Propose消息；\n收到Propose消息的节点进入election状态并仅对更新的election_epoch且Rank值大于自己的消息答复Ack。这里的Rank简单的由ip大小决定。每个节点在每个election_epoch仅做一次Ack，这就保证最终的Leader一定获得了大多数节点的支持；\n发送Propose的节点统计收到的Ack数，超时时间内收到Monmap中大多数的ack后可进入victory过程，这些发送ack的节点形成Quorum，election_epoch加1，结束Election阶段并向Quorum中所有节点发送Victory消息，并告知自己的epoch及当前Quorum，之后进入Leader状态；\n\n收到VICTORY消息的节点完成Election，进入Peon状态；\n","source":"_posts/paxos.md","raw":"---\n  title: paxos\n  date: 2018-04-15\n  categories:\n    - ceph\n  tags:\n    - paxos \n---\n\n### 这个leader节点是怎么确定的？\n答案：zookeeper系统自己选举出来的，所有server节点（observer除外），都参与这个选举。这样做的好处是：当现在leader挂掉了之后，系统可以重新选举一个节点做leader。\nZookeeper的选举算法能保证：只要超过半数节点还活着，就一定能选举出唯一个一个节点作为leader。\n\n- 选举发生时机\n   - 当任何一个节点进入looking状态时，选举开始，进入looking状态有如下原因：\n   1、节点刚启动，使自己进入选举状态\n   2、发现leader节点挂掉了\n   Zookeeper中的leader怎么知道follower还活着？follower怎么知道leader还活着？leader会定时向follower发ping消息；follower会定时向leader发ping消息。当发现无法ping通leader时，就会将自己的状态改为LOOKING，并发起新一轮选举。处于选举模式时，zookeeper服务不可用。\n- 一个节点成为leader条件\n    一个节点要成为leader，必须得到至少n/2+1（即半数以上节点）投票，实际上，在实现时，还可以考虑其它规则，比如节点权重。\n    为什么要保证至少n/2+1的节点同意？因为这样能保证本节点得到多数派的支持。因为每一个节点，只能支持一个节点成为leader，因此，只要一个节点获得至少n/2+1选票，就一定会比其它任何节点得到的选票多。\n    这个规则意味着，如果超过半数以上的节点挂掉，zookeeper是选举不出leader节点的，因此，zookeeper集群最多允许n/2节点故障。\n\n### 选举leader中涉及到的问题\n  选举算法目标是确保一定要选出一个唯一的leader节点。这有两层含义：\n    - 一定要选出一个节点作为leader\n    - 这个leader一定要唯一\n    为此，要解决如下问题：\n      1、在一次选举中，节点应该把票投给谁？\n      规则：每个节点有一个唯一id，在选举中，节点总是把票投给id最大的那个节点，这样，id大的节点更有可能成为leader，天生就是做领导的料。\n      2、在一次选举过程中，有些节点由于没有启动而没参加（有些人去国外了，没有赶上这次大选，当他回国后，进入looking状态，要发起选举，怎么办？），后来这个节点启动了，此时要求选举，怎么解决？\n      3、运行过程中，leader节点挂掉了，怎么办？\n        此时其它节点会发现leader挂了，会发起新一轮选举，最后选出新leader。\n\n### 尝试解决方案\n    1、直接指定一个节点做leader，例如，永远都让id最大节点当leader，这个想法最简单。问题：这个节点挂了怎么办？这会出现单点问题。\n    2、每次选举中，让活着节点中，id最大节点当leader。问题：1、其它节点怎么知道活着节点中，谁id最大？\n\n### 选举算法流程\n    选举开始时，每个节点为自己生成一张投票，推荐自己成为leader，并把投票发送给其它节点，这相当于paxos算法中的proposer角色。接下来，节点启动一个接收线程接收其它节点发送过来的投票，并对选票进行处理，这相当于paxos中的acceptor角色。简单说，节点之间通过这种消息发送（投票），最终选举出leader。\n\n    当收到其他它节点的选票之后，会和自己的投票比较，如果比自己的投票好（比如推荐的leader的id更大，选举轮数更新），则更新自己的选票，接下来把收到的选票放在选票列表里（该列表存储了所有节点的投票，是一个key-value结构，key为节点的id，value为该节点的投票）。并再次把自己的投票发送给其它节点。\n\n    接下来节点会统计选票列表中每个节点获得的票数，如果有一个节点获得超过半数的选票，则认为该节点是leader。如果本节点就是，则将自身的状态置为leading，表明自己是leader；否则将自己的状态置为following，表明自己是follower。\n\n    通过若干轮的消息交换，最终，会有一个节点获得超过一半的选票而成为leader。这种方法的精髓在于，每个节点在不需要获得所有节点的信息（投票结果）的前提下，达成一致意见，选出leader\n\n### 运行机制\n    选举leader之后，只有leader节点才能发起提案，其他节点(Peon角色)根据本地历史选择接受或拒绝Leader的提案，并向Leader回复结果。Leader统计并提交超过半数Paxos节点接受的提案。\n\n### 常规过程（Normal Case）\n常规服务状态下存在一个唯一的Leader以及一个已经确认的大多数节点Quorum，Leader将每个写请求被封装成一个新的提案发送给Quorum中的每个节点，其过程如下，注意这里的Quorum固定：\n- Leader将提案追加在本地Log，并向Quorum中的所有节点发送begin消息，消息中携带提案值、Pn及指向前一条提案version的last_commit；\n- Peon收到begin消息，如果accept过更高的pn则忽略，否则提案写入本地Log并返回accept消息。同时Peon会将当前的lease过期掉，在下一次收到lease前不再提供服务；\n- Leader收到全部Quorum的accept后进行commit。将Log项在本地DB执行，返回调用方并向所有Quorum节点发送commit消息；\n- Peon收到commit消息同样在本地DB执行，完成commit；\n- Leader追加lease消息将整个集群带入到active状态。\n\n### 选主（Leader Election）\nPeon的Lease超时或Leader任何消息超时都会将整个集群带回到Probing状态，整个集群确定新的Members并最终进入Election状态进行选主。每个节点会在本地维护并在通信中交互选主轮次编号election_epoch，election_epoch单调递增，会在开始选主和选主结束时都加一，因此可以根据其奇偶来判断是否在选主轮次，选主过程如下：\n\n将election_epoch加1，向Monmap中的所有其他节点发送Propose消息；\n收到Propose消息的节点进入election状态并仅对更新的election_epoch且Rank值大于自己的消息答复Ack。这里的Rank简单的由ip大小决定。每个节点在每个election_epoch仅做一次Ack，这就保证最终的Leader一定获得了大多数节点的支持；\n发送Propose的节点统计收到的Ack数，超时时间内收到Monmap中大多数的ack后可进入victory过程，这些发送ack的节点形成Quorum，election_epoch加1，结束Election阶段并向Quorum中所有节点发送Victory消息，并告知自己的epoch及当前Quorum，之后进入Leader状态；\n\n收到VICTORY消息的节点完成Election，进入Peon状态；\n","slug":"paxos","published":1,"updated":"2020-02-14T03:40:47.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9o1sea000000svum9wrk6ph","content":"<h3 id=\"这个leader节点是怎么确定的？\"><a href=\"#这个leader节点是怎么确定的？\" class=\"headerlink\" title=\"这个leader节点是怎么确定的？\"></a>这个leader节点是怎么确定的？</h3><p>答案：zookeeper系统自己选举出来的，所有server节点（observer除外），都参与这个选举。这样做的好处是：当现在leader挂掉了之后，系统可以重新选举一个节点做leader。<br>Zookeeper的选举算法能保证：只要超过半数节点还活着，就一定能选举出唯一个一个节点作为leader。</p>\n<ul>\n<li>选举发生时机<ul>\n<li>当任何一个节点进入looking状态时，选举开始，进入looking状态有如下原因：<br>1、节点刚启动，使自己进入选举状态<br>2、发现leader节点挂掉了<br>Zookeeper中的leader怎么知道follower还活着？follower怎么知道leader还活着？leader会定时向follower发ping消息；follower会定时向leader发ping消息。当发现无法ping通leader时，就会将自己的状态改为LOOKING，并发起新一轮选举。处于选举模式时，zookeeper服务不可用。</li>\n</ul>\n</li>\n<li>一个节点成为leader条件<br>  一个节点要成为leader，必须得到至少n/2+1（即半数以上节点）投票，实际上，在实现时，还可以考虑其它规则，比如节点权重。<br>  为什么要保证至少n/2+1的节点同意？因为这样能保证本节点得到多数派的支持。因为每一个节点，只能支持一个节点成为leader，因此，只要一个节点获得至少n/2+1选票，就一定会比其它任何节点得到的选票多。<br>  这个规则意味着，如果超过半数以上的节点挂掉，zookeeper是选举不出leader节点的，因此，zookeeper集群最多允许n/2节点故障。</li>\n</ul>\n<h3 id=\"选举leader中涉及到的问题\"><a href=\"#选举leader中涉及到的问题\" class=\"headerlink\" title=\"选举leader中涉及到的问题\"></a>选举leader中涉及到的问题</h3><p>  选举算法目标是确保一定要选出一个唯一的leader节点。这有两层含义：</p>\n<pre><code>- 一定要选出一个节点作为leader\n- 这个leader一定要唯一\n为此，要解决如下问题：\n  1、在一次选举中，节点应该把票投给谁？\n  规则：每个节点有一个唯一id，在选举中，节点总是把票投给id最大的那个节点，这样，id大的节点更有可能成为leader，天生就是做领导的料。\n  2、在一次选举过程中，有些节点由于没有启动而没参加（有些人去国外了，没有赶上这次大选，当他回国后，进入looking状态，要发起选举，怎么办？），后来这个节点启动了，此时要求选举，怎么解决？\n  3、运行过程中，leader节点挂掉了，怎么办？\n    此时其它节点会发现leader挂了，会发起新一轮选举，最后选出新leader。\n</code></pre><h3 id=\"尝试解决方案\"><a href=\"#尝试解决方案\" class=\"headerlink\" title=\"尝试解决方案\"></a>尝试解决方案</h3><pre><code>1、直接指定一个节点做leader，例如，永远都让id最大节点当leader，这个想法最简单。问题：这个节点挂了怎么办？这会出现单点问题。\n2、每次选举中，让活着节点中，id最大节点当leader。问题：1、其它节点怎么知道活着节点中，谁id最大？\n</code></pre><h3 id=\"选举算法流程\"><a href=\"#选举算法流程\" class=\"headerlink\" title=\"选举算法流程\"></a>选举算法流程</h3><pre><code>选举开始时，每个节点为自己生成一张投票，推荐自己成为leader，并把投票发送给其它节点，这相当于paxos算法中的proposer角色。接下来，节点启动一个接收线程接收其它节点发送过来的投票，并对选票进行处理，这相当于paxos中的acceptor角色。简单说，节点之间通过这种消息发送（投票），最终选举出leader。\n\n当收到其他它节点的选票之后，会和自己的投票比较，如果比自己的投票好（比如推荐的leader的id更大，选举轮数更新），则更新自己的选票，接下来把收到的选票放在选票列表里（该列表存储了所有节点的投票，是一个key-value结构，key为节点的id，value为该节点的投票）。并再次把自己的投票发送给其它节点。\n\n接下来节点会统计选票列表中每个节点获得的票数，如果有一个节点获得超过半数的选票，则认为该节点是leader。如果本节点就是，则将自身的状态置为leading，表明自己是leader；否则将自己的状态置为following，表明自己是follower。\n\n通过若干轮的消息交换，最终，会有一个节点获得超过一半的选票而成为leader。这种方法的精髓在于，每个节点在不需要获得所有节点的信息（投票结果）的前提下，达成一致意见，选出leader\n</code></pre><h3 id=\"运行机制\"><a href=\"#运行机制\" class=\"headerlink\" title=\"运行机制\"></a>运行机制</h3><pre><code>选举leader之后，只有leader节点才能发起提案，其他节点(Peon角色)根据本地历史选择接受或拒绝Leader的提案，并向Leader回复结果。Leader统计并提交超过半数Paxos节点接受的提案。\n</code></pre><h3 id=\"常规过程（Normal-Case）\"><a href=\"#常规过程（Normal-Case）\" class=\"headerlink\" title=\"常规过程（Normal Case）\"></a>常规过程（Normal Case）</h3><p>常规服务状态下存在一个唯一的Leader以及一个已经确认的大多数节点Quorum，Leader将每个写请求被封装成一个新的提案发送给Quorum中的每个节点，其过程如下，注意这里的Quorum固定：</p>\n<ul>\n<li>Leader将提案追加在本地Log，并向Quorum中的所有节点发送begin消息，消息中携带提案值、Pn及指向前一条提案version的last_commit；</li>\n<li>Peon收到begin消息，如果accept过更高的pn则忽略，否则提案写入本地Log并返回accept消息。同时Peon会将当前的lease过期掉，在下一次收到lease前不再提供服务；</li>\n<li>Leader收到全部Quorum的accept后进行commit。将Log项在本地DB执行，返回调用方并向所有Quorum节点发送commit消息；</li>\n<li>Peon收到commit消息同样在本地DB执行，完成commit；</li>\n<li>Leader追加lease消息将整个集群带入到active状态。</li>\n</ul>\n<h3 id=\"选主（Leader-Election）\"><a href=\"#选主（Leader-Election）\" class=\"headerlink\" title=\"选主（Leader Election）\"></a>选主（Leader Election）</h3><p>Peon的Lease超时或Leader任何消息超时都会将整个集群带回到Probing状态，整个集群确定新的Members并最终进入Election状态进行选主。每个节点会在本地维护并在通信中交互选主轮次编号election_epoch，election_epoch单调递增，会在开始选主和选主结束时都加一，因此可以根据其奇偶来判断是否在选主轮次，选主过程如下：</p>\n<p>将election_epoch加1，向Monmap中的所有其他节点发送Propose消息；<br>收到Propose消息的节点进入election状态并仅对更新的election_epoch且Rank值大于自己的消息答复Ack。这里的Rank简单的由ip大小决定。每个节点在每个election_epoch仅做一次Ack，这就保证最终的Leader一定获得了大多数节点的支持；<br>发送Propose的节点统计收到的Ack数，超时时间内收到Monmap中大多数的ack后可进入victory过程，这些发送ack的节点形成Quorum，election_epoch加1，结束Election阶段并向Quorum中所有节点发送Victory消息，并告知自己的epoch及当前Quorum，之后进入Leader状态；</p>\n<p>收到VICTORY消息的节点完成Election，进入Peon状态；</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"这个leader节点是怎么确定的？\"><a href=\"#这个leader节点是怎么确定的？\" class=\"headerlink\" title=\"这个leader节点是怎么确定的？\"></a>这个leader节点是怎么确定的？</h3><p>答案：zookeeper系统自己选举出来的，所有server节点（observer除外），都参与这个选举。这样做的好处是：当现在leader挂掉了之后，系统可以重新选举一个节点做leader。<br>Zookeeper的选举算法能保证：只要超过半数节点还活着，就一定能选举出唯一个一个节点作为leader。</p>\n<ul>\n<li>选举发生时机<ul>\n<li>当任何一个节点进入looking状态时，选举开始，进入looking状态有如下原因：<br>1、节点刚启动，使自己进入选举状态<br>2、发现leader节点挂掉了<br>Zookeeper中的leader怎么知道follower还活着？follower怎么知道leader还活着？leader会定时向follower发ping消息；follower会定时向leader发ping消息。当发现无法ping通leader时，就会将自己的状态改为LOOKING，并发起新一轮选举。处于选举模式时，zookeeper服务不可用。</li>\n</ul>\n</li>\n<li>一个节点成为leader条件<br>  一个节点要成为leader，必须得到至少n/2+1（即半数以上节点）投票，实际上，在实现时，还可以考虑其它规则，比如节点权重。<br>  为什么要保证至少n/2+1的节点同意？因为这样能保证本节点得到多数派的支持。因为每一个节点，只能支持一个节点成为leader，因此，只要一个节点获得至少n/2+1选票，就一定会比其它任何节点得到的选票多。<br>  这个规则意味着，如果超过半数以上的节点挂掉，zookeeper是选举不出leader节点的，因此，zookeeper集群最多允许n/2节点故障。</li>\n</ul>\n<h3 id=\"选举leader中涉及到的问题\"><a href=\"#选举leader中涉及到的问题\" class=\"headerlink\" title=\"选举leader中涉及到的问题\"></a>选举leader中涉及到的问题</h3><p>  选举算法目标是确保一定要选出一个唯一的leader节点。这有两层含义：</p>\n<pre><code>- 一定要选出一个节点作为leader\n- 这个leader一定要唯一\n为此，要解决如下问题：\n  1、在一次选举中，节点应该把票投给谁？\n  规则：每个节点有一个唯一id，在选举中，节点总是把票投给id最大的那个节点，这样，id大的节点更有可能成为leader，天生就是做领导的料。\n  2、在一次选举过程中，有些节点由于没有启动而没参加（有些人去国外了，没有赶上这次大选，当他回国后，进入looking状态，要发起选举，怎么办？），后来这个节点启动了，此时要求选举，怎么解决？\n  3、运行过程中，leader节点挂掉了，怎么办？\n    此时其它节点会发现leader挂了，会发起新一轮选举，最后选出新leader。\n</code></pre><h3 id=\"尝试解决方案\"><a href=\"#尝试解决方案\" class=\"headerlink\" title=\"尝试解决方案\"></a>尝试解决方案</h3><pre><code>1、直接指定一个节点做leader，例如，永远都让id最大节点当leader，这个想法最简单。问题：这个节点挂了怎么办？这会出现单点问题。\n2、每次选举中，让活着节点中，id最大节点当leader。问题：1、其它节点怎么知道活着节点中，谁id最大？\n</code></pre><h3 id=\"选举算法流程\"><a href=\"#选举算法流程\" class=\"headerlink\" title=\"选举算法流程\"></a>选举算法流程</h3><pre><code>选举开始时，每个节点为自己生成一张投票，推荐自己成为leader，并把投票发送给其它节点，这相当于paxos算法中的proposer角色。接下来，节点启动一个接收线程接收其它节点发送过来的投票，并对选票进行处理，这相当于paxos中的acceptor角色。简单说，节点之间通过这种消息发送（投票），最终选举出leader。\n\n当收到其他它节点的选票之后，会和自己的投票比较，如果比自己的投票好（比如推荐的leader的id更大，选举轮数更新），则更新自己的选票，接下来把收到的选票放在选票列表里（该列表存储了所有节点的投票，是一个key-value结构，key为节点的id，value为该节点的投票）。并再次把自己的投票发送给其它节点。\n\n接下来节点会统计选票列表中每个节点获得的票数，如果有一个节点获得超过半数的选票，则认为该节点是leader。如果本节点就是，则将自身的状态置为leading，表明自己是leader；否则将自己的状态置为following，表明自己是follower。\n\n通过若干轮的消息交换，最终，会有一个节点获得超过一半的选票而成为leader。这种方法的精髓在于，每个节点在不需要获得所有节点的信息（投票结果）的前提下，达成一致意见，选出leader\n</code></pre><h3 id=\"运行机制\"><a href=\"#运行机制\" class=\"headerlink\" title=\"运行机制\"></a>运行机制</h3><pre><code>选举leader之后，只有leader节点才能发起提案，其他节点(Peon角色)根据本地历史选择接受或拒绝Leader的提案，并向Leader回复结果。Leader统计并提交超过半数Paxos节点接受的提案。\n</code></pre><h3 id=\"常规过程（Normal-Case）\"><a href=\"#常规过程（Normal-Case）\" class=\"headerlink\" title=\"常规过程（Normal Case）\"></a>常规过程（Normal Case）</h3><p>常规服务状态下存在一个唯一的Leader以及一个已经确认的大多数节点Quorum，Leader将每个写请求被封装成一个新的提案发送给Quorum中的每个节点，其过程如下，注意这里的Quorum固定：</p>\n<ul>\n<li>Leader将提案追加在本地Log，并向Quorum中的所有节点发送begin消息，消息中携带提案值、Pn及指向前一条提案version的last_commit；</li>\n<li>Peon收到begin消息，如果accept过更高的pn则忽略，否则提案写入本地Log并返回accept消息。同时Peon会将当前的lease过期掉，在下一次收到lease前不再提供服务；</li>\n<li>Leader收到全部Quorum的accept后进行commit。将Log项在本地DB执行，返回调用方并向所有Quorum节点发送commit消息；</li>\n<li>Peon收到commit消息同样在本地DB执行，完成commit；</li>\n<li>Leader追加lease消息将整个集群带入到active状态。</li>\n</ul>\n<h3 id=\"选主（Leader-Election）\"><a href=\"#选主（Leader-Election）\" class=\"headerlink\" title=\"选主（Leader Election）\"></a>选主（Leader Election）</h3><p>Peon的Lease超时或Leader任何消息超时都会将整个集群带回到Probing状态，整个集群确定新的Members并最终进入Election状态进行选主。每个节点会在本地维护并在通信中交互选主轮次编号election_epoch，election_epoch单调递增，会在开始选主和选主结束时都加一，因此可以根据其奇偶来判断是否在选主轮次，选主过程如下：</p>\n<p>将election_epoch加1，向Monmap中的所有其他节点发送Propose消息；<br>收到Propose消息的节点进入election状态并仅对更新的election_epoch且Rank值大于自己的消息答复Ack。这里的Rank简单的由ip大小决定。每个节点在每个election_epoch仅做一次Ack，这就保证最终的Leader一定获得了大多数节点的支持；<br>发送Propose的节点统计收到的Ack数，超时时间内收到Monmap中大多数的ack后可进入victory过程，这些发送ack的节点形成Quorum，election_epoch加1，结束Election阶段并向Quorum中所有节点发送Victory消息，并告知自己的epoch及当前Quorum，之后进入Leader状态；</p>\n<p>收到VICTORY消息的节点完成Election，进入Peon状态；</p>\n"},{"title":"Golang反射包的实现原理（The Laws of Reflection)","date":"2018-04-14T16:00:00.000Z","_content":"\n### 类型和接口(Types and interfaces)\n\n因为反射是建立在类型系统(type system)上的。所以我们从Go的类型入手\n- Go是静态类型化的。每个变量都有一个静态类型\n```go\ntype MyInt int\n\nvar i int\nvar j MyInt\n```\ni的类型就是int，而j的类型就是MyInt；这里的变量i和j具有不同的静态变量，虽然他们拥有相同的底层类型(underlying type),如果不显示的进行强制类型转换他们是不能相互赋值的；\n\n类型(type)中非常重要的一类(category)就是接口类型(interface type); 一个接口就表示一组确定的方法（method）集合。一个接口变量能存储任意的具体值（这里的具体concrete就是指非接口的non-interface)，只要这个具体值所属的类型实现了这个接口的所有方法。\n\n一个大家都很熟悉的例子是io.Reader和io.Writer，类型Reader和类型Writer来自io包:\n```go\ntype Reader interface{\n  Read(p []byte) (n int, err error)\n}\n\ntype Writer interface{\n  Write(p []byte)(n int, err error)\n}\n```\n实现了上面的Read方法（或Write方法）的任意类型都可以说实现了io.Reader接口（或io.Writer接口)。 这就意味着io.Reader接口变量能够保存任意Read方法的类型所定义的值；\n\n```go\nvar r io.Reader\nr = os.Stdin\nr = bufio.NewReader(r)\nr = new(bytes.Buffer)\n```\n明确r到底保存了什么样的具体值非常重要，但是这里r的类型却总是io.Reader：注意Go是静态类型化的，而r的静态类型是io.Reader。\n\n一个非常非常重要的接口类型例子就是空接口:\n```go\ninterface{}\n```\n空接口表示方法集合为空并且可以保存任意值，因为任意值都有0个或者更多方法。\n- 有些人说Go的接口是动态类型化的，但这是一种误导。\n- Go的接口都是静态类型化的：一个接口类型变量总是保持同一个静态类型，即使在运行时它【接口类型变量】保存的值类型发生变化，这些值总是满足这个接口。\n\n### 接口的表示(The representation of an interface)\n\n- 一个接口类型变量存储了一个pair：\n  - 赋值给这个接口变量的具体值\n  - 该值的类型描述符\n- 更进一步的说：\n  - 这个\" 值 \"是实现了这个接口的底层具体数据项(underlying concrete data item)\n  - 这个\" 类型 \"是描述了那个接口底层具体数据项(item)的全类型(full type)\n```go\nvar r io.Reader\ntty, err := os.OpenFile(\"/dev/tty\", os.O_RDWR, 0)\nif err != nil{\n  return nil, err\n}\nr = tty\n```\n- 分析\n  - 接口变量r 包含了（value, type) 对，即（tty, os.File) //(底层具体数据项, 描述底层具体数据项的全类型)\n  - 除了Read方法以外，类型os.File也实现了其它方法；即使这个接口值仅仅提供了对Read方法的访问，这个接口值内部仍然带有关于这个值的全部类型信息。这就是为什么我们能干下面这些事儿：\n```go\nvar w io.Writer\nw = r.(io.Writer)\n```\n赋值操作中的表达式是一个类型断言（type assertion）；它所断言的是r中存储的项（item）也实现了io.Writer接口，所以我们可以把它赋值给w。<br>\n赋值操作完毕以后，w将会包含 (tty, *os.File)对;w中的pair跟r中的pair是同样的。\n接口的静态类型决定了能用接口变量调用哪些方法，即使接口里存的具体值内部可能还有一堆其它方法；\n\n接口定义的方法集合是该种接口变量所保存的具体值所含有的方法集合的一个子集，通过这个接口变量只能调用这个接口定义过的方法，没法通过这个接口变量调用其它任何方法；\n```go\nvar empty interface{}\nempty = w\n```\nempty，也能包含同样的pair即(tty, *os.File)。这样的话就很方便了，一个空接口可以保存任意值和我们所需要的关于所保存值的全部信息。\n- 一个接口中的pair总有（值，具体类型）这样的格式，而不能有（值，接口类型）这样的格式。\n- 接口不能保存接口值（也就是说，你没法把一个接口变量值存储到一个接口变量中，只能把一个具体类型的值存储到一个接口变量中。）\n\n### 反射\n####  第一反射定律(the first law of reflection)\n- 从接口值到反射对象的反射\n  反射是一种检查存储在接口变量中的（类型，值）对的机制。\n```go\nvar x float64 = 3.4\nfmt.Println(\"type:\", reflect.TypeOf(x))   //type: float64\nfmt.Println(\"value:\", reflect.ValueOf(x)) //Valueof方法会返回一个Value类型的对象\n\n//TypeOf函数原型\nfunc TypeOf(i interface{}) Type\n```\n当我们调用reflect.Typeof(x)的时候，x首先被保存到一个空接口中，这个空接口然后被作为参数传递。reflect.Typeof 会把这个空接口拆包（unpack）恢复出类型信息。\n\n```go\nvar x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\"type:\", v.Type())  //返回值的静态类型；就是说如果定义了type MyInt int64，那么这个函数返回的是MyInt类型而不是int64，\nfmt.Println(\"kind is float64:\", v.kind() == reflect.Float64) //返回值的底层类型，是说如果定义了type MyInt int64，那么这个函数返回的是int64类型而不是MyInt类型，\nfmt.Println(\"value:\", v.Float())\n\ntype: float64\nkind is float64: true\nvalue: 3.4\n```\n\n反射库有两特殊性质：\n  - 为了保持API简单，Value的”setter”和“getter”类型的方法操作的是可以包含某个值的最大类型；\n    - 比如，所有的有符号整型，只有针对int64类型的方法，因为它是所有的有符号整型中最大的一个类型。也就是说，Value的Int方法返回的是一个int64，同时SetInt的参数类型采用的是一个int64；\n```go\nvar x uint8 = 'x'\nv := reflect.ValueOf(x)\nfmt.Println(\"type:\", v.Type()) // uint8.\nfmt.Println(\"kind is uint8: \", v.Kind() == reflect.Uint8) // true.\nx = uint8(v.Uint())// v.Uint returns a uint64.看到啦嘛？这个地方必须进行强制类型转换！\n```\n  - 反射对象（reflection object）的Kind描述的是底层类型（underlying type），而不是静态类型（static type）\n\n### 第二反射定律（The second law of reflection）\n#### 从反射队形到接口值的反射\n\n给定一个reflect.Value，我们能用Interface方法把它恢复成一个接口值；效果上就是这个Interface方法把类型和值的信息打包成一个接口表示并且返回结果：\n```go\n// func (v Value) Interface() interface{}\n\ny := v.Interface().(float64)\nfmt.Println(y)\n```\n我们甚至可以做得更好一些，fmt.Println等方法的参数是一个空接口类型的值，所以我们可以让fmt包自己在内部完成我们在上面代码中做的工作。因此，为了正确打印一个reflect.Value，我们只需把Interface方法的返回值直接传递给这个格式化输出例程：\n```go\nfmt.Preintln(v.Interface())\nfmt.Printf(\"value is %7.1e\\n\", v.Interface())\n```\n我们不需要对v.Interface方法的结果调用类型断言（type-assert)为float64；空接口类型值内部包含有具体值的类型信息，并且Printf方法会把它恢复出来。\n\nInterface方法是Valueof函数的逆，除了它的返回值的类型总是interface{}静态类型。\n\n### 第三反射定律\n#### 为了修改一个反射对象，值必须是settable的\n```go\nvar x float64 = 3.4\nv := reflect.ValueOf(x)\nv.SetFloat(7.1) // Error: will panic\n\n//panic: reflect.Value.SetFloat using unaddressable value\n```\n问题不是出在值7.1不是可以寻址的，而是出在v不是settable的。Settability是Value的一条性质，而且，不是所有的Value都具备这条性质;\nValue的CanSet方法用与测试一个Value的settablity；\n```go\nvar  x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\"settability of v:\", v.CanSet())\n\n//\nsettability of v: false\n```\n传递了x的一个副本给reflect.Valueof函数，所以作为reflect.Valueof参数被创造出来的接口值只是x的一个副本，而不是x本身。\n```go\nvar x float64 = 3.4\np := reflect.ValueOf(&x)\nfmt.Println(\"type of p:\", p.Type())\nfmt.Println(\"settability of p:\", p.CanSet())\n//\ntype of p: *float64\nsettability of p: false\n```\n反射对象p不是settable的，但是我们想要设置的不是p，而是（效果上来说）*p。为了得到p指向的东西，我们调用Value的Elem方法;这样就能迂回绕过指针，同时把结果保存在叫v的Value中.\n```go\nv := p.Elem()\nfmt.Println(\"settability of v:\", v.CanSet())\nv.SetFloat(7.1)\nfmt.Println(v.Interface())\nfmt.Println(x)\n\n//\nsettability of v: true\n7.1\n7.1\n```\n反射理解起来有点困难，但是它确实正在做编程语言要做的，尽管是通过掩盖了所发生的一切的反射Types和Vlues来实现的。这样好了，你就直接记住反射Values为了修改它们所表示的东西必须要有这些东西的地址。\n\n### structs\nv本身不是一个指针，它只是从一个指针派生来的。出现这种情况的一个常见的方法是当使用反射来修改一个structure的各个域的时候。只要我们有这个structure的地址，我们就能修改它的各个域。\n```go\ntype T struct{\n  A int\n  B string\n}\n\nt := T{23, \"skidoo\"}\ns := reflect.ValueOf(&t).Elem()\ntypeOfT := s.Type()   //把s.Type()返回的Type对象复制给typeofT，typeofT也是一个反射\n\nfor i:=0; i<s.NumField(); i++{\n  f := s.Field(i)   //迭代s的各个域，注意每个域仍然是反射。\n  fmt.Printf(\"%d: %s %s = %v\\n\", i, typeOfT.Field(i).Name, f.Type(), f.Interface())//提取了每个域的名字\n}\n\ns.Field(0).SetInt(77)\ns.Field(1).SetString(\"Sunset Strip\")\nfmt.Println(\"t is now\", t)\n\n//\n0: A int = 23\n1: B string = skidoo\nt is now {77 Sunset Strip}\n```\n","source":"_posts/go_reflect.md","raw":"---\n  title: Golang反射包的实现原理（The Laws of Reflection)\n  date: 2018-04-15\n  categories:\n  - golang\n  tags:\n    - golang\n---\n\n### 类型和接口(Types and interfaces)\n\n因为反射是建立在类型系统(type system)上的。所以我们从Go的类型入手\n- Go是静态类型化的。每个变量都有一个静态类型\n```go\ntype MyInt int\n\nvar i int\nvar j MyInt\n```\ni的类型就是int，而j的类型就是MyInt；这里的变量i和j具有不同的静态变量，虽然他们拥有相同的底层类型(underlying type),如果不显示的进行强制类型转换他们是不能相互赋值的；\n\n类型(type)中非常重要的一类(category)就是接口类型(interface type); 一个接口就表示一组确定的方法（method）集合。一个接口变量能存储任意的具体值（这里的具体concrete就是指非接口的non-interface)，只要这个具体值所属的类型实现了这个接口的所有方法。\n\n一个大家都很熟悉的例子是io.Reader和io.Writer，类型Reader和类型Writer来自io包:\n```go\ntype Reader interface{\n  Read(p []byte) (n int, err error)\n}\n\ntype Writer interface{\n  Write(p []byte)(n int, err error)\n}\n```\n实现了上面的Read方法（或Write方法）的任意类型都可以说实现了io.Reader接口（或io.Writer接口)。 这就意味着io.Reader接口变量能够保存任意Read方法的类型所定义的值；\n\n```go\nvar r io.Reader\nr = os.Stdin\nr = bufio.NewReader(r)\nr = new(bytes.Buffer)\n```\n明确r到底保存了什么样的具体值非常重要，但是这里r的类型却总是io.Reader：注意Go是静态类型化的，而r的静态类型是io.Reader。\n\n一个非常非常重要的接口类型例子就是空接口:\n```go\ninterface{}\n```\n空接口表示方法集合为空并且可以保存任意值，因为任意值都有0个或者更多方法。\n- 有些人说Go的接口是动态类型化的，但这是一种误导。\n- Go的接口都是静态类型化的：一个接口类型变量总是保持同一个静态类型，即使在运行时它【接口类型变量】保存的值类型发生变化，这些值总是满足这个接口。\n\n### 接口的表示(The representation of an interface)\n\n- 一个接口类型变量存储了一个pair：\n  - 赋值给这个接口变量的具体值\n  - 该值的类型描述符\n- 更进一步的说：\n  - 这个\" 值 \"是实现了这个接口的底层具体数据项(underlying concrete data item)\n  - 这个\" 类型 \"是描述了那个接口底层具体数据项(item)的全类型(full type)\n```go\nvar r io.Reader\ntty, err := os.OpenFile(\"/dev/tty\", os.O_RDWR, 0)\nif err != nil{\n  return nil, err\n}\nr = tty\n```\n- 分析\n  - 接口变量r 包含了（value, type) 对，即（tty, os.File) //(底层具体数据项, 描述底层具体数据项的全类型)\n  - 除了Read方法以外，类型os.File也实现了其它方法；即使这个接口值仅仅提供了对Read方法的访问，这个接口值内部仍然带有关于这个值的全部类型信息。这就是为什么我们能干下面这些事儿：\n```go\nvar w io.Writer\nw = r.(io.Writer)\n```\n赋值操作中的表达式是一个类型断言（type assertion）；它所断言的是r中存储的项（item）也实现了io.Writer接口，所以我们可以把它赋值给w。<br>\n赋值操作完毕以后，w将会包含 (tty, *os.File)对;w中的pair跟r中的pair是同样的。\n接口的静态类型决定了能用接口变量调用哪些方法，即使接口里存的具体值内部可能还有一堆其它方法；\n\n接口定义的方法集合是该种接口变量所保存的具体值所含有的方法集合的一个子集，通过这个接口变量只能调用这个接口定义过的方法，没法通过这个接口变量调用其它任何方法；\n```go\nvar empty interface{}\nempty = w\n```\nempty，也能包含同样的pair即(tty, *os.File)。这样的话就很方便了，一个空接口可以保存任意值和我们所需要的关于所保存值的全部信息。\n- 一个接口中的pair总有（值，具体类型）这样的格式，而不能有（值，接口类型）这样的格式。\n- 接口不能保存接口值（也就是说，你没法把一个接口变量值存储到一个接口变量中，只能把一个具体类型的值存储到一个接口变量中。）\n\n### 反射\n####  第一反射定律(the first law of reflection)\n- 从接口值到反射对象的反射\n  反射是一种检查存储在接口变量中的（类型，值）对的机制。\n```go\nvar x float64 = 3.4\nfmt.Println(\"type:\", reflect.TypeOf(x))   //type: float64\nfmt.Println(\"value:\", reflect.ValueOf(x)) //Valueof方法会返回一个Value类型的对象\n\n//TypeOf函数原型\nfunc TypeOf(i interface{}) Type\n```\n当我们调用reflect.Typeof(x)的时候，x首先被保存到一个空接口中，这个空接口然后被作为参数传递。reflect.Typeof 会把这个空接口拆包（unpack）恢复出类型信息。\n\n```go\nvar x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\"type:\", v.Type())  //返回值的静态类型；就是说如果定义了type MyInt int64，那么这个函数返回的是MyInt类型而不是int64，\nfmt.Println(\"kind is float64:\", v.kind() == reflect.Float64) //返回值的底层类型，是说如果定义了type MyInt int64，那么这个函数返回的是int64类型而不是MyInt类型，\nfmt.Println(\"value:\", v.Float())\n\ntype: float64\nkind is float64: true\nvalue: 3.4\n```\n\n反射库有两特殊性质：\n  - 为了保持API简单，Value的”setter”和“getter”类型的方法操作的是可以包含某个值的最大类型；\n    - 比如，所有的有符号整型，只有针对int64类型的方法，因为它是所有的有符号整型中最大的一个类型。也就是说，Value的Int方法返回的是一个int64，同时SetInt的参数类型采用的是一个int64；\n```go\nvar x uint8 = 'x'\nv := reflect.ValueOf(x)\nfmt.Println(\"type:\", v.Type()) // uint8.\nfmt.Println(\"kind is uint8: \", v.Kind() == reflect.Uint8) // true.\nx = uint8(v.Uint())// v.Uint returns a uint64.看到啦嘛？这个地方必须进行强制类型转换！\n```\n  - 反射对象（reflection object）的Kind描述的是底层类型（underlying type），而不是静态类型（static type）\n\n### 第二反射定律（The second law of reflection）\n#### 从反射队形到接口值的反射\n\n给定一个reflect.Value，我们能用Interface方法把它恢复成一个接口值；效果上就是这个Interface方法把类型和值的信息打包成一个接口表示并且返回结果：\n```go\n// func (v Value) Interface() interface{}\n\ny := v.Interface().(float64)\nfmt.Println(y)\n```\n我们甚至可以做得更好一些，fmt.Println等方法的参数是一个空接口类型的值，所以我们可以让fmt包自己在内部完成我们在上面代码中做的工作。因此，为了正确打印一个reflect.Value，我们只需把Interface方法的返回值直接传递给这个格式化输出例程：\n```go\nfmt.Preintln(v.Interface())\nfmt.Printf(\"value is %7.1e\\n\", v.Interface())\n```\n我们不需要对v.Interface方法的结果调用类型断言（type-assert)为float64；空接口类型值内部包含有具体值的类型信息，并且Printf方法会把它恢复出来。\n\nInterface方法是Valueof函数的逆，除了它的返回值的类型总是interface{}静态类型。\n\n### 第三反射定律\n#### 为了修改一个反射对象，值必须是settable的\n```go\nvar x float64 = 3.4\nv := reflect.ValueOf(x)\nv.SetFloat(7.1) // Error: will panic\n\n//panic: reflect.Value.SetFloat using unaddressable value\n```\n问题不是出在值7.1不是可以寻址的，而是出在v不是settable的。Settability是Value的一条性质，而且，不是所有的Value都具备这条性质;\nValue的CanSet方法用与测试一个Value的settablity；\n```go\nvar  x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\"settability of v:\", v.CanSet())\n\n//\nsettability of v: false\n```\n传递了x的一个副本给reflect.Valueof函数，所以作为reflect.Valueof参数被创造出来的接口值只是x的一个副本，而不是x本身。\n```go\nvar x float64 = 3.4\np := reflect.ValueOf(&x)\nfmt.Println(\"type of p:\", p.Type())\nfmt.Println(\"settability of p:\", p.CanSet())\n//\ntype of p: *float64\nsettability of p: false\n```\n反射对象p不是settable的，但是我们想要设置的不是p，而是（效果上来说）*p。为了得到p指向的东西，我们调用Value的Elem方法;这样就能迂回绕过指针，同时把结果保存在叫v的Value中.\n```go\nv := p.Elem()\nfmt.Println(\"settability of v:\", v.CanSet())\nv.SetFloat(7.1)\nfmt.Println(v.Interface())\nfmt.Println(x)\n\n//\nsettability of v: true\n7.1\n7.1\n```\n反射理解起来有点困难，但是它确实正在做编程语言要做的，尽管是通过掩盖了所发生的一切的反射Types和Vlues来实现的。这样好了，你就直接记住反射Values为了修改它们所表示的东西必须要有这些东西的地址。\n\n### structs\nv本身不是一个指针，它只是从一个指针派生来的。出现这种情况的一个常见的方法是当使用反射来修改一个structure的各个域的时候。只要我们有这个structure的地址，我们就能修改它的各个域。\n```go\ntype T struct{\n  A int\n  B string\n}\n\nt := T{23, \"skidoo\"}\ns := reflect.ValueOf(&t).Elem()\ntypeOfT := s.Type()   //把s.Type()返回的Type对象复制给typeofT，typeofT也是一个反射\n\nfor i:=0; i<s.NumField(); i++{\n  f := s.Field(i)   //迭代s的各个域，注意每个域仍然是反射。\n  fmt.Printf(\"%d: %s %s = %v\\n\", i, typeOfT.Field(i).Name, f.Type(), f.Interface())//提取了每个域的名字\n}\n\ns.Field(0).SetInt(77)\ns.Field(1).SetString(\"Sunset Strip\")\nfmt.Println(\"t is now\", t)\n\n//\n0: A int = 23\n1: B string = skidoo\nt is now {77 Sunset Strip}\n```\n","slug":"go_reflect","published":1,"updated":"2020-07-11T02:34:19.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckch1k2xl0000gkvuqpwbmd8u","content":"<h3 id=\"类型和接口-Types-and-interfaces\"><a href=\"#类型和接口-Types-and-interfaces\" class=\"headerlink\" title=\"类型和接口(Types and interfaces)\"></a>类型和接口(Types and interfaces)</h3><p>因为反射是建立在类型系统(type system)上的。所以我们从Go的类型入手</p>\n<ul>\n<li>Go是静态类型化的。每个变量都有一个静态类型<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyInt <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> j MyInt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>i的类型就是int，而j的类型就是MyInt；这里的变量i和j具有不同的静态变量，虽然他们拥有相同的底层类型(underlying type),如果不显示的进行强制类型转换他们是不能相互赋值的；</p>\n<p>类型(type)中非常重要的一类(category)就是接口类型(interface type); 一个接口就表示一组确定的方法（method）集合。一个接口变量能存储任意的具体值（这里的具体concrete就是指非接口的non-interface)，只要这个具体值所属的类型实现了这个接口的所有方法。</p>\n<p>一个大家都很熟悉的例子是io.Reader和io.Writer，类型Reader和类型Writer来自io包:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">  Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">  Write(p []<span class=\"keyword\">byte</span>)(n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现了上面的Read方法（或Write方法）的任意类型都可以说实现了io.Reader接口（或io.Writer接口)。 这就意味着io.Reader接口变量能够保存任意Read方法的类型所定义的值；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> r io.Reader</span><br><span class=\"line\">r = os.Stdin</span><br><span class=\"line\">r = bufio.NewReader(r)</span><br><span class=\"line\">r = <span class=\"built_in\">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>\n<p>明确r到底保存了什么样的具体值非常重要，但是这里r的类型却总是io.Reader：注意Go是静态类型化的，而r的静态类型是io.Reader。</p>\n<p>一个非常非常重要的接口类型例子就是空接口:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>空接口表示方法集合为空并且可以保存任意值，因为任意值都有0个或者更多方法。</p>\n<ul>\n<li>有些人说Go的接口是动态类型化的，但这是一种误导。</li>\n<li>Go的接口都是静态类型化的：一个接口类型变量总是保持同一个静态类型，即使在运行时它【接口类型变量】保存的值类型发生变化，这些值总是满足这个接口。</li>\n</ul>\n<h3 id=\"接口的表示-The-representation-of-an-interface\"><a href=\"#接口的表示-The-representation-of-an-interface\" class=\"headerlink\" title=\"接口的表示(The representation of an interface)\"></a>接口的表示(The representation of an interface)</h3><ul>\n<li>一个接口类型变量存储了一个pair：<ul>\n<li>赋值给这个接口变量的具体值</li>\n<li>该值的类型描述符</li>\n</ul>\n</li>\n<li><p>更进一步的说：</p>\n<ul>\n<li>这个” 值 “是实现了这个接口的底层具体数据项(underlying concrete data item)</li>\n<li>这个” 类型 “是描述了那个接口底层具体数据项(item)的全类型(full type)<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> r io.Reader</span><br><span class=\"line\">tty, err := os.OpenFile(<span class=\"string\">\"/dev/tty\"</span>, os.O_RDWR, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">r = tty</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>分析</p>\n<ul>\n<li>接口变量r 包含了（value, type) 对，即（tty, os.File) //(底层具体数据项, 描述底层具体数据项的全类型)</li>\n<li>除了Read方法以外，类型os.File也实现了其它方法；即使这个接口值仅仅提供了对Read方法的访问，这个接口值内部仍然带有关于这个值的全部类型信息。这就是为什么我们能干下面这些事儿：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w io.Writer</span><br><span class=\"line\">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>赋值操作中的表达式是一个类型断言（type assertion）；它所断言的是r中存储的项（item）也实现了io.Writer接口，所以我们可以把它赋值给w。<br><br>赋值操作完毕以后，w将会包含 (tty, *os.File)对;w中的pair跟r中的pair是同样的。<br>接口的静态类型决定了能用接口变量调用哪些方法，即使接口里存的具体值内部可能还有一堆其它方法；</p>\n<p>接口定义的方法集合是该种接口变量所保存的具体值所含有的方法集合的一个子集，通过这个接口变量只能调用这个接口定义过的方法，没法通过这个接口变量调用其它任何方法；<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> empty <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">empty = w</span><br></pre></td></tr></table></figure></p>\n<p>empty，也能包含同样的pair即(tty, *os.File)。这样的话就很方便了，一个空接口可以保存任意值和我们所需要的关于所保存值的全部信息。</p>\n<ul>\n<li>一个接口中的pair总有（值，具体类型）这样的格式，而不能有（值，接口类型）这样的格式。</li>\n<li>接口不能保存接口值（也就是说，你没法把一个接口变量值存储到一个接口变量中，只能把一个具体类型的值存储到一个接口变量中。）</li>\n</ul>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><h4 id=\"第一反射定律-the-first-law-of-reflection\"><a href=\"#第一反射定律-the-first-law-of-reflection\" class=\"headerlink\" title=\"第一反射定律(the first law of reflection)\"></a>第一反射定律(the first law of reflection)</h4><ul>\n<li>从接口值到反射对象的反射<br>反射是一种检查存储在接口变量中的（类型，值）对的机制。<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type:\"</span>, reflect.TypeOf(x))   <span class=\"comment\">//type: float64</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"value:\"</span>, reflect.ValueOf(x)) <span class=\"comment\">//Valueof方法会返回一个Value类型的对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TypeOf函数原型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TypeOf</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Type</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当我们调用reflect.Typeof(x)的时候，x首先被保存到一个空接口中，这个空接口然后被作为参数传递。reflect.Typeof 会把这个空接口拆包（unpack）恢复出类型信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type:\"</span>, v.Type())  <span class=\"comment\">//返回值的静态类型；就是说如果定义了type MyInt int64，那么这个函数返回的是MyInt类型而不是int64，</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"kind is float64:\"</span>, v.kind() == reflect.Float64) <span class=\"comment\">//返回值的底层类型，是说如果定义了type MyInt int64，那么这个函数返回的是int64类型而不是MyInt类型，</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"value:\"</span>, v.Float())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span>: <span class=\"keyword\">float64</span></span><br><span class=\"line\">kind is <span class=\"keyword\">float64</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">value: <span class=\"number\">3.4</span></span><br></pre></td></tr></table></figure>\n<p>反射库有两特殊性质：</p>\n<ul>\n<li><p>为了保持API简单，Value的”setter”和“getter”类型的方法操作的是可以包含某个值的最大类型；</p>\n<ul>\n<li>比如，所有的有符号整型，只有针对int64类型的方法，因为它是所有的有符号整型中最大的一个类型。也就是说，Value的Int方法返回的是一个int64，同时SetInt的参数类型采用的是一个int64；<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">uint8</span> = <span class=\"string\">'x'</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type:\"</span>, v.Type()) <span class=\"comment\">// uint8.</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"kind is uint8: \"</span>, v.Kind() == reflect.Uint8) <span class=\"comment\">// true.</span></span><br><span class=\"line\">x = <span class=\"keyword\">uint8</span>(v.Uint())<span class=\"comment\">// v.Uint returns a uint64.看到啦嘛？这个地方必须进行强制类型转换！</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>反射对象（reflection object）的Kind描述的是底层类型（underlying type），而不是静态类型（static type）</p>\n</li>\n</ul>\n<h3 id=\"第二反射定律（The-second-law-of-reflection）\"><a href=\"#第二反射定律（The-second-law-of-reflection）\" class=\"headerlink\" title=\"第二反射定律（The second law of reflection）\"></a>第二反射定律（The second law of reflection）</h3><h4 id=\"从反射队形到接口值的反射\"><a href=\"#从反射队形到接口值的反射\" class=\"headerlink\" title=\"从反射队形到接口值的反射\"></a>从反射队形到接口值的反射</h4><p>给定一个reflect.Value，我们能用Interface方法把它恢复成一个接口值；效果上就是这个Interface方法把类型和值的信息打包成一个接口表示并且返回结果：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func (v Value) Interface() interface&#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">y := v.Interface().(<span class=\"keyword\">float64</span>)</span><br><span class=\"line\">fmt.Println(y)</span><br></pre></td></tr></table></figure></p>\n<p>我们甚至可以做得更好一些，fmt.Println等方法的参数是一个空接口类型的值，所以我们可以让fmt包自己在内部完成我们在上面代码中做的工作。因此，为了正确打印一个reflect.Value，我们只需把Interface方法的返回值直接传递给这个格式化输出例程：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Preintln(v.Interface())</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"value is %7.1e\\n\"</span>, v.Interface())</span><br></pre></td></tr></table></figure></p>\n<p>我们不需要对v.Interface方法的结果调用类型断言（type-assert)为float64；空接口类型值内部包含有具体值的类型信息，并且Printf方法会把它恢复出来。</p>\n<p>Interface方法是Valueof函数的逆，除了它的返回值的类型总是interface{}静态类型。</p>\n<h3 id=\"第三反射定律\"><a href=\"#第三反射定律\" class=\"headerlink\" title=\"第三反射定律\"></a>第三反射定律</h3><h4 id=\"为了修改一个反射对象，值必须是settable的\"><a href=\"#为了修改一个反射对象，值必须是settable的\" class=\"headerlink\" title=\"为了修改一个反射对象，值必须是settable的\"></a>为了修改一个反射对象，值必须是settable的</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">v.SetFloat(<span class=\"number\">7.1</span>) <span class=\"comment\">// Error: will panic</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//panic: reflect.Value.SetFloat using unaddressable value</span></span><br></pre></td></tr></table></figure>\n<p>问题不是出在值7.1不是可以寻址的，而是出在v不是settable的。Settability是Value的一条性质，而且，不是所有的Value都具备这条性质;<br>Value的CanSet方法用与测试一个Value的settablity；<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span>  x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"settability of v:\"</span>, v.CanSet())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">settability of v: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>传递了x的一个副本给reflect.Valueof函数，所以作为reflect.Valueof参数被创造出来的接口值只是x的一个副本，而不是x本身。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">p := reflect.ValueOf(&amp;x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type of p:\"</span>, p.Type())</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"settability of p:\"</span>, p.CanSet())</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> of p: *<span class=\"keyword\">float64</span></span><br><span class=\"line\">settability of p: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>反射对象p不是settable的，但是我们想要设置的不是p，而是（效果上来说）*p。为了得到p指向的东西，我们调用Value的Elem方法;这样就能迂回绕过指针，同时把结果保存在叫v的Value中.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v := p.Elem()</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"settability of v:\"</span>, v.CanSet())</span><br><span class=\"line\">v.SetFloat(<span class=\"number\">7.1</span>)</span><br><span class=\"line\">fmt.Println(v.Interface())</span><br><span class=\"line\">fmt.Println(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">settability of v: <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">7.1</span></span><br><span class=\"line\"><span class=\"number\">7.1</span></span><br></pre></td></tr></table></figure></p>\n<p>反射理解起来有点困难，但是它确实正在做编程语言要做的，尽管是通过掩盖了所发生的一切的反射Types和Vlues来实现的。这样好了，你就直接记住反射Values为了修改它们所表示的东西必须要有这些东西的地址。</p>\n<h3 id=\"structs\"><a href=\"#structs\" class=\"headerlink\" title=\"structs\"></a>structs</h3><p>v本身不是一个指针，它只是从一个指针派生来的。出现这种情况的一个常见的方法是当使用反射来修改一个structure的各个域的时候。只要我们有这个structure的地址，我们就能修改它的各个域。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">  A <span class=\"keyword\">int</span></span><br><span class=\"line\">  B <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">t := T&#123;<span class=\"number\">23</span>, <span class=\"string\">\"skidoo\"</span>&#125;</span><br><span class=\"line\">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class=\"line\">typeOfT := s.Type()   <span class=\"comment\">//把s.Type()返回的Type对象复制给typeofT，typeofT也是一个反射</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;s.NumField(); i++&#123;</span><br><span class=\"line\">  f := s.Field(i)   <span class=\"comment\">//迭代s的各个域，注意每个域仍然是反射。</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"%d: %s %s = %v\\n\"</span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface())<span class=\"comment\">//提取了每个域的名字</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s.Field(<span class=\"number\">0</span>).SetInt(<span class=\"number\">77</span>)</span><br><span class=\"line\">s.Field(<span class=\"number\">1</span>).SetString(<span class=\"string\">\"Sunset Strip\"</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"t is now\"</span>, t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"number\">0</span>: A <span class=\"keyword\">int</span> = <span class=\"number\">23</span></span><br><span class=\"line\"><span class=\"number\">1</span>: B <span class=\"keyword\">string</span> = skidoo</span><br><span class=\"line\">t is now &#123;<span class=\"number\">77</span> Sunset Strip&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"类型和接口-Types-and-interfaces\"><a href=\"#类型和接口-Types-and-interfaces\" class=\"headerlink\" title=\"类型和接口(Types and interfaces)\"></a>类型和接口(Types and interfaces)</h3><p>因为反射是建立在类型系统(type system)上的。所以我们从Go的类型入手</p>\n<ul>\n<li>Go是静态类型化的。每个变量都有一个静态类型<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyInt <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> j MyInt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>i的类型就是int，而j的类型就是MyInt；这里的变量i和j具有不同的静态变量，虽然他们拥有相同的底层类型(underlying type),如果不显示的进行强制类型转换他们是不能相互赋值的；</p>\n<p>类型(type)中非常重要的一类(category)就是接口类型(interface type); 一个接口就表示一组确定的方法（method）集合。一个接口变量能存储任意的具体值（这里的具体concrete就是指非接口的non-interface)，只要这个具体值所属的类型实现了这个接口的所有方法。</p>\n<p>一个大家都很熟悉的例子是io.Reader和io.Writer，类型Reader和类型Writer来自io包:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">  Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">  Write(p []<span class=\"keyword\">byte</span>)(n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现了上面的Read方法（或Write方法）的任意类型都可以说实现了io.Reader接口（或io.Writer接口)。 这就意味着io.Reader接口变量能够保存任意Read方法的类型所定义的值；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> r io.Reader</span><br><span class=\"line\">r = os.Stdin</span><br><span class=\"line\">r = bufio.NewReader(r)</span><br><span class=\"line\">r = <span class=\"built_in\">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>\n<p>明确r到底保存了什么样的具体值非常重要，但是这里r的类型却总是io.Reader：注意Go是静态类型化的，而r的静态类型是io.Reader。</p>\n<p>一个非常非常重要的接口类型例子就是空接口:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>空接口表示方法集合为空并且可以保存任意值，因为任意值都有0个或者更多方法。</p>\n<ul>\n<li>有些人说Go的接口是动态类型化的，但这是一种误导。</li>\n<li>Go的接口都是静态类型化的：一个接口类型变量总是保持同一个静态类型，即使在运行时它【接口类型变量】保存的值类型发生变化，这些值总是满足这个接口。</li>\n</ul>\n<h3 id=\"接口的表示-The-representation-of-an-interface\"><a href=\"#接口的表示-The-representation-of-an-interface\" class=\"headerlink\" title=\"接口的表示(The representation of an interface)\"></a>接口的表示(The representation of an interface)</h3><ul>\n<li>一个接口类型变量存储了一个pair：<ul>\n<li>赋值给这个接口变量的具体值</li>\n<li>该值的类型描述符</li>\n</ul>\n</li>\n<li><p>更进一步的说：</p>\n<ul>\n<li>这个” 值 “是实现了这个接口的底层具体数据项(underlying concrete data item)</li>\n<li>这个” 类型 “是描述了那个接口底层具体数据项(item)的全类型(full type)<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> r io.Reader</span><br><span class=\"line\">tty, err := os.OpenFile(<span class=\"string\">\"/dev/tty\"</span>, os.O_RDWR, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">r = tty</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>分析</p>\n<ul>\n<li>接口变量r 包含了（value, type) 对，即（tty, os.File) //(底层具体数据项, 描述底层具体数据项的全类型)</li>\n<li>除了Read方法以外，类型os.File也实现了其它方法；即使这个接口值仅仅提供了对Read方法的访问，这个接口值内部仍然带有关于这个值的全部类型信息。这就是为什么我们能干下面这些事儿：<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w io.Writer</span><br><span class=\"line\">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>赋值操作中的表达式是一个类型断言（type assertion）；它所断言的是r中存储的项（item）也实现了io.Writer接口，所以我们可以把它赋值给w。<br><br>赋值操作完毕以后，w将会包含 (tty, *os.File)对;w中的pair跟r中的pair是同样的。<br>接口的静态类型决定了能用接口变量调用哪些方法，即使接口里存的具体值内部可能还有一堆其它方法；</p>\n<p>接口定义的方法集合是该种接口变量所保存的具体值所含有的方法集合的一个子集，通过这个接口变量只能调用这个接口定义过的方法，没法通过这个接口变量调用其它任何方法；<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> empty <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">empty = w</span><br></pre></td></tr></table></figure></p>\n<p>empty，也能包含同样的pair即(tty, *os.File)。这样的话就很方便了，一个空接口可以保存任意值和我们所需要的关于所保存值的全部信息。</p>\n<ul>\n<li>一个接口中的pair总有（值，具体类型）这样的格式，而不能有（值，接口类型）这样的格式。</li>\n<li>接口不能保存接口值（也就是说，你没法把一个接口变量值存储到一个接口变量中，只能把一个具体类型的值存储到一个接口变量中。）</li>\n</ul>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><h4 id=\"第一反射定律-the-first-law-of-reflection\"><a href=\"#第一反射定律-the-first-law-of-reflection\" class=\"headerlink\" title=\"第一反射定律(the first law of reflection)\"></a>第一反射定律(the first law of reflection)</h4><ul>\n<li>从接口值到反射对象的反射<br>反射是一种检查存储在接口变量中的（类型，值）对的机制。<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type:\"</span>, reflect.TypeOf(x))   <span class=\"comment\">//type: float64</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"value:\"</span>, reflect.ValueOf(x)) <span class=\"comment\">//Valueof方法会返回一个Value类型的对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TypeOf函数原型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TypeOf</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Type</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当我们调用reflect.Typeof(x)的时候，x首先被保存到一个空接口中，这个空接口然后被作为参数传递。reflect.Typeof 会把这个空接口拆包（unpack）恢复出类型信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type:\"</span>, v.Type())  <span class=\"comment\">//返回值的静态类型；就是说如果定义了type MyInt int64，那么这个函数返回的是MyInt类型而不是int64，</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"kind is float64:\"</span>, v.kind() == reflect.Float64) <span class=\"comment\">//返回值的底层类型，是说如果定义了type MyInt int64，那么这个函数返回的是int64类型而不是MyInt类型，</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"value:\"</span>, v.Float())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span>: <span class=\"keyword\">float64</span></span><br><span class=\"line\">kind is <span class=\"keyword\">float64</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">value: <span class=\"number\">3.4</span></span><br></pre></td></tr></table></figure>\n<p>反射库有两特殊性质：</p>\n<ul>\n<li><p>为了保持API简单，Value的”setter”和“getter”类型的方法操作的是可以包含某个值的最大类型；</p>\n<ul>\n<li>比如，所有的有符号整型，只有针对int64类型的方法，因为它是所有的有符号整型中最大的一个类型。也就是说，Value的Int方法返回的是一个int64，同时SetInt的参数类型采用的是一个int64；<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">uint8</span> = <span class=\"string\">'x'</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type:\"</span>, v.Type()) <span class=\"comment\">// uint8.</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"kind is uint8: \"</span>, v.Kind() == reflect.Uint8) <span class=\"comment\">// true.</span></span><br><span class=\"line\">x = <span class=\"keyword\">uint8</span>(v.Uint())<span class=\"comment\">// v.Uint returns a uint64.看到啦嘛？这个地方必须进行强制类型转换！</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>反射对象（reflection object）的Kind描述的是底层类型（underlying type），而不是静态类型（static type）</p>\n</li>\n</ul>\n<h3 id=\"第二反射定律（The-second-law-of-reflection）\"><a href=\"#第二反射定律（The-second-law-of-reflection）\" class=\"headerlink\" title=\"第二反射定律（The second law of reflection）\"></a>第二反射定律（The second law of reflection）</h3><h4 id=\"从反射队形到接口值的反射\"><a href=\"#从反射队形到接口值的反射\" class=\"headerlink\" title=\"从反射队形到接口值的反射\"></a>从反射队形到接口值的反射</h4><p>给定一个reflect.Value，我们能用Interface方法把它恢复成一个接口值；效果上就是这个Interface方法把类型和值的信息打包成一个接口表示并且返回结果：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func (v Value) Interface() interface&#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">y := v.Interface().(<span class=\"keyword\">float64</span>)</span><br><span class=\"line\">fmt.Println(y)</span><br></pre></td></tr></table></figure></p>\n<p>我们甚至可以做得更好一些，fmt.Println等方法的参数是一个空接口类型的值，所以我们可以让fmt包自己在内部完成我们在上面代码中做的工作。因此，为了正确打印一个reflect.Value，我们只需把Interface方法的返回值直接传递给这个格式化输出例程：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Preintln(v.Interface())</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"value is %7.1e\\n\"</span>, v.Interface())</span><br></pre></td></tr></table></figure></p>\n<p>我们不需要对v.Interface方法的结果调用类型断言（type-assert)为float64；空接口类型值内部包含有具体值的类型信息，并且Printf方法会把它恢复出来。</p>\n<p>Interface方法是Valueof函数的逆，除了它的返回值的类型总是interface{}静态类型。</p>\n<h3 id=\"第三反射定律\"><a href=\"#第三反射定律\" class=\"headerlink\" title=\"第三反射定律\"></a>第三反射定律</h3><h4 id=\"为了修改一个反射对象，值必须是settable的\"><a href=\"#为了修改一个反射对象，值必须是settable的\" class=\"headerlink\" title=\"为了修改一个反射对象，值必须是settable的\"></a>为了修改一个反射对象，值必须是settable的</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">v.SetFloat(<span class=\"number\">7.1</span>) <span class=\"comment\">// Error: will panic</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//panic: reflect.Value.SetFloat using unaddressable value</span></span><br></pre></td></tr></table></figure>\n<p>问题不是出在值7.1不是可以寻址的，而是出在v不是settable的。Settability是Value的一条性质，而且，不是所有的Value都具备这条性质;<br>Value的CanSet方法用与测试一个Value的settablity；<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span>  x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">v := reflect.ValueOf(x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"settability of v:\"</span>, v.CanSet())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">settability of v: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>传递了x的一个副本给reflect.Valueof函数，所以作为reflect.Valueof参数被创造出来的接口值只是x的一个副本，而不是x本身。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">float64</span> = <span class=\"number\">3.4</span></span><br><span class=\"line\">p := reflect.ValueOf(&amp;x)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"type of p:\"</span>, p.Type())</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"settability of p:\"</span>, p.CanSet())</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> of p: *<span class=\"keyword\">float64</span></span><br><span class=\"line\">settability of p: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>反射对象p不是settable的，但是我们想要设置的不是p，而是（效果上来说）*p。为了得到p指向的东西，我们调用Value的Elem方法;这样就能迂回绕过指针，同时把结果保存在叫v的Value中.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v := p.Elem()</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"settability of v:\"</span>, v.CanSet())</span><br><span class=\"line\">v.SetFloat(<span class=\"number\">7.1</span>)</span><br><span class=\"line\">fmt.Println(v.Interface())</span><br><span class=\"line\">fmt.Println(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">settability of v: <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">7.1</span></span><br><span class=\"line\"><span class=\"number\">7.1</span></span><br></pre></td></tr></table></figure></p>\n<p>反射理解起来有点困难，但是它确实正在做编程语言要做的，尽管是通过掩盖了所发生的一切的反射Types和Vlues来实现的。这样好了，你就直接记住反射Values为了修改它们所表示的东西必须要有这些东西的地址。</p>\n<h3 id=\"structs\"><a href=\"#structs\" class=\"headerlink\" title=\"structs\"></a>structs</h3><p>v本身不是一个指针，它只是从一个指针派生来的。出现这种情况的一个常见的方法是当使用反射来修改一个structure的各个域的时候。只要我们有这个structure的地址，我们就能修改它的各个域。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">  A <span class=\"keyword\">int</span></span><br><span class=\"line\">  B <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">t := T&#123;<span class=\"number\">23</span>, <span class=\"string\">\"skidoo\"</span>&#125;</span><br><span class=\"line\">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class=\"line\">typeOfT := s.Type()   <span class=\"comment\">//把s.Type()返回的Type对象复制给typeofT，typeofT也是一个反射</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;s.NumField(); i++&#123;</span><br><span class=\"line\">  f := s.Field(i)   <span class=\"comment\">//迭代s的各个域，注意每个域仍然是反射。</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"%d: %s %s = %v\\n\"</span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface())<span class=\"comment\">//提取了每个域的名字</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s.Field(<span class=\"number\">0</span>).SetInt(<span class=\"number\">77</span>)</span><br><span class=\"line\">s.Field(<span class=\"number\">1</span>).SetString(<span class=\"string\">\"Sunset Strip\"</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"t is now\"</span>, t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"number\">0</span>: A <span class=\"keyword\">int</span> = <span class=\"number\">23</span></span><br><span class=\"line\"><span class=\"number\">1</span>: B <span class=\"keyword\">string</span> = skidoo</span><br><span class=\"line\">t is now &#123;<span class=\"number\">77</span> Sunset Strip&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"markdown设置sublime默认打开","date":"2020-04-08T16:00:00.000Z","_content":"\n\n### 设置markdown的默认打开工具\n\n\t- win+R组合键打开运行对话框,输入regedit,打开注册表编辑器\n\t- 定位到计算机HKEY_CLASSES_ROOT项\n\t- HKEY_CLASSES_ROOT 右击，选择 新建-项,命名为 .md\n\t- 选中.md(这个项),双击右边的默认项，打开编辑字符串对话框,写 md_auto_file 确定退出\n\t\t(格式：后缀名_auto_file，后缀名即为你要关联的文件类型，如要关联.html，就填写 html_auto_file)\n\t- 再次对着HKEY_CLASSES_ROOT项单右击,新建项,命名为 md_auto_file\n\t- 选中md_auto_file，新建-项 设置项名为: HKEY_CLASSES_ROOTmd_auto_fileshellopencommand, 设置右边默认值为:\"sublime安装路径 %1\",\n\t\t例如:  \"D:\\sublime\\Sublime Text 3\\sublime_text.exe\" %1 [注意添加英文状态下的双引号及后面的 %1与前面有空格]\n\t- 定位到HKEY_CURRENT_USER/Software/classes，重复以上的步骤创建 .md, md_auto_file项并设值\n\t- 退出注册表编辑器,此时md文件已经关联到sublime，右键点击md文件你会发现右键菜单第一项变成了\"打开\"","source":"_posts/set_markdown_sublime.md","raw":"---\ntitle: markdown设置sublime默认打开\ndate: 2020-04-09\ncategories:\n    - other\ntags:\n    - other\n---\n\n\n### 设置markdown的默认打开工具\n\n\t- win+R组合键打开运行对话框,输入regedit,打开注册表编辑器\n\t- 定位到计算机HKEY_CLASSES_ROOT项\n\t- HKEY_CLASSES_ROOT 右击，选择 新建-项,命名为 .md\n\t- 选中.md(这个项),双击右边的默认项，打开编辑字符串对话框,写 md_auto_file 确定退出\n\t\t(格式：后缀名_auto_file，后缀名即为你要关联的文件类型，如要关联.html，就填写 html_auto_file)\n\t- 再次对着HKEY_CLASSES_ROOT项单右击,新建项,命名为 md_auto_file\n\t- 选中md_auto_file，新建-项 设置项名为: HKEY_CLASSES_ROOTmd_auto_fileshellopencommand, 设置右边默认值为:\"sublime安装路径 %1\",\n\t\t例如:  \"D:\\sublime\\Sublime Text 3\\sublime_text.exe\" %1 [注意添加英文状态下的双引号及后面的 %1与前面有空格]\n\t- 定位到HKEY_CURRENT_USER/Software/classes，重复以上的步骤创建 .md, md_auto_file项并设值\n\t- 退出注册表编辑器,此时md文件已经关联到sublime，右键点击md文件你会发现右键菜单第一项变成了\"打开\"","slug":"set_markdown_sublime","published":1,"updated":"2020-07-11T02:34:19.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckch1k2xz0001gkvum426vw1x","content":"<h3 id=\"设置markdown的默认打开工具\"><a href=\"#设置markdown的默认打开工具\" class=\"headerlink\" title=\"设置markdown的默认打开工具\"></a>设置markdown的默认打开工具</h3><pre><code>- win+R组合键打开运行对话框,输入regedit,打开注册表编辑器\n- 定位到计算机HKEY_CLASSES_ROOT项\n- HKEY_CLASSES_ROOT 右击，选择 新建-项,命名为 .md\n- 选中.md(这个项),双击右边的默认项，打开编辑字符串对话框,写 md_auto_file 确定退出\n    (格式：后缀名_auto_file，后缀名即为你要关联的文件类型，如要关联.html，就填写 html_auto_file)\n- 再次对着HKEY_CLASSES_ROOT项单右击,新建项,命名为 md_auto_file\n- 选中md_auto_file，新建-项 设置项名为: HKEY_CLASSES_ROOTmd_auto_fileshellopencommand, 设置右边默认值为:&quot;sublime安装路径 %1&quot;,\n    例如:  &quot;D:\\sublime\\Sublime Text 3\\sublime_text.exe&quot; %1 [注意添加英文状态下的双引号及后面的 %1与前面有空格]\n- 定位到HKEY_CURRENT_USER/Software/classes，重复以上的步骤创建 .md, md_auto_file项并设值\n- 退出注册表编辑器,此时md文件已经关联到sublime，右键点击md文件你会发现右键菜单第一项变成了&quot;打开&quot;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"设置markdown的默认打开工具\"><a href=\"#设置markdown的默认打开工具\" class=\"headerlink\" title=\"设置markdown的默认打开工具\"></a>设置markdown的默认打开工具</h3><pre><code>- win+R组合键打开运行对话框,输入regedit,打开注册表编辑器\n- 定位到计算机HKEY_CLASSES_ROOT项\n- HKEY_CLASSES_ROOT 右击，选择 新建-项,命名为 .md\n- 选中.md(这个项),双击右边的默认项，打开编辑字符串对话框,写 md_auto_file 确定退出\n    (格式：后缀名_auto_file，后缀名即为你要关联的文件类型，如要关联.html，就填写 html_auto_file)\n- 再次对着HKEY_CLASSES_ROOT项单右击,新建项,命名为 md_auto_file\n- 选中md_auto_file，新建-项 设置项名为: HKEY_CLASSES_ROOTmd_auto_fileshellopencommand, 设置右边默认值为:&quot;sublime安装路径 %1&quot;,\n    例如:  &quot;D:\\sublime\\Sublime Text 3\\sublime_text.exe&quot; %1 [注意添加英文状态下的双引号及后面的 %1与前面有空格]\n- 定位到HKEY_CURRENT_USER/Software/classes，重复以上的步骤创建 .md, md_auto_file项并设值\n- 退出注册表编辑器,此时md文件已经关联到sublime，右键点击md文件你会发现右键菜单第一项变成了&quot;打开&quot;\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjq3l8d4r00065shabmnjpnz6","category_id":"cjq3n8krv0000vchalnmbr5nu","_id":"cjq3n8ks80003vcha72ofecpy"},{"post_id":"cjl25n9qt000114havn5krktm","category_id":"cjq3n8ks70002vchazebfifa2","_id":"cjq3n8ksb0005vchavlf5m8gl"},{"post_id":"cjq3l8d4e00005sha3zdmzvsc","category_id":"cjq3n8ks70002vchazebfifa2","_id":"cjq3n8ksd0007vcha6b6mn1s2"},{"post_id":"cjq3l8d4l00015shaqc9zy2co","category_id":"cjq3n8ks70002vchazebfifa2","_id":"cjq3n8ksf000avcha0qqm386n"},{"post_id":"cjl25n9ql000014ha1u2c0bgx","category_id":"cjq3n8ks70002vchazebfifa2","_id":"cjq3n8ksh000dvchaqf206oey"},{"post_id":"cjq3l8d4q00045shak3a7tmmh","category_id":"cjq3n8ksg000cvchad0ikrl2q","_id":"cjq3n8ksl000jvchallareftc"},{"post_id":"cjl25n9r4000614har5z5alhd","category_id":"cjq3n8ks70002vchazebfifa2","_id":"cjq3n8kso000kvchaulflye7g"},{"post_id":"cjq3l8d4p00035sha3cs7okq0","category_id":"cjq3n8ksi000fvchaj9ydz1l6","_id":"cjq3n8ksq000mvchazxjcqfyn"},{"post_id":"cjq3l8d4q00055shaaxspi6lt","category_id":"cjq3n8ksi000fvchaj9ydz1l6","_id":"cjq3n8kss000pvchaz6ld86uq"},{"post_id":"cjq3l8d4s00085sha9whvdw9w","category_id":"cjq3n8ks70002vchazebfifa2","_id":"cjq3n8kst000qvcha3l7zw401"},{"post_id":"cjj6hwjnv0004lihaonla0ilw","category_id":"cjq3n8ksi000fvchaj9ydz1l6","_id":"cjq3n8ksw000wvchaufpz46ri"},{"post_id":"cjl25n9r9000914ha0av17nol","category_id":"cjq3n8ksu000svchav1el1mt4","_id":"cjq3n8ksx000zvchagvdnsova"},{"post_id":"cjlnekoha0001jshaapuypctk","category_id":"cjq3n8ksu000svchav1el1mt4","_id":"cjq3n8ksx0010vcha6r01hui0"},{"post_id":"ck9o1sea000000svum9wrk6ph","category_id":"cjq3n8ks70002vchazebfifa2","_id":"ck9o1seas00020svuyjm1gx42"},{"post_id":"ckch1k2xl0000gkvuqpwbmd8u","category_id":"cjq3n8ksi000fvchaj9ydz1l6","_id":"ckch1k2ym0004gkvu36vxts8t"},{"post_id":"ckch1k2xz0001gkvum426vw1x","category_id":"cjq3n8ksu000svchav1el1mt4","_id":"ckch1k2yp0005gkvu244qi4w4"}],"PostTag":[{"post_id":"cjq3l8d4e00005sha3zdmzvsc","tag_id":"cjq3nw0t60000iohamwmx98d3","_id":"cjq3nw0tq0004iohaylkozwzq"},{"post_id":"cjl25n9ql000014ha1u2c0bgx","tag_id":"cjq3nw0t60000iohamwmx98d3","_id":"cjq3nw0ts0007iohaq0poy0mw"},{"post_id":"cjq3l8d4l00015shaqc9zy2co","tag_id":"cjq3nw0t60000iohamwmx98d3","_id":"cjq3nw0tt0008iohaq1uy1y5w"},{"post_id":"cjq3l8d4r00065shabmnjpnz6","tag_id":"cjq3nw0ty000ciohaummbnkmm","_id":"cjq3nw0u2000giohaptlhldin"},{"post_id":"cjq3l8d4q00045shak3a7tmmh","tag_id":"cjq3nw0u1000fiohaxv0lwucl","_id":"cjq3nw0u8000liohacvhz98cy"},{"post_id":"cjq3l8d4p00035sha3cs7okq0","tag_id":"cjq3nw0u1000fiohaxv0lwucl","_id":"cjq3nw0uj000siohabyhpnqex"},{"post_id":"cjj6hwjnv0004lihaonla0ilw","tag_id":"cjq3nw0u8000kioha3t0anq1s","_id":"cjq3nw0ul000wiohah5lr6hx4"},{"post_id":"cjl25n9r9000914ha0av17nol","tag_id":"cjq3nw0uf000niohaqno4gjth","_id":"cjq3nw0ul000yiohasvhmizwj"},{"post_id":"cjl25n9qt000114havn5krktm","tag_id":"cjq3nw0t60000iohamwmx98d3","_id":"cjq3nw0um000ziohazu8o82ie"},{"post_id":"cjl25n9qt000114havn5krktm","tag_id":"cjq3nw0uf000niohaqno4gjth","_id":"cjq3nw0um0011iohar5v2q6rg"},{"post_id":"cjq3l8d4s00085sha9whvdw9w","tag_id":"cjq3nw0ui000qiohaqnla9tzp","_id":"cjq3nw0un0012iohaigna08qu"},{"post_id":"cjq3l8d4s00085sha9whvdw9w","tag_id":"cjq3nw0uk000uiohah4xqebtr","_id":"cjq3nw0un0014iohah21knv7z"},{"post_id":"cjq3l8d4s00085sha9whvdw9w","tag_id":"cjq3nw0t60000iohamwmx98d3","_id":"cjq3nw0uo0015iohalu8v9abq"},{"post_id":"cjlnekoha0001jshaapuypctk","tag_id":"cjq3nw0uo0016iohav35leary","_id":"cjq3nw0up001bioha50vlhav5"},{"post_id":"cjl25n9r4000614har5z5alhd","tag_id":"cjq3nw0uo001aioha8cruzena","_id":"cjq3nw0uq001diohaol2ymif0"},{"post_id":"cjl25n9r4000614har5z5alhd","tag_id":"cjq3nw0t60000iohamwmx98d3","_id":"cjq3nw0uq001eioha0clhd83m"},{"post_id":"cjq3l8d4q00055shaaxspi6lt","tag_id":"cjq3nw0up001cioha6y0uano7","_id":"cjq3nw0uq001fioha83bothdv"},{"post_id":"ck9o1sea000000svum9wrk6ph","tag_id":"cjq3nw0um0010iohao6bl4n7z","_id":"ck9o1seap00010svuf4fl2hd7"},{"post_id":"ckch1k2xl0000gkvuqpwbmd8u","tag_id":"cjq3nw0u1000fiohaxv0lwucl","_id":"ckch1k2y50002gkvuf5gzufzi"},{"post_id":"ckch1k2xz0001gkvum426vw1x","tag_id":"ckch1k2y60003gkvubat5v2hg","_id":"ckch1k2yr0006gkvu7sk0ak26"}],"Tag":[{"name":"ceph","_id":"cjq3nw0t60000iohamwmx98d3"},{"name":"eth","_id":"cjq3nw0tp0003iohakh00kare"},{"name":"solidity","_id":"cjq3nw0ts0006iohambzgjqjz"},{"name":"c++11","_id":"cjq3nw0ty000ciohaummbnkmm"},{"name":"golang","_id":"cjq3nw0u1000fiohaxv0lwucl"},{"name":"goroutine","_id":"cjq3nw0u8000kioha3t0anq1s"},{"name":"snapshot","_id":"cjq3nw0uf000niohaqno4gjth"},{"name":"s3","_id":"cjq3nw0ui000qiohaqnla9tzp"},{"name":"rgw","_id":"cjq3nw0uk000uiohah4xqebtr"},{"name":"paxos","_id":"cjq3nw0um0010iohao6bl4n7z"},{"name":"ipfs","_id":"cjq3nw0un0013iohanvxkq6ro"},{"name":"ssd","_id":"cjq3nw0uo0016iohav35leary"},{"name":"librbd","_id":"cjq3nw0uo001aioha8cruzena"},{"name":"cache","_id":"cjq3nw0up001cioha6y0uano7"},{"name":"other","_id":"ckch1k2y60003gkvubat5v2hg"}]}}