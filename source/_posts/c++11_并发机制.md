## c++11中并发机制

- [c++11 lock](#c++11_lock)  
  - [lock_guard实现](#lock_guard实现)
  - [unique_lock实现](#unique_lock实现)

### <span id='c++11_lock'/> c++11 lock

  std::unique_lock与std::lock_guard两种对底层lock的封装
 
  - std::lock_guard：对lock的RAII的封装，构造函数中加锁，析构函数中解锁。通过对象的生命周期管理来保证函数退出时，锁一定被释放。
  - std::unique_lock: std::lock_guard的升级版，封装了各种加锁操作，阻塞或非阻塞的，还可以**条件变量一起使用** 。内存开销比std::lock_guard要大的多~
  
```c++
std::unique_lock<std::mutex> lk(_mutex);
std::condition_variable cv;
cv.wait(lk, []{return ready;});
```

### lock_guard实现

<details>
<summary>lock_guard</summary>

```c++
template <class _Mutex>
{
public:
  typedef _Mutex mutex_type;

private:
  mutex_type& __m_;

public:
  _LIBCPP_INLINE_VISIBILITY  //该宏含义?
  explicit lock_guard(mutex_type& __m)
    :__m_(__m){__m_.lock();}
  _LIBCPP_INLINE_VISIBILITY
  
  lock_guard(mutex_type& __m, adopt_lock_t)
    :__m_(__m) {}
  __LIBCPP_INLINE_VISIBILITY
  
  ~lock_guard() { __m_.unlock(); }

private:
  lock_guard(lock_guard const&);  // = delete; 
  lock_guard& operator=(lock_guard const&);  // = delete;
};
```
</details>

### unique_lock实现

<details>
<summary>unique_lock</summary>

```c++
template <class _Mutex>
{
public:
  typedef _Mutex mutex_type;

private:
  mutex_type* __m_;
  bool __owns_;
  
public:
  __LIBCPP_INLINE_VISIBILITY
  unique_lock() _NOEXCEPT : __m_(nullptr), __owns_(false) {}
  __LIBCPP_INLINE_VISIBILITY
  explicit unique_lock(mutex_type& __m)
    :__m_(__m), __owns_(true) {__m_->lock();}
  __LIBCPP_INLINE_VISIBILITY
  
  unique_lock(mutex_type& __m, defer_lock_t) _NOEXCEPT    // 延迟加锁
    :__m_(__m), __owns_(false) {}
  __LIBCPP_INLINE_VISIBILITY 
  
  unique_lock(mutex_type& __m, try_to_lock_t)            // 尝试加锁
    :__m_(&__m), __owns_(__m.try_lock()){}
  __LIBCPP_INLINE_VISIBILITY
  
  unique_lock(mutex_type& __m, adopt_lock_t)            // 马上加锁
    :__m_(&__m), __owns_(true) {}
    
 template<class _Clock, class _Duration>
 _LIBCPP_INLINE_VISIBILITY
    unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __d)
      :__m_(&__m), __owns_(__m.try_lock_for(__d)) {}
 _LIBCPP_INLINE_VISIBILITY
 
 ~unique_lock()
 {
  if(__owns_)
    __m_->unlock();
 }

private:
  unique_lock(unique_lock const&); // = delete;
  unique_lock&  operator=(unique_lock const &); // = delete;

public:
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY 
    unique_lock(unique_lock&& __u) _NOEXCEPT  //右值引用
        : __m_(__u.__m_), __owns_(__u.__owns_)
        {__u.__m_ = nullptr; __u.__owns_ = false;}
    _LIBCPP_INLINE_VISIBILITY
    unique_lock& operator=(unique_lock&& __u) _NOEXCEPT
        {
            if (__owns_)
                __m_->unlock();
            __m_ = __u.__m_;
            __owns_ = __u.__owns_;
            __u.__m_ = nullptr;
            __u.__owns_ = false;
            return *this;
        }
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
</details>
